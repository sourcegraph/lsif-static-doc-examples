{
  "pathID": "/std/reflect",
  "documentation": {
    "identifier": "reflect",
    "newPage": true,
    "searchKey": "std/reflect",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package reflect"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type. \n\nA call to ValueOf returns a Value representing the run-time data. Zero takes a Type and returns a Value representing a zero value for that type. \n\nSee \"The Laws of Reflection\" for an introduction to reflection in Go: [https://golang.org/doc/articles/laws_of_reflection.html](https://golang.org/doc/articles/laws_of_reflection.html) \n\n"
  },
  "children": [
    {
      "pathID": "/std/reflect/internal"
    },
    {
      "node": {
        "pathID": "/std/reflect#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/reflect#abiStepBad",
              "documentation": {
                "identifier": "abiStepBad",
                "newPage": false,
                "searchKey": "reflect.abiStepBad",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const abiStepBad"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst abiStepBad abiStepKind = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#abiStepStack",
              "documentation": {
                "identifier": "abiStepStack",
                "newPage": false,
                "searchKey": "reflect.abiStepStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const abiStepStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst abiStepStack // copy to/from stack\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#abiStepIntReg",
              "documentation": {
                "identifier": "abiStepIntReg",
                "newPage": false,
                "searchKey": "reflect.abiStepIntReg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const abiStepIntReg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst abiStepIntReg // copy to/from integer register\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#abiStepPointer",
              "documentation": {
                "identifier": "abiStepPointer",
                "newPage": false,
                "searchKey": "reflect.abiStepPointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const abiStepPointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst abiStepPointer // copy pointer to/from integer register\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#abiStepFloatReg",
              "documentation": {
                "identifier": "abiStepFloatReg",
                "newPage": false,
                "searchKey": "reflect.abiStepFloatReg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const abiStepFloatReg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst abiStepFloatReg // copy to/from FP register\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Invalid",
              "documentation": {
                "identifier": "Invalid",
                "newPage": false,
                "searchKey": "reflect.Invalid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Invalid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Invalid Kind = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Bool",
              "documentation": {
                "identifier": "Bool",
                "newPage": false,
                "searchKey": "reflect.Bool",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Int",
              "documentation": {
                "identifier": "Int",
                "newPage": false,
                "searchKey": "reflect.Int",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Int8",
              "documentation": {
                "identifier": "Int8",
                "newPage": false,
                "searchKey": "reflect.Int8",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Int16",
              "documentation": {
                "identifier": "Int16",
                "newPage": false,
                "searchKey": "reflect.Int16",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Int32",
              "documentation": {
                "identifier": "Int32",
                "newPage": false,
                "searchKey": "reflect.Int32",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Int64",
              "documentation": {
                "identifier": "Int64",
                "newPage": false,
                "searchKey": "reflect.Int64",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Uint",
              "documentation": {
                "identifier": "Uint",
                "newPage": false,
                "searchKey": "reflect.Uint",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Uint8",
              "documentation": {
                "identifier": "Uint8",
                "newPage": false,
                "searchKey": "reflect.Uint8",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Uint16",
              "documentation": {
                "identifier": "Uint16",
                "newPage": false,
                "searchKey": "reflect.Uint16",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Uint32",
              "documentation": {
                "identifier": "Uint32",
                "newPage": false,
                "searchKey": "reflect.Uint32",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Uint64",
              "documentation": {
                "identifier": "Uint64",
                "newPage": false,
                "searchKey": "reflect.Uint64",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Uintptr",
              "documentation": {
                "identifier": "Uintptr",
                "newPage": false,
                "searchKey": "reflect.Uintptr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Float32",
              "documentation": {
                "identifier": "Float32",
                "newPage": false,
                "searchKey": "reflect.Float32",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Float32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Float32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Float64",
              "documentation": {
                "identifier": "Float64",
                "newPage": false,
                "searchKey": "reflect.Float64",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Float64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Complex64",
              "documentation": {
                "identifier": "Complex64",
                "newPage": false,
                "searchKey": "reflect.Complex64",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Complex64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Complex64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Complex128",
              "documentation": {
                "identifier": "Complex128",
                "newPage": false,
                "searchKey": "reflect.Complex128",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Complex128"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Complex128\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Array",
              "documentation": {
                "identifier": "Array",
                "newPage": false,
                "searchKey": "reflect.Array",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Array"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Array\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Chan",
              "documentation": {
                "identifier": "Chan",
                "newPage": false,
                "searchKey": "reflect.Chan",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Chan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Chan\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Func",
              "documentation": {
                "identifier": "Func",
                "newPage": false,
                "searchKey": "reflect.Func",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Func"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Func\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Interface",
              "documentation": {
                "identifier": "Interface",
                "newPage": false,
                "searchKey": "reflect.Interface",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Interface\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Map",
              "documentation": {
                "identifier": "Map",
                "newPage": false,
                "searchKey": "reflect.Map",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Map"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Map\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Ptr",
              "documentation": {
                "identifier": "Ptr",
                "newPage": false,
                "searchKey": "reflect.Ptr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Ptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Ptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Slice",
              "documentation": {
                "identifier": "Slice",
                "newPage": false,
                "searchKey": "reflect.Slice",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Slice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Slice\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#String",
              "documentation": {
                "identifier": "String",
                "newPage": false,
                "searchKey": "reflect.String",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const String"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst String\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Struct",
              "documentation": {
                "identifier": "Struct",
                "newPage": false,
                "searchKey": "reflect.Struct",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Struct\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#UnsafePointer",
              "documentation": {
                "identifier": "UnsafePointer",
                "newPage": false,
                "searchKey": "reflect.UnsafePointer",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const UnsafePointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UnsafePointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#tflagUncommon",
              "documentation": {
                "identifier": "tflagUncommon",
                "newPage": false,
                "searchKey": "reflect.tflagUncommon",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tflagUncommon"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tflagUncommon tflag = 1 << 0\n```\n\ntflagUncommon means that there is a pointer, *uncommonType, just beyond the outer type structure. \n\nFor example, if t.Kind() == Struct and t.tflag&tflagUncommon != 0, then t has uncommonType data and it can be accessed as: \n\n```\ntype tUncommon struct {\n\tstructType\n\tu uncommonType\n}\nu := &(*tUncommon)(unsafe.Pointer(t)).u\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#tflagExtraStar",
              "documentation": {
                "identifier": "tflagExtraStar",
                "newPage": false,
                "searchKey": "reflect.tflagExtraStar",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tflagExtraStar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tflagExtraStar tflag = 1 << 1\n```\n\ntflagExtraStar means the name in the str field has an extraneous '*' prefix. This is because for most types T in a program, the type *T also exists and reusing the str data saves binary size. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#tflagNamed",
              "documentation": {
                "identifier": "tflagNamed",
                "newPage": false,
                "searchKey": "reflect.tflagNamed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tflagNamed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tflagNamed tflag = 1 << 2\n```\n\ntflagNamed means the type has a name. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#tflagRegularMemory",
              "documentation": {
                "identifier": "tflagRegularMemory",
                "newPage": false,
                "searchKey": "reflect.tflagRegularMemory",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tflagRegularMemory"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tflagRegularMemory tflag = 1 << 3\n```\n\ntflagRegularMemory means that equal and hash functions can treat this type as a single region of t.size bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#RecvDir",
              "documentation": {
                "identifier": "RecvDir",
                "newPage": false,
                "searchKey": "reflect.RecvDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RecvDir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RecvDir ChanDir = 1 << iota // <-chan\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#SendDir",
              "documentation": {
                "identifier": "SendDir",
                "newPage": false,
                "searchKey": "reflect.SendDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SendDir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SendDir // chan<-\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#BothDir",
              "documentation": {
                "identifier": "BothDir",
                "newPage": false,
                "searchKey": "reflect.BothDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const BothDir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst BothDir = RecvDir | SendDir // chan\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#kindDirectIface",
              "documentation": {
                "identifier": "kindDirectIface",
                "newPage": false,
                "searchKey": "reflect.kindDirectIface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindDirectIface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindDirectIface = 1 << 5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#kindGCProg",
              "documentation": {
                "identifier": "kindGCProg",
                "newPage": false,
                "searchKey": "reflect.kindGCProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindGCProg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindGCProg = 1 << 6 // Type.gc points to GC program\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#kindMask",
              "documentation": {
                "identifier": "kindMask",
                "newPage": false,
                "searchKey": "reflect.kindMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindMask = (1 << 5) - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#bucketSize",
              "documentation": {
                "identifier": "bucketSize",
                "newPage": false,
                "searchKey": "reflect.bucketSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bucketSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bucketSize uintptr = 8\n```\n\nMake sure these routines stay in sync with ../../runtime/map.go! These types exist only for GC, so we only fill out GC relevant info. Currently, that's just size and the GC program. We also fill in string for possible debugging use. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#maxKeySize",
              "documentation": {
                "identifier": "maxKeySize",
                "newPage": false,
                "searchKey": "reflect.maxKeySize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxKeySize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxKeySize uintptr = 128\n```\n\nMake sure these routines stay in sync with ../../runtime/map.go! These types exist only for GC, so we only fill out GC relevant info. Currently, that's just size and the GC program. We also fill in string for possible debugging use. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#maxValSize",
              "documentation": {
                "identifier": "maxValSize",
                "newPage": false,
                "searchKey": "reflect.maxValSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxValSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxValSize uintptr = 128\n```\n\nMake sure these routines stay in sync with ../../runtime/map.go! These types exist only for GC, so we only fill out GC relevant info. Currently, that's just size and the GC program. We also fill in string for possible debugging use. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#maxPtrmaskBytes",
              "documentation": {
                "identifier": "maxPtrmaskBytes",
                "newPage": false,
                "searchKey": "reflect.maxPtrmaskBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxPtrmaskBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxPtrmaskBytes = 2048\n```\n\nSee cmd/compile/internal/gc/reflect.go for derivation of constant. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#ptrSize",
              "documentation": {
                "identifier": "ptrSize",
                "newPage": false,
                "searchKey": "reflect.ptrSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ptrSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ptrSize = 4 << (^uintptr(0) >> 63) // unsafe.Sizeof(uintptr(0)) but an ideal const\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flagKindWidth",
              "documentation": {
                "identifier": "flagKindWidth",
                "newPage": false,
                "searchKey": "reflect.flagKindWidth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagKindWidth"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagKindWidth = 5 // there are 27 kinds\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flagKindMask",
              "documentation": {
                "identifier": "flagKindMask",
                "newPage": false,
                "searchKey": "reflect.flagKindMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagKindMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagKindMask flag = 1<<flagKindWidth - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flagStickyRO",
              "documentation": {
                "identifier": "flagStickyRO",
                "newPage": false,
                "searchKey": "reflect.flagStickyRO",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagStickyRO"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagStickyRO flag = 1 << 5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flagEmbedRO",
              "documentation": {
                "identifier": "flagEmbedRO",
                "newPage": false,
                "searchKey": "reflect.flagEmbedRO",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagEmbedRO"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagEmbedRO flag = 1 << 6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flagIndir",
              "documentation": {
                "identifier": "flagIndir",
                "newPage": false,
                "searchKey": "reflect.flagIndir",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagIndir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagIndir flag = 1 << 7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flagAddr",
              "documentation": {
                "identifier": "flagAddr",
                "newPage": false,
                "searchKey": "reflect.flagAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagAddr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagAddr flag = 1 << 8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flagMethod",
              "documentation": {
                "identifier": "flagMethod",
                "newPage": false,
                "searchKey": "reflect.flagMethod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagMethod"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagMethod flag = 1 << 9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flagMethodShift",
              "documentation": {
                "identifier": "flagMethodShift",
                "newPage": false,
                "searchKey": "reflect.flagMethodShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagMethodShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagMethodShift = 10\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flagRO",
              "documentation": {
                "identifier": "flagRO",
                "newPage": false,
                "searchKey": "reflect.flagRO",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagRO"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagRO flag = flagStickyRO | flagEmbedRO\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#debugReflectCall",
              "documentation": {
                "identifier": "debugReflectCall",
                "newPage": false,
                "searchKey": "reflect.debugReflectCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugReflectCall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugReflectCall = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#SelectSend",
              "documentation": {
                "identifier": "SelectSend",
                "newPage": false,
                "searchKey": "reflect.SelectSend",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SelectSend"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SelectSend // case Chan <- Send\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#SelectRecv",
              "documentation": {
                "identifier": "SelectRecv",
                "newPage": false,
                "searchKey": "reflect.SelectRecv",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SelectRecv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SelectRecv // case <-Chan:\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#SelectDefault",
              "documentation": {
                "identifier": "SelectDefault",
                "newPage": false,
                "searchKey": "reflect.SelectDefault",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SelectDefault"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SelectDefault // default\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#maxZero",
              "documentation": {
                "identifier": "maxZero",
                "newPage": false,
                "searchKey": "reflect.maxZero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxZero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxZero = 1024\n```\n\nmust match declarations in runtime/map.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#PtrSize",
              "documentation": {
                "identifier": "PtrSize",
                "newPage": false,
                "searchKey": "reflect.PtrSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const PtrSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PtrSize = ptrSize\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/reflect#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/reflect#intArgRegs",
              "documentation": {
                "identifier": "intArgRegs",
                "newPage": false,
                "searchKey": "reflect.intArgRegs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var intArgRegs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar intArgRegs = abi.IntArgRegs * goexperiment.RegabiArgsInt\n```\n\nThese variables are used by the register assignment algorithm in this file. \n\nThey should be modified with care (no other reflect code may be executing) and are generally only modified when testing this package. \n\nThey should never be set higher than their internal/abi constant counterparts, because the system relies on a structure that is at least large enough to hold the registers the system supports. \n\nCurrently they're set to zero because using the actual constants will break every part of the toolchain that uses reflect to call functions (e.g. go test, or anything that uses text/template). The values that are currently commented out there should be the actual values once we're ready to use the register ABI everywhere. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#floatArgRegs",
              "documentation": {
                "identifier": "floatArgRegs",
                "newPage": false,
                "searchKey": "reflect.floatArgRegs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var floatArgRegs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar floatArgRegs = abi.FloatArgRegs * goexperiment.RegabiArgsInt\n```\n\nThese variables are used by the register assignment algorithm in this file. \n\nThey should be modified with care (no other reflect code may be executing) and are generally only modified when testing this package. \n\nThey should never be set higher than their internal/abi constant counterparts, because the system relies on a structure that is at least large enough to hold the registers the system supports. \n\nCurrently they're set to zero because using the actual constants will break every part of the toolchain that uses reflect to call functions (e.g. go test, or anything that uses text/template). The values that are currently commented out there should be the actual values once we're ready to use the register ABI everywhere. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#floatRegSize",
              "documentation": {
                "identifier": "floatRegSize",
                "newPage": false,
                "searchKey": "reflect.floatRegSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var floatRegSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar floatRegSize = uintptr(abi.EffectiveFloatRegSize * goexperiment.RegabiArgsInt)\n```\n\nThese variables are used by the register assignment algorithm in this file. \n\nThey should be modified with care (no other reflect code may be executing) and are generally only modified when testing this package. \n\nThey should never be set higher than their internal/abi constant counterparts, because the system relies on a structure that is at least large enough to hold the registers the system supports. \n\nCurrently they're set to zero because using the actual constants will break every part of the toolchain that uses reflect to call functions (e.g. go test, or anything that uses text/template). The values that are currently commented out there should be the actual values once we're ready to use the register ABI everywhere. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#kindNames",
              "documentation": {
                "identifier": "kindNames",
                "newPage": false,
                "searchKey": "reflect.kindNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var kindNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar kindNames = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#ptrMap",
              "documentation": {
                "identifier": "ptrMap",
                "newPage": false,
                "searchKey": "reflect.ptrMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ptrMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ptrMap sync.Map // map[*rtype]*ptrType\n\n```\n\nptrMap is the cache for PtrTo. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#lookupCache",
              "documentation": {
                "identifier": "lookupCache",
                "newPage": false,
                "searchKey": "reflect.lookupCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupCache sync.Map // map[cacheKey]*rtype\n\n```\n\nThe lookupCache caches ArrayOf, ChanOf, MapOf and SliceOf lookups. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcLookupCache",
              "documentation": {
                "identifier": "funcLookupCache",
                "newPage": false,
                "searchKey": "reflect.funcLookupCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var funcLookupCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar funcLookupCache struct {\n\tsync.Mutex // Guards stores (but not loads) on m.\n\n\t// m is a map[uint32][]*rtype keyed by the hash calculated in FuncOf.\n\t// Elements of m are append-only and thus safe for concurrent reading.\n\tm sync.Map\n} = ...\n```\n\nThe funcLookupCache caches FuncOf lookups. FuncOf does not share the common lookupCache since cacheKey is not sufficient to represent functions unambiguously. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#structLookupCache",
              "documentation": {
                "identifier": "structLookupCache",
                "newPage": false,
                "searchKey": "reflect.structLookupCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var structLookupCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar structLookupCache struct {\n\tsync.Mutex // Guards stores (but not loads) on m.\n\n\t// m is a map[uint32][]Type keyed by the hash calculated in StructOf.\n\t// Elements in m are append-only and thus safe for concurrent reading.\n\tm sync.Map\n} = ...\n```\n\nThe structLookupCache caches StructOf lookups. StructOf does not share the common lookupCache since we need to pin the memory associated with *structTypeFixedN. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#layoutCache",
              "documentation": {
                "identifier": "layoutCache",
                "newPage": false,
                "searchKey": "reflect.layoutCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var layoutCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar layoutCache sync.Map // map[layoutKey]layoutType\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#callGC",
              "documentation": {
                "identifier": "callGC",
                "newPage": false,
                "searchKey": "reflect.callGC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var callGC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar callGC bool // for testing; see TestCallMethodJump\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#uint8Type",
              "documentation": {
                "identifier": "uint8Type",
                "newPage": false,
                "searchKey": "reflect.uint8Type",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var uint8Type"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uint8Type = TypeOf(uint8(0)).(*rtype)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#zeroVal",
              "documentation": {
                "identifier": "zeroVal",
                "newPage": false,
                "searchKey": "reflect.zeroVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var zeroVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zeroVal [maxZero]byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#dummy",
              "documentation": {
                "identifier": "dummy",
                "newPage": false,
                "searchKey": "reflect.dummy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dummy"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dummy struct {\n\tb bool\n\tx interface{}\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#CallGC",
              "documentation": {
                "identifier": "CallGC",
                "newPage": false,
                "searchKey": "reflect.CallGC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var CallGC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar CallGC = &callGC\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#GCBits",
              "documentation": {
                "identifier": "GCBits",
                "newPage": false,
                "searchKey": "reflect.GCBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var GCBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar GCBits = gcbits\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#pinUnexpMethI",
              "documentation": {
                "identifier": "pinUnexpMethI",
                "newPage": false,
                "searchKey": "reflect.pinUnexpMethI",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var pinUnexpMethI"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar pinUnexpMethI = pinUnexpMeth(EmbedWithUnexpMeth{})\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/reflect#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/reflect#abiStep",
              "documentation": {
                "identifier": "abiStep",
                "newPage": false,
                "searchKey": "reflect.abiStep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type abiStep struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype abiStep struct {\n\tkind abiStepKind\n\n\t// offset and size together describe a part of a Go value\n\t// in memory.\n\toffset uintptr\n\tsize   uintptr // size in bytes of the part\n\n\t// These fields describe the ABI side of the translation.\n\tstkOff uintptr // stack offset, used if kind == abiStepStack\n\tireg   int     // integer register index, used if kind == abiStepIntReg or kind == abiStepPointer\n\tfreg   int     // FP register index, used if kind == abiStepFloatReg\n}\n```\n\nabiStep represents an ABI \"instruction.\" Each instruction describes one part of how to translate between a Go value in memory and a call frame. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#abiStepKind",
              "documentation": {
                "identifier": "abiStepKind",
                "newPage": false,
                "searchKey": "reflect.abiStepKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type abiStepKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype abiStepKind int\n```\n\nabiStepKind is the \"op-code\" for an abiStep instruction. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#abiSeq",
              "documentation": {
                "identifier": "abiSeq",
                "newPage": false,
                "searchKey": "reflect.abiSeq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type abiSeq struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype abiSeq struct {\n\t// steps is the set of instructions.\n\t//\n\t// The instructions are grouped together by whole arguments,\n\t// with the starting index for the instructions\n\t// of the i'th Go value available in valueStart.\n\t//\n\t// For instance, if this abiSeq represents 3 arguments\n\t// passed to a function, then the 2nd argument's steps\n\t// begin at steps[valueStart[1]].\n\t//\n\t// Because reflect accepts Go arguments in distinct\n\t// Values and each Value is stored separately, each abiStep\n\t// that begins a new argument will have its offset\n\t// field == 0.\n\tsteps      []abiStep\n\tvalueStart []int\n\n\tstackBytes   uintptr // stack space used\n\tiregs, fregs int     // registers used\n}\n```\n\nabiSeq represents a sequence of ABI instructions for copying from a series of reflect.Values to a call frame (for call arguments) or vice-versa (for call results). \n\nAn abiSeq should be populated by calling its addArg method. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#abiSeq.dump",
                    "documentation": {
                      "identifier": "abiSeq.dump",
                      "newPage": false,
                      "searchKey": "reflect.abiSeq.dump",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *abiSeq) dump()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *abiSeq) dump()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#abiSeq.stepsForValue",
                    "documentation": {
                      "identifier": "abiSeq.stepsForValue",
                      "newPage": false,
                      "searchKey": "reflect.abiSeq.stepsForValue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *abiSeq) stepsForValue(i int) []abiStep"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *abiSeq) stepsForValue(i int) []abiStep\n```\n\nstepsForValue returns the ABI instructions for translating the i'th Go argument or return value represented by this abiSeq to the Go ABI. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#abiSeq.addArg",
                    "documentation": {
                      "identifier": "abiSeq.addArg",
                      "newPage": false,
                      "searchKey": "reflect.abiSeq.addArg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *abiSeq) addArg(t *rtype) *abiStep"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *abiSeq) addArg(t *rtype) *abiStep\n```\n\naddArg extends the abiSeq with a new Go value of type t. \n\nIf the value was stack-assigned, returns the single abiStep describing that translation, and nil otherwise. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#abiSeq.addRcvr",
                    "documentation": {
                      "identifier": "abiSeq.addRcvr",
                      "newPage": false,
                      "searchKey": "reflect.abiSeq.addRcvr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *abiSeq) addRcvr(rcvr *rtype) (*abiStep, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *abiSeq) addRcvr(rcvr *rtype) (*abiStep, bool)\n```\n\naddRcvr extends the abiSeq with a new method call receiver according to the interface calling convention. \n\nIf the receiver was stack-assigned, returns the single abiStep describing that translation, and nil otherwise. Returns true if the receiver is a pointer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#abiSeq.regAssign",
                    "documentation": {
                      "identifier": "abiSeq.regAssign",
                      "newPage": false,
                      "searchKey": "reflect.abiSeq.regAssign",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *abiSeq) regAssign(t *rtype, offset uintptr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *abiSeq) regAssign(t *rtype, offset uintptr) bool\n```\n\nregAssign attempts to reserve argument registers for a value of type t, stored at some offset. \n\nIt returns whether or not the assignment succeeded, but leaves any changes it made to a.steps behind, so the caller must undo that work by adjusting a.steps if it fails. \n\nThis method along with the assign* methods represent the complete register-assignment algorithm for the Go ABI. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#abiSeq.assignIntN",
                    "documentation": {
                      "identifier": "abiSeq.assignIntN",
                      "newPage": false,
                      "searchKey": "reflect.abiSeq.assignIntN",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *abiSeq) assignIntN(offset, size uintptr, n int, ptrMap uint8) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *abiSeq) assignIntN(offset, size uintptr, n int, ptrMap uint8) bool\n```\n\nassignIntN assigns n values to registers, each \"size\" bytes large, from the data at [offset, offset+n*size) in memory. Each value at [offset+i*size, offset+(i+1)*size) for i < n is assigned to the next n integer registers. \n\nBit i in ptrMap indicates whether the i'th value is a pointer. n must be <= 8. \n\nReturns whether assignment succeeded. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#abiSeq.assignFloatN",
                    "documentation": {
                      "identifier": "abiSeq.assignFloatN",
                      "newPage": false,
                      "searchKey": "reflect.abiSeq.assignFloatN",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *abiSeq) assignFloatN(offset, size uintptr, n int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *abiSeq) assignFloatN(offset, size uintptr, n int) bool\n```\n\nassignFloatN assigns n values to registers, each \"size\" bytes large, from the data at [offset, offset+n*size) in memory. Each value at [offset+i*size, offset+(i+1)*size) for i < n is assigned to the next n floating-point registers. \n\nReturns whether assignment succeeded. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#abiSeq.stackAssign",
                    "documentation": {
                      "identifier": "abiSeq.stackAssign",
                      "newPage": false,
                      "searchKey": "reflect.abiSeq.stackAssign",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *abiSeq) stackAssign(size, alignment uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *abiSeq) stackAssign(size, alignment uintptr)\n```\n\nstackAssign reserves space for one value that is \"size\" bytes large with alignment \"alignment\" to the stack. \n\nShould not be called directly; use addArg instead. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#abiDesc",
              "documentation": {
                "identifier": "abiDesc",
                "newPage": false,
                "searchKey": "reflect.abiDesc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type abiDesc struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype abiDesc struct {\n\t// call and ret represent the translation steps for\n\t// the call and return paths of a Go function.\n\tcall, ret abiSeq\n\n\t// These fields describe the stack space allocated\n\t// for the call. stackCallArgsSize is the amount of space\n\t// reserved for arguments but not return values. retOffset\n\t// is the offset at which return values begin, and\n\t// spill is the size in bytes of additional space reserved\n\t// to spill argument registers into in case of preemption in\n\t// reflectcall's stack frame.\n\tstackCallArgsSize, retOffset, spill uintptr\n\n\t// stackPtrs is a bitmap that indicates whether\n\t// each word in the ABI stack space (stack-assigned\n\t// args + return values) is a pointer. Used\n\t// as the heap pointer bitmap for stack space\n\t// passed to reflectcall.\n\tstackPtrs *bitVector\n\n\t// inRegPtrs is a bitmap whose i'th bit indicates\n\t// whether the i'th integer argument register contains\n\t// a pointer. Used by makeFuncStub and methodValueCall\n\t// to make result pointers visible to the GC.\n\t//\n\t// outRegPtrs is the same, but for result values.\n\t// Used by reflectcall to make result pointers visible\n\t// to the GC.\n\tinRegPtrs, outRegPtrs abi.IntArgRegBitmap\n}\n```\n\nabiDesc describes the ABI for a function or method. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#newAbiDesc",
                    "documentation": {
                      "identifier": "newAbiDesc",
                      "newPage": false,
                      "searchKey": "reflect.newAbiDesc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newAbiDesc(t *funcType, rcvr *rtype) abiDesc"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newAbiDesc(t *funcType, rcvr *rtype) abiDesc\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#funcLayout",
                    "documentation": {
                      "identifier": "funcLayout",
                      "newPage": false,
                      "searchKey": "reflect.funcLayout",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func funcLayout(t *funcType, rcvr *rtype) (frametype *rtype, framePool *sync.Pool, abi abiDesc)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc funcLayout(t *funcType, rcvr *rtype) (frametype *rtype, framePool *sync.Pool, abi abiDesc)\n```\n\nfuncLayout computes a struct type representing the layout of the stack-assigned function arguments and return values for the function type t. If rcvr != nil, rcvr specifies the type of the receiver. The returned type exists only for GC, so we only fill out GC relevant info. Currently, that's just size and the GC program. We also fill in the name for possible debugging use. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#abiDesc.dump",
                    "documentation": {
                      "identifier": "abiDesc.dump",
                      "newPage": false,
                      "searchKey": "reflect.abiDesc.dump",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *abiDesc) dump()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *abiDesc) dump()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#visit",
              "documentation": {
                "identifier": "visit",
                "newPage": false,
                "searchKey": "reflect.visit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type visit struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype visit struct {\n\ta1  unsafe.Pointer\n\ta2  unsafe.Pointer\n\ttyp Type\n}\n```\n\nDuring deepValueEqual, must keep track of checks that are in progress. The comparison algorithm assumes that all checks in progress are true when it reencounters them. Visited comparisons are stored in a map indexed by visit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#makeFuncImpl",
              "documentation": {
                "identifier": "makeFuncImpl",
                "newPage": false,
                "searchKey": "reflect.makeFuncImpl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type makeFuncImpl struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype makeFuncImpl struct {\n\tmakeFuncCtxt\n\tftyp *funcType\n\tfn   func([]Value) []Value\n}\n```\n\nmakeFuncImpl is the closure value implementing the function returned by MakeFunc. The first three words of this type must be kept in sync with methodValue and runtime.reflectMethodValue. Any changes should be reflected in all three. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#methodValue",
              "documentation": {
                "identifier": "methodValue",
                "newPage": false,
                "searchKey": "reflect.methodValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type methodValue struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype methodValue struct {\n\tmakeFuncCtxt\n\tmethod int\n\trcvr   Value\n}\n```\n\nThe first 3 words of this type must be kept in sync with makeFuncImpl and runtime.reflectMethodValue. Any changes should be reflected in all three. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#makeFuncCtxt",
              "documentation": {
                "identifier": "makeFuncCtxt",
                "newPage": false,
                "searchKey": "reflect.makeFuncCtxt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type makeFuncCtxt struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype makeFuncCtxt struct {\n\tfn      uintptr\n\tstack   *bitVector // ptrmap for both stack args and results\n\targLen  uintptr    // just args\n\tregPtrs abi.IntArgRegBitmap\n}\n```\n\nThis structure must be kept in sync with runtime.reflectMethodValue. Any changes should be reflected in all both. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Type",
              "documentation": {
                "identifier": "Type",
                "newPage": false,
                "searchKey": "reflect.Type",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Type interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Type interface {\n\n\t// Align returns the alignment in bytes of a value of\n\t// this type when allocated in memory.\n\tAlign() int\n\n\t// FieldAlign returns the alignment in bytes of a value of\n\t// this type when used as a field in a struct.\n\tFieldAlign() int\n\n\t// Method returns the i'th method in the type's method set.\n\t// It panics if i is not in the range [0, NumMethod()).\n\t//\n\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t// fields describe a function whose first argument is the receiver,\n\t// and only exported methods are accessible.\n\t//\n\t// For an interface type, the returned Method's Type field gives the\n\t// method signature, without a receiver, and the Func field is nil.\n\t//\n\t// Methods are sorted in lexicographic order.\n\tMethod(int) Method\n\n\t// MethodByName returns the method with that name in the type's\n\t// method set and a boolean indicating if the method was found.\n\t//\n\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t// fields describe a function whose first argument is the receiver.\n\t//\n\t// For an interface type, the returned Method's Type field gives the\n\t// method signature, without a receiver, and the Func field is nil.\n\tMethodByName(string) (Method, bool)\n\n\t// NumMethod returns the number of methods accessible using Method.\n\t//\n\t// Note that NumMethod counts unexported methods only for interface types.\n\tNumMethod() int\n\n\t// Name returns the type's name within its package for a defined type.\n\t// For other (non-defined) types it returns the empty string.\n\tName() string\n\n\t// PkgPath returns a defined type's package path, that is, the import path\n\t// that uniquely identifies the package, such as \"encoding/base64\".\n\t// If the type was predeclared (string, error) or not defined (*T, struct{},\n\t// []int, or A where A is an alias for a non-defined type), the package path\n\t// will be the empty string.\n\tPkgPath() string\n\n\t// Size returns the number of bytes needed to store\n\t// a value of the given type; it is analogous to unsafe.Sizeof.\n\tSize() uintptr\n\n\t// String returns a string representation of the type.\n\t// The string representation may use shortened package names\n\t// (e.g., base64 instead of \"encoding/base64\") and is not\n\t// guaranteed to be unique among types. To test for type identity,\n\t// compare the Types directly.\n\tString() string\n\n\t// Kind returns the specific kind of this type.\n\tKind() Kind\n\n\t// Implements reports whether the type implements the interface type u.\n\tImplements(u Type) bool\n\n\t// AssignableTo reports whether a value of the type is assignable to type u.\n\tAssignableTo(u Type) bool\n\n\t// ConvertibleTo reports whether a value of the type is convertible to type u.\n\t// Even if ConvertibleTo returns true, the conversion may still panic.\n\t// For example, a slice of type []T is convertible to *[N]T,\n\t// but the conversion will panic if its length is less than N.\n\tConvertibleTo(u Type) bool\n\n\t// Comparable reports whether values of this type are comparable.\n\t// Even if Comparable returns true, the comparison may still panic.\n\t// For example, values of interface type are comparable,\n\t// but the comparison will panic if their dynamic type is not comparable.\n\tComparable() bool\n\n\t// Bits returns the size of the type in bits.\n\t// It panics if the type's Kind is not one of the\n\t// sized or unsized Int, Uint, Float, or Complex kinds.\n\tBits() int\n\n\t// ChanDir returns a channel type's direction.\n\t// It panics if the type's Kind is not Chan.\n\tChanDir() ChanDir\n\n\t// IsVariadic reports whether a function type's final input parameter\n\t// is a \"...\" parameter. If so, t.In(t.NumIn() - 1) returns the parameter's\n\t// implicit actual type []T.\n\t//\n\t// For concreteness, if t represents func(x int, y ... float64), then\n\t//\n\t//\tt.NumIn() == 2\n\t//\tt.In(0) is the reflect.Type for \"int\"\n\t//\tt.In(1) is the reflect.Type for \"[]float64\"\n\t//\tt.IsVariadic() == true\n\t//\n\t// IsVariadic panics if the type's Kind is not Func.\n\tIsVariadic() bool\n\n\t// Elem returns a type's element type.\n\t// It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.\n\tElem() Type\n\n\t// Field returns a struct type's i'th field.\n\t// It panics if the type's Kind is not Struct.\n\t// It panics if i is not in the range [0, NumField()).\n\tField(i int) StructField\n\n\t// FieldByIndex returns the nested field corresponding\n\t// to the index sequence. It is equivalent to calling Field\n\t// successively for each index i.\n\t// It panics if the type's Kind is not Struct.\n\tFieldByIndex(index []int) StructField\n\n\t// FieldByName returns the struct field with the given name\n\t// and a boolean indicating if the field was found.\n\tFieldByName(name string) (StructField, bool)\n\n\t// FieldByNameFunc returns the struct field with a name\n\t// that satisfies the match function and a boolean indicating if\n\t// the field was found.\n\t//\n\t// FieldByNameFunc considers the fields in the struct itself\n\t// and then the fields in any embedded structs, in breadth first order,\n\t// stopping at the shallowest nesting depth containing one or more\n\t// fields satisfying the match function. If multiple fields at that depth\n\t// satisfy the match function, they cancel each other\n\t// and FieldByNameFunc returns no match.\n\t// This behavior mirrors Go's handling of name lookup in\n\t// structs containing embedded fields.\n\tFieldByNameFunc(match func(string) bool) (StructField, bool)\n\n\t// In returns the type of a function type's i'th input parameter.\n\t// It panics if the type's Kind is not Func.\n\t// It panics if i is not in the range [0, NumIn()).\n\tIn(i int) Type\n\n\t// Key returns a map type's key type.\n\t// It panics if the type's Kind is not Map.\n\tKey() Type\n\n\t// Len returns an array type's length.\n\t// It panics if the type's Kind is not Array.\n\tLen() int\n\n\t// NumField returns a struct type's field count.\n\t// It panics if the type's Kind is not Struct.\n\tNumField() int\n\n\t// NumIn returns a function type's input parameter count.\n\t// It panics if the type's Kind is not Func.\n\tNumIn() int\n\n\t// NumOut returns a function type's output parameter count.\n\t// It panics if the type's Kind is not Func.\n\tNumOut() int\n\n\t// Out returns the type of a function type's i'th output parameter.\n\t// It panics if the type's Kind is not Func.\n\t// It panics if i is not in the range [0, NumOut()).\n\tOut(i int) Type\n\n\tcommon() *rtype\n\tuncommon() *uncommonType\n}\n```\n\nType is the representation of a Go type. \n\nNot all methods apply to all kinds of types. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of type before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run-time panic. \n\nType values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#TypeOf",
                    "documentation": {
                      "identifier": "TypeOf",
                      "newPage": false,
                      "searchKey": "reflect.TypeOf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func TypeOf(i interface{}) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc TypeOf(i interface{}) Type\n```\n\nTypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#PtrTo",
                    "documentation": {
                      "identifier": "PtrTo",
                      "newPage": false,
                      "searchKey": "reflect.PtrTo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func PtrTo(t Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc PtrTo(t Type) Type\n```\n\nPtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#ChanOf",
                    "documentation": {
                      "identifier": "ChanOf",
                      "newPage": false,
                      "searchKey": "reflect.ChanOf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ChanOf(dir ChanDir, t Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ChanOf(dir ChanDir, t Type) Type\n```\n\nChanOf returns the channel type with the given direction and element type. For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int. \n\nThe gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#MapOf",
                    "documentation": {
                      "identifier": "MapOf",
                      "newPage": false,
                      "searchKey": "reflect.MapOf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MapOf(key, elem Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MapOf(key, elem Type) Type\n```\n\nMapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string. \n\nIf the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#FuncOf",
                    "documentation": {
                      "identifier": "FuncOf",
                      "newPage": false,
                      "searchKey": "reflect.FuncOf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FuncOf(in, out []Type, variadic bool) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FuncOf(in, out []Type, variadic bool) Type\n```\n\nFuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string. \n\nThe variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#SliceOf",
                    "documentation": {
                      "identifier": "SliceOf",
                      "newPage": false,
                      "searchKey": "reflect.SliceOf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func SliceOf(t Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc SliceOf(t Type) Type\n```\n\nSliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#StructOf",
                    "documentation": {
                      "identifier": "StructOf",
                      "newPage": false,
                      "searchKey": "reflect.StructOf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func StructOf(fields []StructField) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc StructOf(fields []StructField) Type\n```\n\nStructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler. \n\nStructOf currently does not generate wrapper methods for embedded fields and panics if passed unexported StructFields. These limitations may be lifted in a future version. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#ArrayOf",
                    "documentation": {
                      "identifier": "ArrayOf",
                      "newPage": false,
                      "searchKey": "reflect.ArrayOf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ArrayOf(length int, elem Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ArrayOf(length int, elem Type) Type\n```\n\nArrayOf returns the array type with the given length and element type. For example, if t represents int, ArrayOf(5, t) represents [5]int. \n\nIf the resulting type would be larger than the available address space, ArrayOf panics. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#toType",
                    "documentation": {
                      "identifier": "toType",
                      "newPage": false,
                      "searchKey": "reflect.toType",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func toType(t *rtype) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc toType(t *rtype) Type\n```\n\ntoType converts from a *rtype to a Type that can be returned to the client of package reflect. In gc, the only concern is that a nil *rtype must be replaced by a nil Type, but in gccgo this function takes care of ensuring that multiple *rtype for the same type are coalesced into a single Type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#FuncLayout",
                    "documentation": {
                      "identifier": "FuncLayout",
                      "newPage": false,
                      "searchKey": "reflect.FuncLayout",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FuncLayout(t Type, rcvr Type) (frametype Type, argSize, retOffset uintptr, stack, gc, inReg, outReg []byte, ptrs bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FuncLayout(t Type, rcvr Type) (frametype Type, argSize, retOffset uintptr, stack, gc, inReg, outReg []byte, ptrs bool)\n```\n\nFuncLayout calls funcLayout and returns a subset of the results for testing. \n\nBitmaps like stack, gc, inReg, and outReg are expanded such that each bit takes up one byte, so that writing out test cases is a little clearer. If ptrs is false, gc will be nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#MapBucketOf",
                    "documentation": {
                      "identifier": "MapBucketOf",
                      "newPage": false,
                      "searchKey": "reflect.MapBucketOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MapBucketOf(x, y Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MapBucketOf(x, y Type) Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#CachedBucketOf",
                    "documentation": {
                      "identifier": "CachedBucketOf",
                      "newPage": false,
                      "searchKey": "reflect.CachedBucketOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func CachedBucketOf(m Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc CachedBucketOf(m Type) Type\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Kind",
              "documentation": {
                "identifier": "Kind",
                "newPage": false,
                "searchKey": "reflect.Kind",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Kind uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Kind uint\n```\n\nA Kind represents the specific kind of type that a Type represents. The zero Kind is not a valid kind. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#Kind.String",
                    "documentation": {
                      "identifier": "Kind.String",
                      "newPage": false,
                      "searchKey": "reflect.Kind.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (k Kind) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (k Kind) String() string\n```\n\nString returns the name of k. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#tflag",
              "documentation": {
                "identifier": "tflag",
                "newPage": false,
                "searchKey": "reflect.tflag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type tflag uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tflag uint8\n```\n\ntflag is used by an rtype to signal what extra type information is available in the memory directly following the rtype value. \n\ntflag values must be kept in sync with copies in: \n\n```\ncmd/compile/internal/gc/reflect.go\ncmd/link/internal/ld/decodesym.go\nruntime/type.go\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#rtype",
              "documentation": {
                "identifier": "rtype",
                "newPage": false,
                "searchKey": "reflect.rtype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type rtype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype rtype struct {\n\tsize       uintptr\n\tptrdata    uintptr // number of bytes in the type that can contain pointers\n\thash       uint32  // hash of type; avoids computation in hash tables\n\ttflag      tflag   // extra type information flags\n\talign      uint8   // alignment of variable with this type\n\tfieldAlign uint8   // alignment of struct field with this type\n\tkind       uint8   // enumeration for C\n\t// function for comparing objects of this type\n\t// (ptr to object A, ptr to object B) -> ==?\n\tequal     func(unsafe.Pointer, unsafe.Pointer) bool\n\tgcdata    *byte   // garbage collection data\n\tstr       nameOff // string form\n\tptrToThis typeOff // type for pointer to this type, may be zero\n}\n```\n\nrtype is the common implementation of most values. It is embedded in other struct types. \n\nrtype must be kept in sync with ../runtime/type.go:/^type._type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#rtypeOff",
                    "documentation": {
                      "identifier": "rtypeOff",
                      "newPage": false,
                      "searchKey": "reflect.rtypeOff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func rtypeOff(section unsafe.Pointer, off int32) *rtype"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc rtypeOff(section unsafe.Pointer, off int32) *rtype\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#bucketOf",
                    "documentation": {
                      "identifier": "bucketOf",
                      "newPage": false,
                      "searchKey": "reflect.bucketOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func bucketOf(ktyp, etyp *rtype) *rtype"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc bucketOf(ktyp, etyp *rtype) *rtype\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#funcLayout",
                    "documentation": {
                      "identifier": "funcLayout",
                      "newPage": false,
                      "searchKey": "reflect.funcLayout",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func funcLayout(t *funcType, rcvr *rtype) (frametype *rtype, framePool *sync.Pool, abi abiDesc)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc funcLayout(t *funcType, rcvr *rtype) (frametype *rtype, framePool *sync.Pool, abi abiDesc)\n```\n\nfuncLayout computes a struct type representing the layout of the stack-assigned function arguments and return values for the function type t. If rcvr != nil, rcvr specifies the type of the receiver. The returned type exists only for GC, so we only fill out GC relevant info. Currently, that's just size and the GC program. We also fill in the name for possible debugging use. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#methodReceiver",
                    "documentation": {
                      "identifier": "methodReceiver",
                      "newPage": false,
                      "searchKey": "reflect.methodReceiver",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func methodReceiver(op string, v Value, methodIndex int) (rcvrtype *rtype, t *funcType, fn unsafe.Pointer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc methodReceiver(op string, v Value, methodIndex int) (rcvrtype *rtype, t *funcType, fn unsafe.Pointer)\n```\n\nmethodReceiver returns information about the receiver described by v. The Value v may or may not have the flagMethod bit set, so the kind cached in v.flag should not be used. The return value rcvrtype gives the method's actual receiver type. The return value t gives the method type signature (without the receiver). The return value fn is a pointer to the method code. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.nameOff",
                    "documentation": {
                      "identifier": "rtype.nameOff",
                      "newPage": false,
                      "searchKey": "reflect.rtype.nameOff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) nameOff(off nameOff) name"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) nameOff(off nameOff) name\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.typeOff",
                    "documentation": {
                      "identifier": "rtype.typeOff",
                      "newPage": false,
                      "searchKey": "reflect.rtype.typeOff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) typeOff(off typeOff) *rtype"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) typeOff(off typeOff) *rtype\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.textOff",
                    "documentation": {
                      "identifier": "rtype.textOff",
                      "newPage": false,
                      "searchKey": "reflect.rtype.textOff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) textOff(off textOff) unsafe.Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) textOff(off textOff) unsafe.Pointer\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.uncommon",
                    "documentation": {
                      "identifier": "rtype.uncommon",
                      "newPage": false,
                      "searchKey": "reflect.rtype.uncommon",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) uncommon() *uncommonType"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) uncommon() *uncommonType\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.String",
                    "documentation": {
                      "identifier": "rtype.String",
                      "newPage": false,
                      "searchKey": "reflect.rtype.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Size",
                    "documentation": {
                      "identifier": "rtype.Size",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Size",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Size() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Size() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Bits",
                    "documentation": {
                      "identifier": "rtype.Bits",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Bits",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Bits() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Bits() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Align",
                    "documentation": {
                      "identifier": "rtype.Align",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Align",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Align() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Align() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.FieldAlign",
                    "documentation": {
                      "identifier": "rtype.FieldAlign",
                      "newPage": false,
                      "searchKey": "reflect.rtype.FieldAlign",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) FieldAlign() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) FieldAlign() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Kind",
                    "documentation": {
                      "identifier": "rtype.Kind",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Kind",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Kind() Kind"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Kind() Kind\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.pointers",
                    "documentation": {
                      "identifier": "rtype.pointers",
                      "newPage": false,
                      "searchKey": "reflect.rtype.pointers",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) pointers() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) pointers() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.common",
                    "documentation": {
                      "identifier": "rtype.common",
                      "newPage": false,
                      "searchKey": "reflect.rtype.common",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) common() *rtype"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) common() *rtype\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.exportedMethods",
                    "documentation": {
                      "identifier": "rtype.exportedMethods",
                      "newPage": false,
                      "searchKey": "reflect.rtype.exportedMethods",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) exportedMethods() []method"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) exportedMethods() []method\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.NumMethod",
                    "documentation": {
                      "identifier": "rtype.NumMethod",
                      "newPage": false,
                      "searchKey": "reflect.rtype.NumMethod",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) NumMethod() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) NumMethod() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Method",
                    "documentation": {
                      "identifier": "rtype.Method",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Method",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Method(i int) (m Method)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Method(i int) (m Method)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.MethodByName",
                    "documentation": {
                      "identifier": "rtype.MethodByName",
                      "newPage": false,
                      "searchKey": "reflect.rtype.MethodByName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) MethodByName(name string) (m Method, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) MethodByName(name string) (m Method, ok bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.PkgPath",
                    "documentation": {
                      "identifier": "rtype.PkgPath",
                      "newPage": false,
                      "searchKey": "reflect.rtype.PkgPath",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) PkgPath() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) PkgPath() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.hasName",
                    "documentation": {
                      "identifier": "rtype.hasName",
                      "newPage": false,
                      "searchKey": "reflect.rtype.hasName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) hasName() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) hasName() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Name",
                    "documentation": {
                      "identifier": "rtype.Name",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.ChanDir",
                    "documentation": {
                      "identifier": "rtype.ChanDir",
                      "newPage": false,
                      "searchKey": "reflect.rtype.ChanDir",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) ChanDir() ChanDir"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) ChanDir() ChanDir\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.IsVariadic",
                    "documentation": {
                      "identifier": "rtype.IsVariadic",
                      "newPage": false,
                      "searchKey": "reflect.rtype.IsVariadic",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) IsVariadic() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) IsVariadic() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Elem",
                    "documentation": {
                      "identifier": "rtype.Elem",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Elem",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Elem() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Elem() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Field",
                    "documentation": {
                      "identifier": "rtype.Field",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Field",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Field(i int) StructField"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Field(i int) StructField\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.FieldByIndex",
                    "documentation": {
                      "identifier": "rtype.FieldByIndex",
                      "newPage": false,
                      "searchKey": "reflect.rtype.FieldByIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) FieldByIndex(index []int) StructField"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) FieldByIndex(index []int) StructField\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.FieldByName",
                    "documentation": {
                      "identifier": "rtype.FieldByName",
                      "newPage": false,
                      "searchKey": "reflect.rtype.FieldByName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) FieldByName(name string) (StructField, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) FieldByName(name string) (StructField, bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.FieldByNameFunc",
                    "documentation": {
                      "identifier": "rtype.FieldByNameFunc",
                      "newPage": false,
                      "searchKey": "reflect.rtype.FieldByNameFunc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) FieldByNameFunc(match func(string) bool) (StructField, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) FieldByNameFunc(match func(string) bool) (StructField, bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.In",
                    "documentation": {
                      "identifier": "rtype.In",
                      "newPage": false,
                      "searchKey": "reflect.rtype.In",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) In(i int) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) In(i int) Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Key",
                    "documentation": {
                      "identifier": "rtype.Key",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Key",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Key() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Key() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Len",
                    "documentation": {
                      "identifier": "rtype.Len",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.NumField",
                    "documentation": {
                      "identifier": "rtype.NumField",
                      "newPage": false,
                      "searchKey": "reflect.rtype.NumField",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) NumField() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) NumField() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.NumIn",
                    "documentation": {
                      "identifier": "rtype.NumIn",
                      "newPage": false,
                      "searchKey": "reflect.rtype.NumIn",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) NumIn() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) NumIn() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.NumOut",
                    "documentation": {
                      "identifier": "rtype.NumOut",
                      "newPage": false,
                      "searchKey": "reflect.rtype.NumOut",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) NumOut() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) NumOut() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Out",
                    "documentation": {
                      "identifier": "rtype.Out",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Out",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Out(i int) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Out(i int) Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.ptrTo",
                    "documentation": {
                      "identifier": "rtype.ptrTo",
                      "newPage": false,
                      "searchKey": "reflect.rtype.ptrTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) ptrTo() *rtype"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) ptrTo() *rtype\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Implements",
                    "documentation": {
                      "identifier": "rtype.Implements",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Implements",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Implements(u Type) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Implements(u Type) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.AssignableTo",
                    "documentation": {
                      "identifier": "rtype.AssignableTo",
                      "newPage": false,
                      "searchKey": "reflect.rtype.AssignableTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) AssignableTo(u Type) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) AssignableTo(u Type) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.ConvertibleTo",
                    "documentation": {
                      "identifier": "rtype.ConvertibleTo",
                      "newPage": false,
                      "searchKey": "reflect.rtype.ConvertibleTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) ConvertibleTo(u Type) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) ConvertibleTo(u Type) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.Comparable",
                    "documentation": {
                      "identifier": "rtype.Comparable",
                      "newPage": false,
                      "searchKey": "reflect.rtype.Comparable",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) Comparable() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) Comparable() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#rtype.gcSlice",
                    "documentation": {
                      "identifier": "rtype.gcSlice",
                      "newPage": false,
                      "searchKey": "reflect.rtype.gcSlice",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *rtype) gcSlice(begin, end uintptr) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *rtype) gcSlice(begin, end uintptr) []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#method",
              "documentation": {
                "identifier": "method",
                "newPage": false,
                "searchKey": "reflect.method",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type method struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype method struct {\n\tname nameOff // name of method\n\tmtyp typeOff // method type (without receiver)\n\tifn  textOff // fn used in interface call (one-word receiver)\n\ttfn  textOff // fn used for normal method call\n}\n```\n\nMethod on non-interface type \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#uncommonType",
              "documentation": {
                "identifier": "uncommonType",
                "newPage": false,
                "searchKey": "reflect.uncommonType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uncommonType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uncommonType struct {\n\tpkgPath nameOff // import path; empty for built-in types like int, string\n\tmcount  uint16  // number of methods\n\txcount  uint16  // number of exported methods\n\tmoff    uint32  // offset from this uncommontype to [mcount]method\n\t_       uint32  // unused\n}\n```\n\nuncommonType is present only for defined types or types with methods (if T is a defined type, the uncommonTypes for T and *T have methods). Using a pointer to this struct reduces the overall size required to describe a non-defined type with no methods. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#uncommonType.methods",
                    "documentation": {
                      "identifier": "uncommonType.methods",
                      "newPage": false,
                      "searchKey": "reflect.uncommonType.methods",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *uncommonType) methods() []method"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *uncommonType) methods() []method\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#uncommonType.exportedMethods",
                    "documentation": {
                      "identifier": "uncommonType.exportedMethods",
                      "newPage": false,
                      "searchKey": "reflect.uncommonType.exportedMethods",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *uncommonType) exportedMethods() []method"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *uncommonType) exportedMethods() []method\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#ChanDir",
              "documentation": {
                "identifier": "ChanDir",
                "newPage": false,
                "searchKey": "reflect.ChanDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ChanDir int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ChanDir int\n```\n\nChanDir represents a channel type's direction. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#ChanDir.String",
                    "documentation": {
                      "identifier": "ChanDir.String",
                      "newPage": false,
                      "searchKey": "reflect.ChanDir.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d ChanDir) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d ChanDir) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#arrayType",
              "documentation": {
                "identifier": "arrayType",
                "newPage": false,
                "searchKey": "reflect.arrayType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type arrayType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype arrayType struct {\n\trtype\n\telem  *rtype // array element type\n\tslice *rtype // slice type\n\tlen   uintptr\n}\n```\n\narrayType represents a fixed array type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#chanType",
              "documentation": {
                "identifier": "chanType",
                "newPage": false,
                "searchKey": "reflect.chanType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type chanType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype chanType struct {\n\trtype\n\telem *rtype  // channel element type\n\tdir  uintptr // channel direction (ChanDir)\n}\n```\n\nchanType represents a channel type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcType",
              "documentation": {
                "identifier": "funcType",
                "newPage": false,
                "searchKey": "reflect.funcType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcType struct {\n\trtype\n\tinCount  uint16\n\toutCount uint16 // top bit is set if last input parameter is ...\n}\n```\n\nfuncType represents a function type. \n\nA *rtype for each in and out parameter is stored in an array that directly follows the funcType (and possibly its uncommonType). So a function type with one method, one input, and one output is: \n\n```\nstruct {\n\tfuncType\n\tuncommonType\n\t[2]*rtype    // [0] is in, [1] is out\n}\n\n```\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#methodReceiver",
                    "documentation": {
                      "identifier": "methodReceiver",
                      "newPage": false,
                      "searchKey": "reflect.methodReceiver",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func methodReceiver(op string, v Value, methodIndex int) (rcvrtype *rtype, t *funcType, fn unsafe.Pointer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc methodReceiver(op string, v Value, methodIndex int) (rcvrtype *rtype, t *funcType, fn unsafe.Pointer)\n```\n\nmethodReceiver returns information about the receiver described by v. The Value v may or may not have the flagMethod bit set, so the kind cached in v.flag should not be used. The return value rcvrtype gives the method's actual receiver type. The return value t gives the method type signature (without the receiver). The return value fn is a pointer to the method code. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#funcType.in",
                    "documentation": {
                      "identifier": "funcType.in",
                      "newPage": false,
                      "searchKey": "reflect.funcType.in",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *funcType) in() []*rtype"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *funcType) in() []*rtype\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#funcType.out",
                    "documentation": {
                      "identifier": "funcType.out",
                      "newPage": false,
                      "searchKey": "reflect.funcType.out",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *funcType) out() []*rtype"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *funcType) out() []*rtype\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#imethod",
              "documentation": {
                "identifier": "imethod",
                "newPage": false,
                "searchKey": "reflect.imethod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type imethod struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype imethod struct {\n\tname nameOff // name of method\n\ttyp  typeOff // .(*FuncType) underneath\n}\n```\n\nimethod represents a method on an interface type \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#interfaceType",
              "documentation": {
                "identifier": "interfaceType",
                "newPage": false,
                "searchKey": "reflect.interfaceType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type interfaceType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype interfaceType struct {\n\trtype\n\tpkgPath name      // import path\n\tmethods []imethod // sorted by hash\n}\n```\n\ninterfaceType represents an interface type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#interfaceType.Method",
                    "documentation": {
                      "identifier": "interfaceType.Method",
                      "newPage": false,
                      "searchKey": "reflect.interfaceType.Method",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *interfaceType) Method(i int) (m Method)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *interfaceType) Method(i int) (m Method)\n```\n\nMethod returns the i'th method in the type's method set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#interfaceType.NumMethod",
                    "documentation": {
                      "identifier": "interfaceType.NumMethod",
                      "newPage": false,
                      "searchKey": "reflect.interfaceType.NumMethod",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *interfaceType) NumMethod() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *interfaceType) NumMethod() int\n```\n\nNumMethod returns the number of interface methods in the type's method set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#interfaceType.MethodByName",
                    "documentation": {
                      "identifier": "interfaceType.MethodByName",
                      "newPage": false,
                      "searchKey": "reflect.interfaceType.MethodByName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *interfaceType) MethodByName(name string) (m Method, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *interfaceType) MethodByName(name string) (m Method, ok bool)\n```\n\nMethodByName method with the given name in the type's method set. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#mapType",
              "documentation": {
                "identifier": "mapType",
                "newPage": false,
                "searchKey": "reflect.mapType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mapType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mapType struct {\n\trtype\n\tkey    *rtype // map key type\n\telem   *rtype // map element (value) type\n\tbucket *rtype // internal bucket structure\n\t// function for hashing keys (ptr to key, seed) -> hash\n\thasher     func(unsafe.Pointer, uintptr) uintptr\n\tkeysize    uint8  // size of key slot\n\tvaluesize  uint8  // size of value slot\n\tbucketsize uint16 // size of bucket\n\tflags      uint32\n}\n```\n\nmapType represents a map type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#ptrType",
              "documentation": {
                "identifier": "ptrType",
                "newPage": false,
                "searchKey": "reflect.ptrType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ptrType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ptrType struct {\n\trtype\n\telem *rtype // pointer element (pointed at) type\n}\n```\n\nptrType represents a pointer type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#sliceType",
              "documentation": {
                "identifier": "sliceType",
                "newPage": false,
                "searchKey": "reflect.sliceType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sliceType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sliceType struct {\n\trtype\n\telem *rtype // slice element type\n}\n```\n\nsliceType represents a slice type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#structField",
              "documentation": {
                "identifier": "structField",
                "newPage": false,
                "searchKey": "reflect.structField",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type structField struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype structField struct {\n\tname        name    // name is always non-empty\n\ttyp         *rtype  // type of field\n\toffsetEmbed uintptr // byte offset of field<<1 | isEmbedded\n}\n```\n\nStruct field \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#runtimeStructField",
                    "documentation": {
                      "identifier": "runtimeStructField",
                      "newPage": false,
                      "searchKey": "reflect.runtimeStructField",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func runtimeStructField(field StructField) (structField, string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc runtimeStructField(field StructField) (structField, string)\n```\n\nruntimeStructField takes a StructField value passed to StructOf and returns both the corresponding internal representation, of type structField, and the pkgpath value to use for this field. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#structField.offset",
                    "documentation": {
                      "identifier": "structField.offset",
                      "newPage": false,
                      "searchKey": "reflect.structField.offset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *structField) offset() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *structField) offset() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#structField.embedded",
                    "documentation": {
                      "identifier": "structField.embedded",
                      "newPage": false,
                      "searchKey": "reflect.structField.embedded",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *structField) embedded() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *structField) embedded() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#structType",
              "documentation": {
                "identifier": "structType",
                "newPage": false,
                "searchKey": "reflect.structType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type structType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype structType struct {\n\trtype\n\tpkgPath name\n\tfields  []structField // sorted by offset\n}\n```\n\nstructType represents a struct type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#structType.Field",
                    "documentation": {
                      "identifier": "structType.Field",
                      "newPage": false,
                      "searchKey": "reflect.structType.Field",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *structType) Field(i int) (f StructField)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *structType) Field(i int) (f StructField)\n```\n\nField returns the i'th struct field. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#structType.FieldByIndex",
                    "documentation": {
                      "identifier": "structType.FieldByIndex",
                      "newPage": false,
                      "searchKey": "reflect.structType.FieldByIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *structType) FieldByIndex(index []int) (f StructField)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *structType) FieldByIndex(index []int) (f StructField)\n```\n\nFieldByIndex returns the nested field corresponding to index. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#structType.FieldByNameFunc",
                    "documentation": {
                      "identifier": "structType.FieldByNameFunc",
                      "newPage": false,
                      "searchKey": "reflect.structType.FieldByNameFunc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *structType) FieldByNameFunc(match func(string) bool) (result StructField, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *structType) FieldByNameFunc(match func(string) bool) (result StructField, ok bool)\n```\n\nFieldByNameFunc returns the struct field with a name that satisfies the match function and a boolean to indicate if the field was found. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#structType.FieldByName",
                    "documentation": {
                      "identifier": "structType.FieldByName",
                      "newPage": false,
                      "searchKey": "reflect.structType.FieldByName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *structType) FieldByName(name string) (f StructField, present bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *structType) FieldByName(name string) (f StructField, present bool)\n```\n\nFieldByName returns the struct field with the given name and a boolean to indicate if the field was found. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#name",
              "documentation": {
                "identifier": "name",
                "newPage": false,
                "searchKey": "reflect.name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type name struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype name struct {\n\tbytes *byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#newName",
                    "documentation": {
                      "identifier": "newName",
                      "newPage": false,
                      "searchKey": "reflect.newName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newName(n, tag string, exported bool) name"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newName(n, tag string, exported bool) name\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#name.data",
                    "documentation": {
                      "identifier": "name.data",
                      "newPage": false,
                      "searchKey": "reflect.name.data",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) data(off int, whySafe string) *byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) data(off int, whySafe string) *byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#name.isExported",
                    "documentation": {
                      "identifier": "name.isExported",
                      "newPage": false,
                      "searchKey": "reflect.name.isExported",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) isExported() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) isExported() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#name.hasTag",
                    "documentation": {
                      "identifier": "name.hasTag",
                      "newPage": false,
                      "searchKey": "reflect.name.hasTag",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) hasTag() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) hasTag() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#name.readVarint",
                    "documentation": {
                      "identifier": "name.readVarint",
                      "newPage": false,
                      "searchKey": "reflect.name.readVarint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) readVarint(off int) (int, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) readVarint(off int) (int, int)\n```\n\nreadVarint parses a varint as encoded by encoding/binary. It returns the number of encoded bytes and the encoded value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#name.name",
                    "documentation": {
                      "identifier": "name.name",
                      "newPage": false,
                      "searchKey": "reflect.name.name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) name() (s string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) name() (s string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#name.tag",
                    "documentation": {
                      "identifier": "name.tag",
                      "newPage": false,
                      "searchKey": "reflect.name.tag",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) tag() (s string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) tag() (s string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#name.pkgPath",
                    "documentation": {
                      "identifier": "name.pkgPath",
                      "newPage": false,
                      "searchKey": "reflect.name.pkgPath",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) pkgPath() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) pkgPath() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Method",
              "documentation": {
                "identifier": "Method",
                "newPage": false,
                "searchKey": "reflect.Method",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Method struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Method struct {\n\t// Name is the method name.\n\tName string\n\n\t// PkgPath is the package path that qualifies a lower case (unexported)\n\t// method name. It is empty for upper case (exported) method names.\n\t// The combination of PkgPath and Name uniquely identifies a method\n\t// in a method set.\n\t// See https://golang.org/ref/spec#Uniqueness_of_identifiers\n\tPkgPath string\n\n\tType  Type  // method type\n\tFunc  Value // func with receiver as first argument\n\tIndex int   // index for Type.Method\n}\n```\n\nMethod represents a single method. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#Method.IsExported",
                    "documentation": {
                      "identifier": "Method.IsExported",
                      "newPage": false,
                      "searchKey": "reflect.Method.IsExported",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m Method) IsExported() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m Method) IsExported() bool\n```\n\nIsExported reports whether the method is exported. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#nameOff",
              "documentation": {
                "identifier": "nameOff",
                "newPage": false,
                "searchKey": "reflect.nameOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nameOff int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nameOff int32 // offset to a name\n\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#resolveReflectName",
                    "documentation": {
                      "identifier": "resolveReflectName",
                      "newPage": false,
                      "searchKey": "reflect.resolveReflectName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func resolveReflectName(n name) nameOff"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc resolveReflectName(n name) nameOff\n```\n\nresolveReflectName adds a name to the reflection lookup map in the runtime. It returns a new nameOff that can be used to refer to the pointer. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typeOff",
              "documentation": {
                "identifier": "typeOff",
                "newPage": false,
                "searchKey": "reflect.typeOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type typeOff int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype typeOff int32 // offset to an *rtype\n\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#resolveReflectType",
                    "documentation": {
                      "identifier": "resolveReflectType",
                      "newPage": false,
                      "searchKey": "reflect.resolveReflectType",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func resolveReflectType(t *rtype) typeOff"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc resolveReflectType(t *rtype) typeOff\n```\n\nresolveReflectType adds a *rtype to the reflection lookup map in the runtime. It returns a new typeOff that can be used to refer to the pointer. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#textOff",
              "documentation": {
                "identifier": "textOff",
                "newPage": false,
                "searchKey": "reflect.textOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type textOff int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype textOff int32 // offset from top of text section\n\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#resolveReflectText",
                    "documentation": {
                      "identifier": "resolveReflectText",
                      "newPage": false,
                      "searchKey": "reflect.resolveReflectText",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func resolveReflectText(ptr unsafe.Pointer) textOff"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc resolveReflectText(ptr unsafe.Pointer) textOff\n```\n\nresolveReflectText adds a function pointer to the reflection lookup map in the runtime. It returns a new textOff that can be used to refer to the pointer. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#StructField",
              "documentation": {
                "identifier": "StructField",
                "newPage": false,
                "searchKey": "reflect.StructField",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type StructField struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype StructField struct {\n\t// Name is the field name.\n\tName string\n\n\t// PkgPath is the package path that qualifies a lower case (unexported)\n\t// field name. It is empty for upper case (exported) field names.\n\t// See https://golang.org/ref/spec#Uniqueness_of_identifiers\n\tPkgPath string\n\n\tType      Type      // field type\n\tTag       StructTag // field tag string\n\tOffset    uintptr   // offset within struct, in bytes\n\tIndex     []int     // index sequence for Type.FieldByIndex\n\tAnonymous bool      // is an embedded field\n}\n```\n\nA StructField describes a single field in a struct. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#StructField.IsExported",
                    "documentation": {
                      "identifier": "StructField.IsExported",
                      "newPage": false,
                      "searchKey": "reflect.StructField.IsExported",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f StructField) IsExported() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f StructField) IsExported() bool\n```\n\nIsExported reports whether the field is exported. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#StructTag",
              "documentation": {
                "identifier": "StructTag",
                "newPage": false,
                "searchKey": "reflect.StructTag",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type StructTag string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype StructTag string\n```\n\nA StructTag is the tag string in a struct field. \n\nBy convention, tag strings are a concatenation of optionally space-separated key:\"value\" pairs. Each key is a non-empty string consisting of non-control characters other than space (U+0020 ' '), quote (U+0022 '\"'), and colon (U+003A ':').  Each value is quoted using U+0022 '\"' characters and Go string literal syntax. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#StructTag.Get",
                    "documentation": {
                      "identifier": "StructTag.Get",
                      "newPage": false,
                      "searchKey": "reflect.StructTag.Get",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tag StructTag) Get(key string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tag StructTag) Get(key string) string\n```\n\nGet returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use Lookup. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#StructTag.Lookup",
                    "documentation": {
                      "identifier": "StructTag.Lookup",
                      "newPage": false,
                      "searchKey": "reflect.StructTag.Lookup",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tag StructTag) Lookup(key string) (value string, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tag StructTag) Lookup(key string) (value string, ok bool)\n```\n\nLookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#fieldScan",
              "documentation": {
                "identifier": "fieldScan",
                "newPage": false,
                "searchKey": "reflect.fieldScan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type fieldScan struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fieldScan struct {\n\ttyp   *structType\n\tindex []int\n}\n```\n\nA fieldScan represents an item on the fieldByNameFunc scan work list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#cacheKey",
              "documentation": {
                "identifier": "cacheKey",
                "newPage": false,
                "searchKey": "reflect.cacheKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cacheKey struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cacheKey struct {\n\tkind  Kind\n\tt1    *rtype\n\tt2    *rtype\n\textra uintptr\n}\n```\n\nA cacheKey is the key for use in the lookupCache. Four values describe any of the types we are looking for: type kind, one or two subtypes, and an extra integer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcTypeFixed4",
              "documentation": {
                "identifier": "funcTypeFixed4",
                "newPage": false,
                "searchKey": "reflect.funcTypeFixed4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcTypeFixed4 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcTypeFixed4 struct {\n\tfuncType\n\targs [4]*rtype\n}\n```\n\nTODO(crawshaw): as these funcTypeFixedN structs have no methods, they could be defined at runtime using the StructOf function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcTypeFixed8",
              "documentation": {
                "identifier": "funcTypeFixed8",
                "newPage": false,
                "searchKey": "reflect.funcTypeFixed8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcTypeFixed8 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcTypeFixed8 struct {\n\tfuncType\n\targs [8]*rtype\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcTypeFixed16",
              "documentation": {
                "identifier": "funcTypeFixed16",
                "newPage": false,
                "searchKey": "reflect.funcTypeFixed16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcTypeFixed16 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcTypeFixed16 struct {\n\tfuncType\n\targs [16]*rtype\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcTypeFixed32",
              "documentation": {
                "identifier": "funcTypeFixed32",
                "newPage": false,
                "searchKey": "reflect.funcTypeFixed32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcTypeFixed32 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcTypeFixed32 struct {\n\tfuncType\n\targs [32]*rtype\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcTypeFixed64",
              "documentation": {
                "identifier": "funcTypeFixed64",
                "newPage": false,
                "searchKey": "reflect.funcTypeFixed64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcTypeFixed64 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcTypeFixed64 struct {\n\tfuncType\n\targs [64]*rtype\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcTypeFixed128",
              "documentation": {
                "identifier": "funcTypeFixed128",
                "newPage": false,
                "searchKey": "reflect.funcTypeFixed128",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcTypeFixed128 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcTypeFixed128 struct {\n\tfuncType\n\targs [128]*rtype\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#structTypeUncommon",
              "documentation": {
                "identifier": "structTypeUncommon",
                "newPage": false,
                "searchKey": "reflect.structTypeUncommon",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type structTypeUncommon struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype structTypeUncommon struct {\n\tstructType\n\tu uncommonType\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#layoutKey",
              "documentation": {
                "identifier": "layoutKey",
                "newPage": false,
                "searchKey": "reflect.layoutKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type layoutKey struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype layoutKey struct {\n\tftyp *funcType // function signature\n\trcvr *rtype    // receiver type, or nil if none\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#layoutType",
              "documentation": {
                "identifier": "layoutType",
                "newPage": false,
                "searchKey": "reflect.layoutType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type layoutType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype layoutType struct {\n\tt         *rtype\n\tframePool *sync.Pool\n\tabi       abiDesc\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#bitVector",
              "documentation": {
                "identifier": "bitVector",
                "newPage": false,
                "searchKey": "reflect.bitVector",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type bitVector struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bitVector struct {\n\tn    uint32 // number of bits\n\tdata []byte\n}\n```\n\nNote: this type must agree with runtime.bitvector. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#bitVector.append",
                    "documentation": {
                      "identifier": "bitVector.append",
                      "newPage": false,
                      "searchKey": "reflect.bitVector.append",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (bv *bitVector) append(bit uint8)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (bv *bitVector) append(bit uint8)\n```\n\nappend a bit to the bitmap. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Value",
              "documentation": {
                "identifier": "Value",
                "newPage": false,
                "searchKey": "reflect.Value",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Value struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Value struct {\n\t// typ holds the type of the value represented by a Value.\n\ttyp *rtype\n\n\t// Pointer-valued data or, if flagIndir is set, pointer to data.\n\t// Valid when either flagIndir is set or typ.pointers() is true.\n\tptr unsafe.Pointer\n\n\t// flag holds metadata about the value.\n\t// The lowest bits are flag bits:\n\t//\t- flagStickyRO: obtained via unexported not embedded field, so read-only\n\t//\t- flagEmbedRO: obtained via unexported embedded field, so read-only\n\t//\t- flagIndir: val holds a pointer to the data\n\t//\t- flagAddr: v.CanAddr is true (implies flagIndir)\n\t//\t- flagMethod: v is a method value.\n\t// The next five bits give the Kind of the value.\n\t// This repeats typ.Kind() except for method values.\n\t// The remaining 23+ bits give a method number for method values.\n\t// If flag.kind() != Func, code can assume that flagMethod is unset.\n\t// If ifaceIndir(typ), code can assume that flagIndir is set.\n\tflag\n}\n```\n\nValue is the reflection interface to a Go value. \n\nNot all methods apply to all kinds of values. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of value before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic. \n\nThe zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns \"<invalid Value>\", and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly. \n\nA Value can be used concurrently by multiple goroutines provided that the underlying Go value can be used concurrently for the equivalent direct operations. \n\nTo compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#MakeFunc",
                    "documentation": {
                      "identifier": "MakeFunc",
                      "newPage": false,
                      "searchKey": "reflect.MakeFunc",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value\n```\n\nMakeFunc returns a new function of the given Type that wraps the function fn. When called, that new function does the following: \n\n```\n- converts its arguments to a slice of Values.\n- runs results := fn(args).\n- returns the results as a slice of Values, one per formal result.\n\n```\nThe implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ. \n\nThe Value.Call method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values. \n\nThe Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#makeMethodValue",
                    "documentation": {
                      "identifier": "makeMethodValue",
                      "newPage": false,
                      "searchKey": "reflect.makeMethodValue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeMethodValue(op string, v Value) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeMethodValue(op string, v Value) Value\n```\n\nmakeMethodValue converts v from the rcvr+method index representation of a method value to an actual method func value, which is basically the receiver value with a special bit set, into a true func value - a value holding an actual func. The output is semantically equivalent to the input as far as the user of package reflect can tell, but the true func representation can be handled by code like Convert and Interface and Assign. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#unpackEface",
                    "documentation": {
                      "identifier": "unpackEface",
                      "newPage": false,
                      "searchKey": "reflect.unpackEface",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func unpackEface(i interface{}) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc unpackEface(i interface{}) Value\n```\n\nunpackEface converts the empty interface i to a Value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#copyVal",
                    "documentation": {
                      "identifier": "copyVal",
                      "newPage": false,
                      "searchKey": "reflect.copyVal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func copyVal(typ *rtype, fl flag, ptr unsafe.Pointer) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc copyVal(typ *rtype, fl flag, ptr unsafe.Pointer) Value\n```\n\ncopyVal returns a Value containing the map key or value at ptr, allocating a new variable as needed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#grow",
                    "documentation": {
                      "identifier": "grow",
                      "newPage": false,
                      "searchKey": "reflect.grow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func grow(s Value, extra int) (Value, int, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc grow(s Value, extra int) (Value, int, int)\n```\n\ngrow grows the slice s so that it can hold extra more values, allocating more capacity if needed. It also returns the old and new slice lengths. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Append",
                    "documentation": {
                      "identifier": "Append",
                      "newPage": false,
                      "searchKey": "reflect.Append",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Append(s Value, x ...Value) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Append(s Value, x ...Value) Value\n```\n\nAppend appends the values x to a slice s and returns the resulting slice. As in Go, each x's value must be assignable to the slice's element type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#AppendSlice",
                    "documentation": {
                      "identifier": "AppendSlice",
                      "newPage": false,
                      "searchKey": "reflect.AppendSlice",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func AppendSlice(s, t Value) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc AppendSlice(s, t Value) Value\n```\n\nAppendSlice appends a slice t to a slice s and returns the resulting slice. The slices s and t must have the same element type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Select",
                    "documentation": {
                      "identifier": "Select",
                      "newPage": false,
                      "searchKey": "reflect.Select",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)\n```\n\nSelect executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed). Select supports a maximum of 65536 cases. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#MakeSlice",
                    "documentation": {
                      "identifier": "MakeSlice",
                      "newPage": false,
                      "searchKey": "reflect.MakeSlice",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MakeSlice(typ Type, len, cap int) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MakeSlice(typ Type, len, cap int) Value\n```\n\nMakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#MakeChan",
                    "documentation": {
                      "identifier": "MakeChan",
                      "newPage": false,
                      "searchKey": "reflect.MakeChan",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MakeChan(typ Type, buffer int) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MakeChan(typ Type, buffer int) Value\n```\n\nMakeChan creates a new channel with the specified type and buffer size. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#MakeMap",
                    "documentation": {
                      "identifier": "MakeMap",
                      "newPage": false,
                      "searchKey": "reflect.MakeMap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MakeMap(typ Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MakeMap(typ Type) Value\n```\n\nMakeMap creates a new map with the specified type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#MakeMapWithSize",
                    "documentation": {
                      "identifier": "MakeMapWithSize",
                      "newPage": false,
                      "searchKey": "reflect.MakeMapWithSize",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MakeMapWithSize(typ Type, n int) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MakeMapWithSize(typ Type, n int) Value\n```\n\nMakeMapWithSize creates a new map with the specified type and initial space for approximately n elements. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Indirect",
                    "documentation": {
                      "identifier": "Indirect",
                      "newPage": false,
                      "searchKey": "reflect.Indirect",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Indirect(v Value) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Indirect(v Value) Value\n```\n\nIndirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#ValueOf",
                    "documentation": {
                      "identifier": "ValueOf",
                      "newPage": false,
                      "searchKey": "reflect.ValueOf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ValueOf(i interface{}) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ValueOf(i interface{}) Value\n```\n\nValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Zero",
                    "documentation": {
                      "identifier": "Zero",
                      "newPage": false,
                      "searchKey": "reflect.Zero",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Zero(typ Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Zero(typ Type) Value\n```\n\nZero returns a Value representing the zero value for the specified type. The result is different from the zero value of the Value struct, which represents no value at all. For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0. The returned value is neither addressable nor settable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#New",
                    "documentation": {
                      "identifier": "New",
                      "newPage": false,
                      "searchKey": "reflect.New",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func New(typ Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc New(typ Type) Value\n```\n\nNew returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is PtrTo(typ). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#NewAt",
                    "documentation": {
                      "identifier": "NewAt",
                      "newPage": false,
                      "searchKey": "reflect.NewAt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewAt(typ Type, p unsafe.Pointer) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewAt(typ Type, p unsafe.Pointer) Value\n```\n\nNewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#makeInt",
                    "documentation": {
                      "identifier": "makeInt",
                      "newPage": false,
                      "searchKey": "reflect.makeInt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeInt(f flag, bits uint64, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeInt(f flag, bits uint64, t Type) Value\n```\n\nmakeInt returns a Value of type t equal to bits (possibly truncated), where t is a signed or unsigned int type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#makeFloat",
                    "documentation": {
                      "identifier": "makeFloat",
                      "newPage": false,
                      "searchKey": "reflect.makeFloat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeFloat(f flag, v float64, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeFloat(f flag, v float64, t Type) Value\n```\n\nmakeFloat returns a Value of type t equal to v (possibly truncated to float32), where t is a float32 or float64 type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#makeFloat32",
                    "documentation": {
                      "identifier": "makeFloat32",
                      "newPage": false,
                      "searchKey": "reflect.makeFloat32",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeFloat32(f flag, v float32, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeFloat32(f flag, v float32, t Type) Value\n```\n\nmakeFloat returns a Value of type t equal to v, where t is a float32 type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#makeComplex",
                    "documentation": {
                      "identifier": "makeComplex",
                      "newPage": false,
                      "searchKey": "reflect.makeComplex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeComplex(f flag, v complex128, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeComplex(f flag, v complex128, t Type) Value\n```\n\nmakeComplex returns a Value of type t equal to v (possibly truncated to complex64), where t is a complex64 or complex128 type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#makeString",
                    "documentation": {
                      "identifier": "makeString",
                      "newPage": false,
                      "searchKey": "reflect.makeString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeString(f flag, v string, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeString(f flag, v string, t Type) Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#makeBytes",
                    "documentation": {
                      "identifier": "makeBytes",
                      "newPage": false,
                      "searchKey": "reflect.makeBytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeBytes(f flag, v []byte, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeBytes(f flag, v []byte, t Type) Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#makeRunes",
                    "documentation": {
                      "identifier": "makeRunes",
                      "newPage": false,
                      "searchKey": "reflect.makeRunes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeRunes(f flag, v []rune, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeRunes(f flag, v []rune, t Type) Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtInt",
                    "documentation": {
                      "identifier": "cvtInt",
                      "newPage": false,
                      "searchKey": "reflect.cvtInt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtInt(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtInt(v Value, t Type) Value\n```\n\nconvertOp: intXX -> [u]intXX \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtUint",
                    "documentation": {
                      "identifier": "cvtUint",
                      "newPage": false,
                      "searchKey": "reflect.cvtUint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtUint(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtUint(v Value, t Type) Value\n```\n\nconvertOp: uintXX -> [u]intXX \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtFloatInt",
                    "documentation": {
                      "identifier": "cvtFloatInt",
                      "newPage": false,
                      "searchKey": "reflect.cvtFloatInt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtFloatInt(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtFloatInt(v Value, t Type) Value\n```\n\nconvertOp: floatXX -> intXX \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtFloatUint",
                    "documentation": {
                      "identifier": "cvtFloatUint",
                      "newPage": false,
                      "searchKey": "reflect.cvtFloatUint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtFloatUint(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtFloatUint(v Value, t Type) Value\n```\n\nconvertOp: floatXX -> uintXX \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtIntFloat",
                    "documentation": {
                      "identifier": "cvtIntFloat",
                      "newPage": false,
                      "searchKey": "reflect.cvtIntFloat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtIntFloat(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtIntFloat(v Value, t Type) Value\n```\n\nconvertOp: intXX -> floatXX \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtUintFloat",
                    "documentation": {
                      "identifier": "cvtUintFloat",
                      "newPage": false,
                      "searchKey": "reflect.cvtUintFloat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtUintFloat(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtUintFloat(v Value, t Type) Value\n```\n\nconvertOp: uintXX -> floatXX \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtFloat",
                    "documentation": {
                      "identifier": "cvtFloat",
                      "newPage": false,
                      "searchKey": "reflect.cvtFloat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtFloat(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtFloat(v Value, t Type) Value\n```\n\nconvertOp: floatXX -> floatXX \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtComplex",
                    "documentation": {
                      "identifier": "cvtComplex",
                      "newPage": false,
                      "searchKey": "reflect.cvtComplex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtComplex(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtComplex(v Value, t Type) Value\n```\n\nconvertOp: complexXX -> complexXX \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtIntString",
                    "documentation": {
                      "identifier": "cvtIntString",
                      "newPage": false,
                      "searchKey": "reflect.cvtIntString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtIntString(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtIntString(v Value, t Type) Value\n```\n\nconvertOp: intXX -> string \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtUintString",
                    "documentation": {
                      "identifier": "cvtUintString",
                      "newPage": false,
                      "searchKey": "reflect.cvtUintString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtUintString(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtUintString(v Value, t Type) Value\n```\n\nconvertOp: uintXX -> string \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtBytesString",
                    "documentation": {
                      "identifier": "cvtBytesString",
                      "newPage": false,
                      "searchKey": "reflect.cvtBytesString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtBytesString(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtBytesString(v Value, t Type) Value\n```\n\nconvertOp: []byte -> string \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtStringBytes",
                    "documentation": {
                      "identifier": "cvtStringBytes",
                      "newPage": false,
                      "searchKey": "reflect.cvtStringBytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtStringBytes(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtStringBytes(v Value, t Type) Value\n```\n\nconvertOp: string -> []byte \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtRunesString",
                    "documentation": {
                      "identifier": "cvtRunesString",
                      "newPage": false,
                      "searchKey": "reflect.cvtRunesString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtRunesString(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtRunesString(v Value, t Type) Value\n```\n\nconvertOp: []rune -> string \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtStringRunes",
                    "documentation": {
                      "identifier": "cvtStringRunes",
                      "newPage": false,
                      "searchKey": "reflect.cvtStringRunes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtStringRunes(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtStringRunes(v Value, t Type) Value\n```\n\nconvertOp: string -> []rune \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtSliceArrayPtr",
                    "documentation": {
                      "identifier": "cvtSliceArrayPtr",
                      "newPage": false,
                      "searchKey": "reflect.cvtSliceArrayPtr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtSliceArrayPtr(v Value, t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtSliceArrayPtr(v Value, t Type) Value\n```\n\nconvertOp: []T -> *[N]T \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtDirect",
                    "documentation": {
                      "identifier": "cvtDirect",
                      "newPage": false,
                      "searchKey": "reflect.cvtDirect",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtDirect(v Value, typ Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtDirect(v Value, typ Type) Value\n```\n\nconvertOp: direct copy \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtT2I",
                    "documentation": {
                      "identifier": "cvtT2I",
                      "newPage": false,
                      "searchKey": "reflect.cvtT2I",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtT2I(v Value, typ Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtT2I(v Value, typ Type) Value\n```\n\nconvertOp: concrete -> interface \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#cvtI2I",
                    "documentation": {
                      "identifier": "cvtI2I",
                      "newPage": false,
                      "searchKey": "reflect.cvtI2I",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cvtI2I(v Value, typ Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cvtI2I(v Value, typ Type) Value\n```\n\nconvertOp: interface -> interface \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#MakeRO",
                    "documentation": {
                      "identifier": "MakeRO",
                      "newPage": false,
                      "searchKey": "reflect.MakeRO",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MakeRO(v Value) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MakeRO(v Value) Value\n```\n\nMakeRO returns a copy of v with the read-only flag set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.pointer",
                    "documentation": {
                      "identifier": "Value.pointer",
                      "newPage": false,
                      "searchKey": "reflect.Value.pointer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) pointer() unsafe.Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) pointer() unsafe.Pointer\n```\n\npointer returns the underlying pointer represented by v. v.Kind() must be Ptr, Map, Chan, Func, or UnsafePointer if v.Kind() == Ptr, the base type must not be go:notinheap. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Addr",
                    "documentation": {
                      "identifier": "Value.Addr",
                      "newPage": false,
                      "searchKey": "reflect.Value.Addr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Addr() Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Addr() Value\n```\n\nAddr returns a pointer value representing the address of v. It panics if CanAddr() returns false. Addr is typically used to obtain a pointer to a struct field or slice element in order to call a method that requires a pointer receiver. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Bool",
                    "documentation": {
                      "identifier": "Value.Bool",
                      "newPage": false,
                      "searchKey": "reflect.Value.Bool",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Bool() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Bool() bool\n```\n\nBool returns v's underlying value. It panics if v's kind is not Bool. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Bytes",
                    "documentation": {
                      "identifier": "Value.Bytes",
                      "newPage": false,
                      "searchKey": "reflect.Value.Bytes",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Bytes() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Bytes() []byte\n```\n\nBytes returns v's underlying value. It panics if v's underlying value is not a slice of bytes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.runes",
                    "documentation": {
                      "identifier": "Value.runes",
                      "newPage": false,
                      "searchKey": "reflect.Value.runes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) runes() []rune"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) runes() []rune\n```\n\nrunes returns v's underlying value. It panics if v's underlying value is not a slice of runes (int32s). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.CanAddr",
                    "documentation": {
                      "identifier": "Value.CanAddr",
                      "newPage": false,
                      "searchKey": "reflect.Value.CanAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) CanAddr() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) CanAddr() bool\n```\n\nCanAddr reports whether the value's address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.CanSet",
                    "documentation": {
                      "identifier": "Value.CanSet",
                      "newPage": false,
                      "searchKey": "reflect.Value.CanSet",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) CanSet() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) CanSet() bool\n```\n\nCanSet reports whether the value of v can be changed. A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling Set or any type-specific setter (e.g., SetBool, SetInt) will panic. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Call",
                    "documentation": {
                      "identifier": "Value.Call",
                      "newPage": false,
                      "searchKey": "reflect.Value.Call",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Call(in []Value) []Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Call(in []Value) []Value\n```\n\nCall calls the function v with the input arguments in. For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]). Call panics if v's Kind is not Func. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. If v is a variadic function, Call creates the variadic slice parameter itself, copying in the corresponding values. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.CallSlice",
                    "documentation": {
                      "identifier": "Value.CallSlice",
                      "newPage": false,
                      "searchKey": "reflect.Value.CallSlice",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) CallSlice(in []Value) []Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) CallSlice(in []Value) []Value\n```\n\nCallSlice calls the variadic function v with the input arguments in, assigning the slice in[len(in)-1] to v's final variadic argument. For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...). CallSlice panics if v's Kind is not Func or if v is not variadic. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.call",
                    "documentation": {
                      "identifier": "Value.call",
                      "newPage": false,
                      "searchKey": "reflect.Value.call",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) call(op string, in []Value) []Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) call(op string, in []Value) []Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Cap",
                    "documentation": {
                      "identifier": "Value.Cap",
                      "newPage": false,
                      "searchKey": "reflect.Value.Cap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Cap() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Cap() int\n```\n\nCap returns v's capacity. It panics if v's Kind is not Array, Chan, or Slice. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Close",
                    "documentation": {
                      "identifier": "Value.Close",
                      "newPage": false,
                      "searchKey": "reflect.Value.Close",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Close()\n```\n\nClose closes the channel v. It panics if v's Kind is not Chan. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Complex",
                    "documentation": {
                      "identifier": "Value.Complex",
                      "newPage": false,
                      "searchKey": "reflect.Value.Complex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Complex() complex128"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Complex() complex128\n```\n\nComplex returns v's underlying value, as a complex128. It panics if v's Kind is not Complex64 or Complex128 \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Elem",
                    "documentation": {
                      "identifier": "Value.Elem",
                      "newPage": false,
                      "searchKey": "reflect.Value.Elem",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Elem() Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Elem() Value\n```\n\nElem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Ptr. It returns the zero Value if v is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Field",
                    "documentation": {
                      "identifier": "Value.Field",
                      "newPage": false,
                      "searchKey": "reflect.Value.Field",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Field(i int) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Field(i int) Value\n```\n\nField returns the i'th field of the struct v. It panics if v's Kind is not Struct or i is out of range. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.FieldByIndex",
                    "documentation": {
                      "identifier": "Value.FieldByIndex",
                      "newPage": false,
                      "searchKey": "reflect.Value.FieldByIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) FieldByIndex(index []int) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) FieldByIndex(index []int) Value\n```\n\nFieldByIndex returns the nested field corresponding to index. It panics if v's Kind is not struct. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.FieldByName",
                    "documentation": {
                      "identifier": "Value.FieldByName",
                      "newPage": false,
                      "searchKey": "reflect.Value.FieldByName",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) FieldByName(name string) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) FieldByName(name string) Value\n```\n\nFieldByName returns the struct field with the given name. It returns the zero Value if no field was found. It panics if v's Kind is not struct. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.FieldByNameFunc",
                    "documentation": {
                      "identifier": "Value.FieldByNameFunc",
                      "newPage": false,
                      "searchKey": "reflect.Value.FieldByNameFunc",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) FieldByNameFunc(match func(string) bool) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) FieldByNameFunc(match func(string) bool) Value\n```\n\nFieldByNameFunc returns the struct field with a name that satisfies the match function. It panics if v's Kind is not struct. It returns the zero Value if no field was found. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Float",
                    "documentation": {
                      "identifier": "Value.Float",
                      "newPage": false,
                      "searchKey": "reflect.Value.Float",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Float() float64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Float() float64\n```\n\nFloat returns v's underlying value, as a float64. It panics if v's Kind is not Float32 or Float64 \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Index",
                    "documentation": {
                      "identifier": "Value.Index",
                      "newPage": false,
                      "searchKey": "reflect.Value.Index",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Index(i int) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Index(i int) Value\n```\n\nIndex returns v's i'th element. It panics if v's Kind is not Array, Slice, or String or i is out of range. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Int",
                    "documentation": {
                      "identifier": "Value.Int",
                      "newPage": false,
                      "searchKey": "reflect.Value.Int",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Int() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Int() int64\n```\n\nInt returns v's underlying value, as an int64. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.CanInterface",
                    "documentation": {
                      "identifier": "Value.CanInterface",
                      "newPage": false,
                      "searchKey": "reflect.Value.CanInterface",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) CanInterface() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) CanInterface() bool\n```\n\nCanInterface reports whether Interface can be used without panicking. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Interface",
                    "documentation": {
                      "identifier": "Value.Interface",
                      "newPage": false,
                      "searchKey": "reflect.Value.Interface",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Interface() (i interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Interface() (i interface{})\n```\n\nInterface returns v's current value as an interface{}. It is equivalent to: \n\n```\nvar i interface{} = (v's underlying value)\n\n```\nIt panics if the Value was obtained by accessing unexported struct fields. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.InterfaceData",
                    "documentation": {
                      "identifier": "Value.InterfaceData",
                      "newPage": false,
                      "searchKey": "reflect.Value.InterfaceData",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) InterfaceData() [2]uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) InterfaceData() [2]uintptr\n```\n\nInterfaceData returns the interface v's value as a uintptr pair. It panics if v's Kind is not Interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.IsNil",
                    "documentation": {
                      "identifier": "Value.IsNil",
                      "newPage": false,
                      "searchKey": "reflect.Value.IsNil",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) IsNil() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) IsNil() bool\n```\n\nIsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.IsValid",
                    "documentation": {
                      "identifier": "Value.IsValid",
                      "newPage": false,
                      "searchKey": "reflect.Value.IsValid",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) IsValid() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) IsValid() bool\n```\n\nIsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid Value. If one does, its documentation states the conditions explicitly. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.IsZero",
                    "documentation": {
                      "identifier": "Value.IsZero",
                      "newPage": false,
                      "searchKey": "reflect.Value.IsZero",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) IsZero() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) IsZero() bool\n```\n\nIsZero reports whether v is the zero value for its type. It panics if the argument is invalid. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Kind",
                    "documentation": {
                      "identifier": "Value.Kind",
                      "newPage": false,
                      "searchKey": "reflect.Value.Kind",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Kind() Kind"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Kind() Kind\n```\n\nKind returns v's Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Len",
                    "documentation": {
                      "identifier": "Value.Len",
                      "newPage": false,
                      "searchKey": "reflect.Value.Len",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Len() int\n```\n\nLen returns v's length. It panics if v's Kind is not Array, Chan, Map, Slice, or String. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.MapIndex",
                    "documentation": {
                      "identifier": "Value.MapIndex",
                      "newPage": false,
                      "searchKey": "reflect.Value.MapIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) MapIndex(key Value) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) MapIndex(key Value) Value\n```\n\nMapIndex returns the value associated with key in the map v. It panics if v's Kind is not Map. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key's value must be assignable to the map's key type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.MapKeys",
                    "documentation": {
                      "identifier": "Value.MapKeys",
                      "newPage": false,
                      "searchKey": "reflect.Value.MapKeys",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) MapKeys() []Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) MapKeys() []Value\n```\n\nMapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v's Kind is not Map. It returns an empty slice if v represents a nil map. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.MapRange",
                    "documentation": {
                      "identifier": "Value.MapRange",
                      "newPage": false,
                      "searchKey": "reflect.Value.MapRange",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) MapRange() *MapIter"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) MapRange() *MapIter\n```\n\nMapRange returns a range iterator for a map. It panics if v's Kind is not Map. \n\nCall Next to advance the iterator, and Key/Value to access each entry. Next returns false when the iterator is exhausted. MapRange follows the same iteration semantics as a range statement. \n\nExample: \n\n```\niter := reflect.ValueOf(m).MapRange()\nfor iter.Next() {\n\tk := iter.Key()\n\tv := iter.Value()\n\t...\n}\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Method",
                    "documentation": {
                      "identifier": "Value.Method",
                      "newPage": false,
                      "searchKey": "reflect.Value.Method",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Method(i int) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Method(i int) Value\n```\n\nMethod returns a function value corresponding to v's i'th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.NumMethod",
                    "documentation": {
                      "identifier": "Value.NumMethod",
                      "newPage": false,
                      "searchKey": "reflect.Value.NumMethod",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) NumMethod() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) NumMethod() int\n```\n\nNumMethod returns the number of exported methods in the value's method set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.MethodByName",
                    "documentation": {
                      "identifier": "Value.MethodByName",
                      "newPage": false,
                      "searchKey": "reflect.Value.MethodByName",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) MethodByName(name string) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) MethodByName(name string) Value\n```\n\nMethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.NumField",
                    "documentation": {
                      "identifier": "Value.NumField",
                      "newPage": false,
                      "searchKey": "reflect.Value.NumField",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) NumField() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) NumField() int\n```\n\nNumField returns the number of fields in the struct v. It panics if v's Kind is not Struct. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.OverflowComplex",
                    "documentation": {
                      "identifier": "Value.OverflowComplex",
                      "newPage": false,
                      "searchKey": "reflect.Value.OverflowComplex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) OverflowComplex(x complex128) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) OverflowComplex(x complex128) bool\n```\n\nOverflowComplex reports whether the complex128 x cannot be represented by v's type. It panics if v's Kind is not Complex64 or Complex128. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.OverflowFloat",
                    "documentation": {
                      "identifier": "Value.OverflowFloat",
                      "newPage": false,
                      "searchKey": "reflect.Value.OverflowFloat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) OverflowFloat(x float64) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) OverflowFloat(x float64) bool\n```\n\nOverflowFloat reports whether the float64 x cannot be represented by v's type. It panics if v's Kind is not Float32 or Float64. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.OverflowInt",
                    "documentation": {
                      "identifier": "Value.OverflowInt",
                      "newPage": false,
                      "searchKey": "reflect.Value.OverflowInt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) OverflowInt(x int64) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) OverflowInt(x int64) bool\n```\n\nOverflowInt reports whether the int64 x cannot be represented by v's type. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.OverflowUint",
                    "documentation": {
                      "identifier": "Value.OverflowUint",
                      "newPage": false,
                      "searchKey": "reflect.Value.OverflowUint",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) OverflowUint(x uint64) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) OverflowUint(x uint64) bool\n```\n\nOverflowUint reports whether the uint64 x cannot be represented by v's type. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Pointer",
                    "documentation": {
                      "identifier": "Value.Pointer",
                      "newPage": false,
                      "searchKey": "reflect.Value.Pointer",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Pointer() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Pointer() uintptr\n```\n\nPointer returns v's value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer. \n\nIf v's Kind is Func, the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value. \n\nIf v's Kind is Slice, the returned pointer is to the first element of the slice. If the slice is nil the returned value is 0.  If the slice is empty but non-nil the return value is non-zero. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Recv",
                    "documentation": {
                      "identifier": "Value.Recv",
                      "newPage": false,
                      "searchKey": "reflect.Value.Recv",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Recv() (x Value, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Recv() (x Value, ok bool)\n```\n\nRecv receives and returns a value from the channel v. It panics if v's Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.recv",
                    "documentation": {
                      "identifier": "Value.recv",
                      "newPage": false,
                      "searchKey": "reflect.Value.recv",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) recv(nb bool) (val Value, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) recv(nb bool) (val Value, ok bool)\n```\n\ninternal recv, possibly non-blocking (nb). v is known to be a channel. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Send",
                    "documentation": {
                      "identifier": "Value.Send",
                      "newPage": false,
                      "searchKey": "reflect.Value.Send",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Send(x Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Send(x Value)\n```\n\nSend sends x on the channel v. It panics if v's kind is not Chan or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.send",
                    "documentation": {
                      "identifier": "Value.send",
                      "newPage": false,
                      "searchKey": "reflect.Value.send",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) send(x Value, nb bool) (selected bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) send(x Value, nb bool) (selected bool)\n```\n\ninternal send, possibly non-blocking. v is known to be a channel. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Set",
                    "documentation": {
                      "identifier": "Value.Set",
                      "newPage": false,
                      "searchKey": "reflect.Value.Set",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Set(x Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Set(x Value)\n```\n\nSet assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetBool",
                    "documentation": {
                      "identifier": "Value.SetBool",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetBool",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetBool(x bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetBool(x bool)\n```\n\nSetBool sets v's underlying value. It panics if v's Kind is not Bool or if CanSet() is false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetBytes",
                    "documentation": {
                      "identifier": "Value.SetBytes",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetBytes",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetBytes(x []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetBytes(x []byte)\n```\n\nSetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.setRunes",
                    "documentation": {
                      "identifier": "Value.setRunes",
                      "newPage": false,
                      "searchKey": "reflect.Value.setRunes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) setRunes(x []rune)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) setRunes(x []rune)\n```\n\nsetRunes sets v's underlying value. It panics if v's underlying value is not a slice of runes (int32s). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetComplex",
                    "documentation": {
                      "identifier": "Value.SetComplex",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetComplex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetComplex(x complex128)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetComplex(x complex128)\n```\n\nSetComplex sets v's underlying value to x. It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetFloat",
                    "documentation": {
                      "identifier": "Value.SetFloat",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetFloat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetFloat(x float64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetFloat(x float64)\n```\n\nSetFloat sets v's underlying value to x. It panics if v's Kind is not Float32 or Float64, or if CanSet() is false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetInt",
                    "documentation": {
                      "identifier": "Value.SetInt",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetInt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetInt(x int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetInt(x int64)\n```\n\nSetInt sets v's underlying value to x. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetLen",
                    "documentation": {
                      "identifier": "Value.SetLen",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetLen",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetLen(n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetLen(n int)\n```\n\nSetLen sets v's length to n. It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetCap",
                    "documentation": {
                      "identifier": "Value.SetCap",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetCap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetCap(n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetCap(n int)\n```\n\nSetCap sets v's capacity to n. It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetMapIndex",
                    "documentation": {
                      "identifier": "Value.SetMapIndex",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetMapIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetMapIndex(key, elem Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetMapIndex(key, elem Value)\n```\n\nSetMapIndex sets the element associated with key in the map v to elem. It panics if v's Kind is not Map. If elem is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's elem must be assignable to the map's key type, and elem's value must be assignable to the map's elem type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetUint",
                    "documentation": {
                      "identifier": "Value.SetUint",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetUint",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetUint(x uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetUint(x uint64)\n```\n\nSetUint sets v's underlying value to x. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetPointer",
                    "documentation": {
                      "identifier": "Value.SetPointer",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetPointer",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetPointer(x unsafe.Pointer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetPointer(x unsafe.Pointer)\n```\n\nSetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is not UnsafePointer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.SetString",
                    "documentation": {
                      "identifier": "Value.SetString",
                      "newPage": false,
                      "searchKey": "reflect.Value.SetString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) SetString(x string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) SetString(x string)\n```\n\nSetString sets v's underlying value to x. It panics if v's Kind is not String or if CanSet() is false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Slice",
                    "documentation": {
                      "identifier": "Value.Slice",
                      "newPage": false,
                      "searchKey": "reflect.Value.Slice",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Slice(i, j int) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Slice(i, j int) Value\n```\n\nSlice returns v[i:j]. It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Slice3",
                    "documentation": {
                      "identifier": "Value.Slice3",
                      "newPage": false,
                      "searchKey": "reflect.Value.Slice3",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Slice3(i, j, k int) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Slice3(i, j, k int) Value\n```\n\nSlice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.String",
                    "documentation": {
                      "identifier": "Value.String",
                      "newPage": false,
                      "searchKey": "reflect.Value.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) String() string\n```\n\nString returns the string v's underlying value, as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Kind is not String. Instead, it returns a string of the form \"<T value>\" where T is v's type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.TryRecv",
                    "documentation": {
                      "identifier": "Value.TryRecv",
                      "newPage": false,
                      "searchKey": "reflect.Value.TryRecv",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) TryRecv() (x Value, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) TryRecv() (x Value, ok bool)\n```\n\nTryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.TrySend",
                    "documentation": {
                      "identifier": "Value.TrySend",
                      "newPage": false,
                      "searchKey": "reflect.Value.TrySend",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) TrySend(x Value) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) TrySend(x Value) bool\n```\n\nTrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Type",
                    "documentation": {
                      "identifier": "Value.Type",
                      "newPage": false,
                      "searchKey": "reflect.Value.Type",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Type() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Type() Type\n```\n\nType returns v's type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Uint",
                    "documentation": {
                      "identifier": "Value.Uint",
                      "newPage": false,
                      "searchKey": "reflect.Value.Uint",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Uint() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Uint() uint64\n```\n\nUint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.UnsafeAddr",
                    "documentation": {
                      "identifier": "Value.UnsafeAddr",
                      "newPage": false,
                      "searchKey": "reflect.Value.UnsafeAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) UnsafeAddr() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) UnsafeAddr() uintptr\n```\n\nUnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the \"unsafe\" package. It panics if v is not addressable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.assignTo",
                    "documentation": {
                      "identifier": "Value.assignTo",
                      "newPage": false,
                      "searchKey": "reflect.Value.assignTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value\n```\n\nassignTo returns a value v that can be assigned directly to typ. It panics if v is not assignable to typ. For a conversion to an interface type, target is a suggested scratch space to use. target must be initialized memory (or nil). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#Value.Convert",
                    "documentation": {
                      "identifier": "Value.Convert",
                      "newPage": false,
                      "searchKey": "reflect.Value.Convert",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v Value) Convert(t Type) Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v Value) Convert(t Type) Value\n```\n\nConvert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, or if converting v to type t panics, Convert panics. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#flag",
              "documentation": {
                "identifier": "flag",
                "newPage": false,
                "searchKey": "reflect.flag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type flag uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype flag uintptr\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#flag.kind",
                    "documentation": {
                      "identifier": "flag.kind",
                      "newPage": false,
                      "searchKey": "reflect.flag.kind",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f flag) kind() Kind"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f flag) kind() Kind\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#flag.ro",
                    "documentation": {
                      "identifier": "flag.ro",
                      "newPage": false,
                      "searchKey": "reflect.flag.ro",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f flag) ro() flag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f flag) ro() flag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#flag.mustBe",
                    "documentation": {
                      "identifier": "flag.mustBe",
                      "newPage": false,
                      "searchKey": "reflect.flag.mustBe",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f flag) mustBe(expected Kind)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f flag) mustBe(expected Kind)\n```\n\nmustBe panics if f's kind is not expected. Making this a method on flag instead of on Value (and embedding flag in Value) means that we can write the very clear v.mustBe(Bool) and have it compile into v.flag.mustBe(Bool), which will only bother to copy the single important word for the receiver. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#flag.mustBeExported",
                    "documentation": {
                      "identifier": "flag.mustBeExported",
                      "newPage": false,
                      "searchKey": "reflect.flag.mustBeExported",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f flag) mustBeExported()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f flag) mustBeExported()\n```\n\nmustBeExported panics if f records that the value was obtained using an unexported field. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#flag.mustBeExportedSlow",
                    "documentation": {
                      "identifier": "flag.mustBeExportedSlow",
                      "newPage": false,
                      "searchKey": "reflect.flag.mustBeExportedSlow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f flag) mustBeExportedSlow()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f flag) mustBeExportedSlow()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#flag.mustBeAssignable",
                    "documentation": {
                      "identifier": "flag.mustBeAssignable",
                      "newPage": false,
                      "searchKey": "reflect.flag.mustBeAssignable",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f flag) mustBeAssignable()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f flag) mustBeAssignable()\n```\n\nmustBeAssignable panics if f records that the value is not assignable, which is to say that either it was obtained using an unexported field or it is not addressable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#flag.mustBeAssignableSlow",
                    "documentation": {
                      "identifier": "flag.mustBeAssignableSlow",
                      "newPage": false,
                      "searchKey": "reflect.flag.mustBeAssignableSlow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f flag) mustBeAssignableSlow()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f flag) mustBeAssignableSlow()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#ValueError",
              "documentation": {
                "identifier": "ValueError",
                "newPage": false,
                "searchKey": "reflect.ValueError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ValueError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ValueError struct {\n\tMethod string\n\tKind   Kind\n}\n```\n\nA ValueError occurs when a Value method is invoked on a Value that does not support it. Such cases are documented in the description of each method. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#ValueError.Error",
                    "documentation": {
                      "identifier": "ValueError.Error",
                      "newPage": false,
                      "searchKey": "reflect.ValueError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ValueError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ValueError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#emptyInterface",
              "documentation": {
                "identifier": "emptyInterface",
                "newPage": false,
                "searchKey": "reflect.emptyInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type emptyInterface struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype emptyInterface struct {\n\ttyp  *rtype\n\tword unsafe.Pointer\n}\n```\n\nemptyInterface is the header for an interface{} value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#nonEmptyInterface",
              "documentation": {
                "identifier": "nonEmptyInterface",
                "newPage": false,
                "searchKey": "reflect.nonEmptyInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nonEmptyInterface struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nonEmptyInterface struct {\n\t// see ../runtime/iface.go:/Itab\n\titab *struct {\n\t\tityp *rtype // static interface type\n\t\ttyp  *rtype // dynamic concrete type\n\t\thash uint32 // copy of typ.hash\n\t\t_    [4]byte\n\t\tfun  [100000]unsafe.Pointer // method table\n\t}\n\tword unsafe.Pointer\n}\n```\n\nnonEmptyInterface is the header for an interface value with methods. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#MapIter",
              "documentation": {
                "identifier": "MapIter",
                "newPage": false,
                "searchKey": "reflect.MapIter",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type MapIter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype MapIter struct {\n\tm  Value\n\tit unsafe.Pointer\n}\n```\n\nA MapIter is an iterator for ranging over a map. See Value.MapRange. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#MapIter.Key",
                    "documentation": {
                      "identifier": "MapIter.Key",
                      "newPage": false,
                      "searchKey": "reflect.MapIter.Key",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (it *MapIter) Key() Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (it *MapIter) Key() Value\n```\n\nKey returns the key of the iterator's current map entry. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#MapIter.Value",
                    "documentation": {
                      "identifier": "MapIter.Value",
                      "newPage": false,
                      "searchKey": "reflect.MapIter.Value",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (it *MapIter) Value() Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (it *MapIter) Value() Value\n```\n\nValue returns the value of the iterator's current map entry. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/reflect#MapIter.Next",
                    "documentation": {
                      "identifier": "MapIter.Next",
                      "newPage": false,
                      "searchKey": "reflect.MapIter.Next",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (it *MapIter) Next() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (it *MapIter) Next() bool\n```\n\nNext advances the map iterator and reports whether there is another entry. It returns false when the iterator is exhausted; subsequent calls to Key, Value, or Next will panic. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#StringHeader",
              "documentation": {
                "identifier": "StringHeader",
                "newPage": false,
                "searchKey": "reflect.StringHeader",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type StringHeader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype StringHeader struct {\n\tData uintptr\n\tLen  int\n}\n```\n\nStringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#SliceHeader",
              "documentation": {
                "identifier": "SliceHeader",
                "newPage": false,
                "searchKey": "reflect.SliceHeader",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type SliceHeader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SliceHeader struct {\n\tData uintptr\n\tLen  int\n\tCap  int\n}\n```\n\nSliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#runtimeSelect",
              "documentation": {
                "identifier": "runtimeSelect",
                "newPage": false,
                "searchKey": "reflect.runtimeSelect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type runtimeSelect struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype runtimeSelect struct {\n\tdir SelectDir      // SelectSend, SelectRecv or SelectDefault\n\ttyp *rtype         // channel type\n\tch  unsafe.Pointer // channel\n\tval unsafe.Pointer // ptr to data (SendDir) or ptr to receive buffer (RecvDir)\n}\n```\n\nA runtimeSelect is a single case passed to rselect. This must match ../runtime/select.go:/runtimeSelect \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#SelectDir",
              "documentation": {
                "identifier": "SelectDir",
                "newPage": false,
                "searchKey": "reflect.SelectDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type SelectDir int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SelectDir int\n```\n\nA SelectDir describes the communication direction of a select case. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#SelectCase",
              "documentation": {
                "identifier": "SelectCase",
                "newPage": false,
                "searchKey": "reflect.SelectCase",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type SelectCase struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SelectCase struct {\n\tDir  SelectDir // direction of case\n\tChan Value     // channel to use (for send or receive)\n\tSend Value     // value to send (for send)\n}\n```\n\nA SelectCase describes a single case in a select operation. The kind of case depends on Dir, the communication direction. \n\nIf Dir is SelectDefault, the case represents a default case. Chan and Send must be zero Values. \n\nIf Dir is SelectSend, the case represents a send operation. Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non-zero. \n\nIf Dir is SelectRecv, the case represents a receive operation. Normally Chan's underlying value must be a channel and Send must be a zero Value. If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. When a receive operation is selected, the received Value is returned by Select. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#visibleFieldsWalker",
              "documentation": {
                "identifier": "visibleFieldsWalker",
                "newPage": false,
                "searchKey": "reflect.visibleFieldsWalker",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type visibleFieldsWalker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype visibleFieldsWalker struct {\n\tbyName   map[string]int\n\tvisiting map[Type]bool\n\tfields   []StructField\n\tindex    []int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#visibleFieldsWalker.walk",
                    "documentation": {
                      "identifier": "visibleFieldsWalker.walk",
                      "newPage": false,
                      "searchKey": "reflect.visibleFieldsWalker.walk",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *visibleFieldsWalker) walk(t Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *visibleFieldsWalker) walk(t Type)\n```\n\nwalk walks all the fields in the struct type t, visiting fields in index preorder and appending them to w.fields (this maintains the required ordering). Fields that have been overridden have their Name field cleared. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#EmbedWithUnexpMeth",
              "documentation": {
                "identifier": "EmbedWithUnexpMeth",
                "newPage": false,
                "searchKey": "reflect.EmbedWithUnexpMeth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type EmbedWithUnexpMeth struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype EmbedWithUnexpMeth struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/reflect#EmbedWithUnexpMeth.f",
                    "documentation": {
                      "identifier": "EmbedWithUnexpMeth.f",
                      "newPage": false,
                      "searchKey": "reflect.EmbedWithUnexpMeth.f",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (EmbedWithUnexpMeth) f()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (EmbedWithUnexpMeth) f()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#pinUnexpMeth",
              "documentation": {
                "identifier": "pinUnexpMeth",
                "newPage": false,
                "searchKey": "reflect.pinUnexpMeth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pinUnexpMeth interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pinUnexpMeth interface {\n\tf()\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#OtherPkgFields",
              "documentation": {
                "identifier": "OtherPkgFields",
                "newPage": false,
                "searchKey": "reflect.OtherPkgFields",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type OtherPkgFields struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype OtherPkgFields struct {\n\tOtherExported   int\n\totherUnexported int\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Buffer",
              "documentation": {
                "identifier": "Buffer",
                "newPage": false,
                "searchKey": "reflect.Buffer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Buffer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Buffer struct {\n\tbuf []byte\n}\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/reflect#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/reflect#dumpPtrBitMap",
              "documentation": {
                "identifier": "dumpPtrBitMap",
                "newPage": false,
                "searchKey": "reflect.dumpPtrBitMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpPtrBitMap(b abi.IntArgRegBitmap)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpPtrBitMap(b abi.IntArgRegBitmap)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#deepValueEqual",
              "documentation": {
                "identifier": "deepValueEqual",
                "newPage": false,
                "searchKey": "reflect.deepValueEqual",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deepValueEqual(v1, v2 Value, visited map[visit]bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deepValueEqual(v1, v2 Value, visited map[visit]bool) bool\n```\n\nTests for deep equality using reflected types. The map argument tracks comparisons that have already been seen, which allows short circuiting on recursive types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#DeepEqual",
              "documentation": {
                "identifier": "DeepEqual",
                "newPage": false,
                "searchKey": "reflect.DeepEqual",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func DeepEqual(x, y interface{}) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc DeepEqual(x, y interface{}) bool\n```\n\nDeepEqual reports whether x and y are `deeply equal,' defined as follows. Two values of identical type are deeply equal if one of the following cases applies. Values of distinct types are never deeply equal. \n\nArray values are deeply equal when their corresponding elements are deeply equal. \n\nStruct values are deeply equal if their corresponding fields, both exported and unexported, are deeply equal. \n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal. \n\nInterface values are deeply equal if they hold deeply equal concrete values. \n\nMap values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they are the same map object or their corresponding keys (matched using Go equality) map to deeply equal values. \n\nPointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values. \n\nSlice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil)) are not deeply equal. \n\nOther values - numbers, bools, strings, and channels - are deeply equal if they are equal using Go's == operator. \n\nIn general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content. \n\nAs DeepEqual traverses the data values it may find a cycle. The second and subsequent times that DeepEqual compares two pointer values that have been compared before, it treats the values as equal rather than examining the values to which they point. This ensures that DeepEqual terminates. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#makeFuncStub",
              "documentation": {
                "identifier": "makeFuncStub",
                "newPage": false,
                "searchKey": "reflect.makeFuncStub",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeFuncStub()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeFuncStub()\n```\n\nmakeFuncStub is an assembly function that is the code half of the function returned from MakeFunc. It expects a *callReflectFunc as its context register, and its job is to invoke callReflect(ctxt, frame) where ctxt is the context register and frame is a pointer to the first word in the passed-in argument frame. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#methodValueCall",
              "documentation": {
                "identifier": "methodValueCall",
                "newPage": false,
                "searchKey": "reflect.methodValueCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func methodValueCall()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc methodValueCall()\n```\n\nmethodValueCall is an assembly function that is the code half of the function returned from makeMethodValue. It expects a *methodValue as its context register, and its job is to invoke callMethod(ctxt, frame) where ctxt is the context register and frame is a pointer to the first word in the passed-in argument frame. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#moveMakeFuncArgPtrs",
              "documentation": {
                "identifier": "moveMakeFuncArgPtrs",
                "newPage": false,
                "searchKey": "reflect.moveMakeFuncArgPtrs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func moveMakeFuncArgPtrs(ctxt *makeFuncCtxt, args *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc moveMakeFuncArgPtrs(ctxt *makeFuncCtxt, args *abi.RegArgs)\n```\n\nmoveMakeFuncArgPtrs uses ctxt.regPtrs to copy integer pointer arguments in args.Ints to args.Ptrs where the GC can see them. \n\nThis is similar to what reflectcallmove does in the runtime, except that happens on the return path, whereas this happens on the call path. \n\nnosplit because pointers are being held in uintptr slots in args, so having our stack scanned now could lead to accidentally freeing memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Swapper",
              "documentation": {
                "identifier": "Swapper",
                "newPage": false,
                "searchKey": "reflect.Swapper",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Swapper(slice interface{}) func(i, j int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Swapper(slice interface{}) func(i, j int)\n```\n\nSwapper returns a function that swaps the elements in the provided slice. \n\nSwapper panics if the provided interface is not a slice. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#writeVarint",
              "documentation": {
                "identifier": "writeVarint",
                "newPage": false,
                "searchKey": "reflect.writeVarint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeVarint(buf []byte, n int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeVarint(buf []byte, n int) int\n```\n\nwriteVarint writes n to buf in varint form. Returns the number of bytes written. n must be nonnegative. Writes at most 10 bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#resolveNameOff",
              "documentation": {
                "identifier": "resolveNameOff",
                "newPage": false,
                "searchKey": "reflect.resolveNameOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer\n```\n\nresolveNameOff resolves a name offset from a base pointer. The (*rtype).nameOff method is a convenience wrapper for this function. Implemented in the runtime package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#resolveTypeOff",
              "documentation": {
                "identifier": "resolveTypeOff",
                "newPage": false,
                "searchKey": "reflect.resolveTypeOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer\n```\n\nresolveTypeOff resolves an *rtype offset from a base type. The (*rtype).typeOff method is a convenience wrapper for this function. Implemented in the runtime package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#resolveTextOff",
              "documentation": {
                "identifier": "resolveTextOff",
                "newPage": false,
                "searchKey": "reflect.resolveTextOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func resolveTextOff(rtype unsafe.Pointer, off int32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resolveTextOff(rtype unsafe.Pointer, off int32) unsafe.Pointer\n```\n\nresolveTextOff resolves a function pointer offset from a base type. The (*rtype).textOff method is a convenience wrapper for this function. Implemented in the runtime package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#addReflectOff",
              "documentation": {
                "identifier": "addReflectOff",
                "newPage": false,
                "searchKey": "reflect.addReflectOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addReflectOff(ptr unsafe.Pointer) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addReflectOff(ptr unsafe.Pointer) int32\n```\n\naddReflectOff adds a pointer to the reflection lookup map in the runtime. It returns a new ID that can be used as a typeOff or textOff, and will be resolved correctly. Implemented in the runtime package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#add",
              "documentation": {
                "identifier": "add",
                "newPage": false,
                "searchKey": "reflect.add",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func add(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc add(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer\n```\n\nadd returns p+x. \n\nThe whySafe string is ignored, so that the function still inlines as efficiently as p+x, but all call sites should use the string to record why the addition is safe, which is to say why the addition does not cause x to advance to the very end of p's allocation and therefore point incorrectly at the next block in memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#fnv1",
              "documentation": {
                "identifier": "fnv1",
                "newPage": false,
                "searchKey": "reflect.fnv1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fnv1(x uint32, list ...byte) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fnv1(x uint32, list ...byte) uint32\n```\n\nfnv1 incorporates the list of bytes into the hash x using the FNV-1 hash function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#implements",
              "documentation": {
                "identifier": "implements",
                "newPage": false,
                "searchKey": "reflect.implements",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func implements(T, V *rtype) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc implements(T, V *rtype) bool\n```\n\nimplements reports whether the type V implements the interface type T. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#specialChannelAssignability",
              "documentation": {
                "identifier": "specialChannelAssignability",
                "newPage": false,
                "searchKey": "reflect.specialChannelAssignability",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func specialChannelAssignability(T, V *rtype) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc specialChannelAssignability(T, V *rtype) bool\n```\n\nspecialChannelAssignability reports whether a value x of channel type V can be directly assigned (using memmove) to another channel type T. [https://golang.org/doc/go_spec.html#Assignability](https://golang.org/doc/go_spec.html#Assignability) T and V must be both of Chan kind. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#directlyAssignable",
              "documentation": {
                "identifier": "directlyAssignable",
                "newPage": false,
                "searchKey": "reflect.directlyAssignable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func directlyAssignable(T, V *rtype) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc directlyAssignable(T, V *rtype) bool\n```\n\ndirectlyAssignable reports whether a value x of type V can be directly assigned (using memmove) to a value of type T. [https://golang.org/doc/go_spec.html#Assignability](https://golang.org/doc/go_spec.html#Assignability) Ignoring the interface rules (implemented elsewhere) and the ideal constant rules (no ideal constants at run time). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#haveIdenticalType",
              "documentation": {
                "identifier": "haveIdenticalType",
                "newPage": false,
                "searchKey": "reflect.haveIdenticalType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func haveIdenticalType(T, V Type, cmpTags bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc haveIdenticalType(T, V Type, cmpTags bool) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#haveIdenticalUnderlyingType",
              "documentation": {
                "identifier": "haveIdenticalUnderlyingType",
                "newPage": false,
                "searchKey": "reflect.haveIdenticalUnderlyingType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func haveIdenticalUnderlyingType(T, V *rtype, cmpTags bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc haveIdenticalUnderlyingType(T, V *rtype, cmpTags bool) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typelinks",
              "documentation": {
                "identifier": "typelinks",
                "newPage": false,
                "searchKey": "reflect.typelinks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typelinks() (sections []unsafe.Pointer, offset [][]int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typelinks() (sections []unsafe.Pointer, offset [][]int32)\n```\n\ntypelinks is implemented in package runtime. It returns a slice of the sections in each module, and a slice of *rtype offsets in each module. \n\nThe types in each module are sorted by string. That is, the first two linked types of the first module are: \n\n```\nd0 := sections[0]\nt1 := (*rtype)(add(d0, offset[0][0]))\nt2 := (*rtype)(add(d0, offset[0][1]))\n\n```\nand \n\n```\nt1.String() < t2.String()\n\n```\nNote that strings are not unique identifiers for types: there can be more than one with a given string. Only types we might want to look up are included: pointers, channels, maps, slices, and arrays. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typesByString",
              "documentation": {
                "identifier": "typesByString",
                "newPage": false,
                "searchKey": "reflect.typesByString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typesByString(s string) []*rtype"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typesByString(s string) []*rtype\n```\n\ntypesByString returns the subslice of typelinks() whose elements have the given string representation. It may be empty (no known types with that string) or may have multiple elements (multiple types with that string). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcStr",
              "documentation": {
                "identifier": "funcStr",
                "newPage": false,
                "searchKey": "reflect.funcStr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcStr(ft *funcType) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcStr(ft *funcType) string\n```\n\nfuncStr builds a string representation of a funcType. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#isReflexive",
              "documentation": {
                "identifier": "isReflexive",
                "newPage": false,
                "searchKey": "reflect.isReflexive",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isReflexive(t *rtype) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isReflexive(t *rtype) bool\n```\n\nisReflexive reports whether the == operation on the type is reflexive. That is, x == x for all values x of type t. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#needKeyUpdate",
              "documentation": {
                "identifier": "needKeyUpdate",
                "newPage": false,
                "searchKey": "reflect.needKeyUpdate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func needKeyUpdate(t *rtype) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc needKeyUpdate(t *rtype) bool\n```\n\nneedKeyUpdate reports whether map overwrites require the key to be copied. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#hashMightPanic",
              "documentation": {
                "identifier": "hashMightPanic",
                "newPage": false,
                "searchKey": "reflect.hashMightPanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hashMightPanic(t *rtype) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hashMightPanic(t *rtype) bool\n```\n\nhashMightPanic reports whether the hash of a map key of type t might panic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#emitGCMask",
              "documentation": {
                "identifier": "emitGCMask",
                "newPage": false,
                "searchKey": "reflect.emitGCMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func emitGCMask(out []byte, base uintptr, typ *rtype, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc emitGCMask(out []byte, base uintptr, typ *rtype, n uintptr)\n```\n\nemitGCMask writes the GC mask for [n]typ into out, starting at bit offset base. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#appendGCProg",
              "documentation": {
                "identifier": "appendGCProg",
                "newPage": false,
                "searchKey": "reflect.appendGCProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendGCProg(dst []byte, typ *rtype) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendGCProg(dst []byte, typ *rtype) []byte\n```\n\nappendGCProg appends the GC program for the first ptrdata bytes of typ to dst and returns the extended slice. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#isLetter",
              "documentation": {
                "identifier": "isLetter",
                "newPage": false,
                "searchKey": "reflect.isLetter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isLetter(ch rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isLetter(ch rune) bool\n```\n\nisLetter reports whether a given 'rune' is classified as a Letter. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#isValidFieldName",
              "documentation": {
                "identifier": "isValidFieldName",
                "newPage": false,
                "searchKey": "reflect.isValidFieldName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isValidFieldName(fieldName string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isValidFieldName(fieldName string) bool\n```\n\nisValidFieldName checks if a string is a valid (struct) field name or not. \n\nAccording to the language spec, a field name should be an identifier. \n\nidentifier = letter { letter | unicode_digit } . letter = unicode_letter | \"_\" . \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typeptrdata",
              "documentation": {
                "identifier": "typeptrdata",
                "newPage": false,
                "searchKey": "reflect.typeptrdata",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typeptrdata(t *rtype) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typeptrdata(t *rtype) uintptr\n```\n\ntypeptrdata returns the length in bytes of the prefix of t containing pointer data. Anything after this offset is scalar data. keep in sync with ../cmd/compile/internal/gc/reflect.go \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#appendVarint",
              "documentation": {
                "identifier": "appendVarint",
                "newPage": false,
                "searchKey": "reflect.appendVarint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendVarint(x []byte, v uintptr) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendVarint(x []byte, v uintptr) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#ifaceIndir",
              "documentation": {
                "identifier": "ifaceIndir",
                "newPage": false,
                "searchKey": "reflect.ifaceIndir",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ifaceIndir(t *rtype) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ifaceIndir(t *rtype) bool\n```\n\nifaceIndir reports whether t is stored indirectly in an interface value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#addTypeBits",
              "documentation": {
                "identifier": "addTypeBits",
                "newPage": false,
                "searchKey": "reflect.addTypeBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addTypeBits(bv *bitVector, offset uintptr, t *rtype)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addTypeBits(bv *bitVector, offset uintptr, t *rtype)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#packEface",
              "documentation": {
                "identifier": "packEface",
                "newPage": false,
                "searchKey": "reflect.packEface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func packEface(v Value) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc packEface(v Value) interface{}\n```\n\npackEface converts v to the empty interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#methodName",
              "documentation": {
                "identifier": "methodName",
                "newPage": false,
                "searchKey": "reflect.methodName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func methodName() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc methodName() string\n```\n\nmethodName returns the name of the calling method, assumed to be two stack frames above. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#methodNameSkip",
              "documentation": {
                "identifier": "methodNameSkip",
                "newPage": false,
                "searchKey": "reflect.methodNameSkip",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func methodNameSkip() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc methodNameSkip() string\n```\n\nmethodNameSkip is like methodName, but skips another stack frame. This is a separate function so that reflect.flag.mustBe will be inlined. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#callReflect",
              "documentation": {
                "identifier": "callReflect",
                "newPage": false,
                "searchKey": "reflect.callReflect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func callReflect(ctxt *makeFuncImpl, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc callReflect(ctxt *makeFuncImpl, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs)\n```\n\ncallReflect is the call implementation used by a function returned by MakeFunc. In many ways it is the opposite of the method Value.call above. The method above converts a call using Values into a call of a function with a concrete argument frame, while callReflect converts a call of a function with a concrete argument frame into a call using Values. It is in this file so that it can be next to the call method above. The remainder of the MakeFunc implementation is in makefunc.go. \n\nNOTE: This function must be marked as a \"wrapper\" in the generated code, so that the linker can make it work correctly for panic and recover. The gc compilers know to do that for the name \"reflect.callReflect\". \n\nctxt is the \"closure\" generated by MakeFunc. frame is a pointer to the arguments to that closure on the stack. retValid points to a boolean which should be set when the results section of frame is set. \n\nregs contains the argument values passed in registers and will contain the values returned from ctxt.fn in registers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#storeRcvr",
              "documentation": {
                "identifier": "storeRcvr",
                "newPage": false,
                "searchKey": "reflect.storeRcvr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func storeRcvr(v Value, p unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc storeRcvr(v Value, p unsafe.Pointer)\n```\n\nv is a method receiver. Store at p the word which is used to encode that receiver at the start of the argument list. Reflect uses the \"interface\" calling convention for methods, which always uses one word to record the receiver. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#align",
              "documentation": {
                "identifier": "align",
                "newPage": false,
                "searchKey": "reflect.align",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func align(x, n uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc align(x, n uintptr) uintptr\n```\n\nalign returns the result of rounding x up to a multiple of n. n must be a power of two. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#callMethod",
              "documentation": {
                "identifier": "callMethod",
                "newPage": false,
                "searchKey": "reflect.callMethod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func callMethod(ctxt *methodValue, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc callMethod(ctxt *methodValue, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs)\n```\n\ncallMethod is the call implementation used by a function returned by makeMethodValue (used by v.Method(i).Interface()). It is a streamlined version of the usual reflect call: the caller has already laid out the argument frame for us, so we don't have to deal with individual Values for each argument. It is in this file so that it can be next to the two similar functions above. The remainder of the makeMethodValue implementation is in makefunc.go. \n\nNOTE: This function must be marked as a \"wrapper\" in the generated code, so that the linker can make it work correctly for panic and recover. The gc compilers know to do that for the name \"reflect.callMethod\". \n\nctxt is the \"closure\" generated by makeVethodValue. frame is a pointer to the arguments to that closure on the stack. retValid points to a boolean which should be set when the results section of frame is set. \n\nregs contains the argument values passed in registers and will contain the values returned from ctxt.fn in registers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#funcName",
              "documentation": {
                "identifier": "funcName",
                "newPage": false,
                "searchKey": "reflect.funcName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcName(f func([]Value) []Value) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcName(f func([]Value) []Value) string\n```\n\nfuncName returns the name of f, for use in error messages. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#valueInterface",
              "documentation": {
                "identifier": "valueInterface",
                "newPage": false,
                "searchKey": "reflect.valueInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func valueInterface(v Value, safe bool) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc valueInterface(v Value, safe bool) interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#overflowFloat32",
              "documentation": {
                "identifier": "overflowFloat32",
                "newPage": false,
                "searchKey": "reflect.overflowFloat32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func overflowFloat32(x float64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc overflowFloat32(x float64) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typesMustMatch",
              "documentation": {
                "identifier": "typesMustMatch",
                "newPage": false,
                "searchKey": "reflect.typesMustMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typesMustMatch(what string, t1, t2 Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typesMustMatch(what string, t1, t2 Type)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#arrayAt",
              "documentation": {
                "identifier": "arrayAt",
                "newPage": false,
                "searchKey": "reflect.arrayAt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func arrayAt(p unsafe.Pointer, i int, eltSize uintptr, whySafe string) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc arrayAt(p unsafe.Pointer, i int, eltSize uintptr, whySafe string) unsafe.Pointer\n```\n\narrayAt returns the i-th element of p, an array whose elements are eltSize bytes wide. The array pointed at by p must have at least i+1 elements: it is invalid (but impossible to check here) to pass i >= len, because then the result will point outside the array. whySafe must explain why i < len. (Passing \"i < len\" is fine; the benefit is to surface this assumption at the call site.) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#Copy",
              "documentation": {
                "identifier": "Copy",
                "newPage": false,
                "searchKey": "reflect.Copy",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Copy(dst, src Value) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Copy(dst, src Value) int\n```\n\nCopy copies the contents of src into dst until either dst has been filled or src has been exhausted. It returns the number of elements copied. Dst and src each must have kind Slice or Array, and dst and src must have the same element type. \n\nAs a special case, src can have kind String if the element type of dst is kind Uint8. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#rselect",
              "documentation": {
                "identifier": "rselect",
                "newPage": false,
                "searchKey": "reflect.rselect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func rselect([]runtimeSelect) (chosen int, recvOK bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rselect([]runtimeSelect) (chosen int, recvOK bool)\n```\n\nrselect runs a select. It returns the index of the chosen case. If the case was a receive, val is filled in with the received value. The conventional OK bool indicates whether the receive corresponds to a sent value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#unsafe_New",
              "documentation": {
                "identifier": "unsafe_New",
                "newPage": false,
                "searchKey": "reflect.unsafe_New",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unsafe_New(*rtype) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unsafe_New(*rtype) unsafe.Pointer\n```\n\nimplemented in package runtime \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#unsafe_NewArray",
              "documentation": {
                "identifier": "unsafe_NewArray",
                "newPage": false,
                "searchKey": "reflect.unsafe_NewArray",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unsafe_NewArray(*rtype, int) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unsafe_NewArray(*rtype, int) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#convertOp",
              "documentation": {
                "identifier": "convertOp",
                "newPage": false,
                "searchKey": "reflect.convertOp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func convertOp(dst, src *rtype) func(Value, Type) Value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc convertOp(dst, src *rtype) func(Value, Type) Value\n```\n\nconvertOp returns the function to convert a value of type src to a value of type dst. If the conversion is illegal, convertOp returns nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#chancap",
              "documentation": {
                "identifier": "chancap",
                "newPage": false,
                "searchKey": "reflect.chancap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chancap(ch unsafe.Pointer) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chancap(ch unsafe.Pointer) int\n```\n\nimplemented in ../runtime \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#chanclose",
              "documentation": {
                "identifier": "chanclose",
                "newPage": false,
                "searchKey": "reflect.chanclose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chanclose(ch unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chanclose(ch unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#chanlen",
              "documentation": {
                "identifier": "chanlen",
                "newPage": false,
                "searchKey": "reflect.chanlen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chanlen(ch unsafe.Pointer) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chanlen(ch unsafe.Pointer) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#chanrecv",
              "documentation": {
                "identifier": "chanrecv",
                "newPage": false,
                "searchKey": "reflect.chanrecv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chanrecv(ch unsafe.Pointer, nb bool, val unsafe.Pointer) (selected, received bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chanrecv(ch unsafe.Pointer, nb bool, val unsafe.Pointer) (selected, received bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#chansend",
              "documentation": {
                "identifier": "chansend",
                "newPage": false,
                "searchKey": "reflect.chansend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chansend(ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chansend(ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#makechan",
              "documentation": {
                "identifier": "makechan",
                "newPage": false,
                "searchKey": "reflect.makechan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makechan(typ *rtype, size int) (ch unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makechan(typ *rtype, size int) (ch unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#makemap",
              "documentation": {
                "identifier": "makemap",
                "newPage": false,
                "searchKey": "reflect.makemap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makemap(t *rtype, cap int) (m unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makemap(t *rtype, cap int) (m unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#mapaccess",
              "documentation": {
                "identifier": "mapaccess",
                "newPage": false,
                "searchKey": "reflect.mapaccess",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess(t *rtype, m unsafe.Pointer, key unsafe.Pointer) (val unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess(t *rtype, m unsafe.Pointer, key unsafe.Pointer) (val unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#mapassign",
              "documentation": {
                "identifier": "mapassign",
                "newPage": false,
                "searchKey": "reflect.mapassign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapassign(t *rtype, m unsafe.Pointer, key, val unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapassign(t *rtype, m unsafe.Pointer, key, val unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#mapdelete",
              "documentation": {
                "identifier": "mapdelete",
                "newPage": false,
                "searchKey": "reflect.mapdelete",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapdelete(t *rtype, m unsafe.Pointer, key unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapdelete(t *rtype, m unsafe.Pointer, key unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#mapiterinit",
              "documentation": {
                "identifier": "mapiterinit",
                "newPage": false,
                "searchKey": "reflect.mapiterinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapiterinit(t *rtype, m unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapiterinit(t *rtype, m unsafe.Pointer) unsafe.Pointer\n```\n\nm escapes into the return value, but the caller of mapiterinit doesn't let the return value escape. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#mapiterkey",
              "documentation": {
                "identifier": "mapiterkey",
                "newPage": false,
                "searchKey": "reflect.mapiterkey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapiterkey(it unsafe.Pointer) (key unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapiterkey(it unsafe.Pointer) (key unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#mapiterelem",
              "documentation": {
                "identifier": "mapiterelem",
                "newPage": false,
                "searchKey": "reflect.mapiterelem",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapiterelem(it unsafe.Pointer) (elem unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapiterelem(it unsafe.Pointer) (elem unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#mapiternext",
              "documentation": {
                "identifier": "mapiternext",
                "newPage": false,
                "searchKey": "reflect.mapiternext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapiternext(it unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapiternext(it unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#maplen",
              "documentation": {
                "identifier": "maplen",
                "newPage": false,
                "searchKey": "reflect.maplen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func maplen(m unsafe.Pointer) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc maplen(m unsafe.Pointer) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#call",
              "documentation": {
                "identifier": "call",
                "newPage": false,
                "searchKey": "reflect.call",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call(stackArgsType *rtype, f, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call(stackArgsType *rtype, f, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\ncall calls fn with \"stackArgsSize\" bytes of stack arguments laid out at stackArgs and register arguments laid out in regArgs. frameSize is the total amount of stack space that will be reserved by call, so this should include enough space to spill register arguments to the stack in case of preemption. \n\nAfter fn returns, call copies stackArgsSize-stackRetOffset result bytes back into stackArgs+stackRetOffset before returning, for any return values passed on the stack. Register-based return values will be found in the same regArgs structure. \n\nregArgs must also be prepared with an appropriate ReturnIsPtr bitmap indicating which registers will contain pointer-valued return values. The purpose of this bitmap is to keep pointers visible to the GC between returning from reflectcall and actually using them. \n\nIf copying result bytes back from the stack, the caller must pass the argument frame type as stackArgsType, so that call can execute appropriate write barriers during the copy. \n\nArguments passed through to call do not escape. The type is used only in a very limited callee of call, the stackArgs are copied, and regArgs is only used in the call frame. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#ifaceE2I",
              "documentation": {
                "identifier": "ifaceE2I",
                "newPage": false,
                "searchKey": "reflect.ifaceE2I",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ifaceE2I(t *rtype, src interface{}, dst unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ifaceE2I(t *rtype, src interface{}, dst unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#memmove",
              "documentation": {
                "identifier": "memmove",
                "newPage": false,
                "searchKey": "reflect.memmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memmove(dst, src unsafe.Pointer, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memmove(dst, src unsafe.Pointer, size uintptr)\n```\n\nmemmove copies size bytes to dst from src. No write barriers are used. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typedmemmove",
              "documentation": {
                "identifier": "typedmemmove",
                "newPage": false,
                "searchKey": "reflect.typedmemmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typedmemmove(t *rtype, dst, src unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typedmemmove(t *rtype, dst, src unsafe.Pointer)\n```\n\ntypedmemmove copies a value of type t to dst from src. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typedmemmovepartial",
              "documentation": {
                "identifier": "typedmemmovepartial",
                "newPage": false,
                "searchKey": "reflect.typedmemmovepartial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typedmemmovepartial(t *rtype, dst, src unsafe.Pointer, off, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typedmemmovepartial(t *rtype, dst, src unsafe.Pointer, off, size uintptr)\n```\n\ntypedmemmovepartial is like typedmemmove but assumes that dst and src point off bytes into the value and only copies size bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typedmemclr",
              "documentation": {
                "identifier": "typedmemclr",
                "newPage": false,
                "searchKey": "reflect.typedmemclr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typedmemclr(t *rtype, ptr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typedmemclr(t *rtype, ptr unsafe.Pointer)\n```\n\ntypedmemclr zeros the value at ptr of type t. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typedmemclrpartial",
              "documentation": {
                "identifier": "typedmemclrpartial",
                "newPage": false,
                "searchKey": "reflect.typedmemclrpartial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typedmemclrpartial(t *rtype, ptr unsafe.Pointer, off, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typedmemclrpartial(t *rtype, ptr unsafe.Pointer, off, size uintptr)\n```\n\ntypedmemclrpartial is like typedmemclr but assumes that dst points off bytes into the value and only clears size bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typedslicecopy",
              "documentation": {
                "identifier": "typedslicecopy",
                "newPage": false,
                "searchKey": "reflect.typedslicecopy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typedslicecopy(elemType *rtype, dst, src unsafeheader.Slice) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typedslicecopy(elemType *rtype, dst, src unsafeheader.Slice) int\n```\n\ntypedslicecopy copies a slice of elemType values from src to dst, returning the number of elements copied. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#typehash",
              "documentation": {
                "identifier": "typehash",
                "newPage": false,
                "searchKey": "reflect.typehash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typehash(t *rtype, p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typehash(t *rtype, p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#escapes",
              "documentation": {
                "identifier": "escapes",
                "newPage": false,
                "searchKey": "reflect.escapes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func escapes(x interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc escapes(x interface{})\n```\n\nDummy annotation marking that the value x escapes, for use in cases where the reflect code is so clever that the compiler cannot follow. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#VisibleFields",
              "documentation": {
                "identifier": "VisibleFields",
                "newPage": false,
                "searchKey": "reflect.VisibleFields",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func VisibleFields(t Type) []StructField"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc VisibleFields(t Type) []StructField\n```\n\nVisibleFields returns all the visible fields in t, which must be a struct type. A field is defined as visible if it's accessible directly with a FieldByName call. The returned fields include fields inside anonymous struct members and unexported fields. They follow the same order found in the struct, with anonymous fields followed immediately by their promoted fields. \n\nFor each element e of the returned slice, the corresponding field can be retrieved from a value v of type t by calling v.FieldByIndex(e.Index). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#IsRO",
              "documentation": {
                "identifier": "IsRO",
                "newPage": false,
                "searchKey": "reflect.IsRO",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsRO(v Value) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsRO(v Value) bool\n```\n\nIsRO reports whether v's read-only flag is set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#TypeLinks",
              "documentation": {
                "identifier": "TypeLinks",
                "newPage": false,
                "searchKey": "reflect.TypeLinks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TypeLinks() []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TypeLinks() []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#gcbits",
              "documentation": {
                "identifier": "gcbits",
                "newPage": false,
                "searchKey": "reflect.gcbits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcbits(interface{}) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcbits(interface{}) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#FirstMethodNameBytes",
              "documentation": {
                "identifier": "FirstMethodNameBytes",
                "newPage": false,
                "searchKey": "reflect.FirstMethodNameBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func FirstMethodNameBytes(t Type) *byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc FirstMethodNameBytes(t Type) *byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#IsExported",
              "documentation": {
                "identifier": "IsExported",
                "newPage": false,
                "searchKey": "reflect.IsExported",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsExported(t Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsExported(t Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#ResolveReflectName",
              "documentation": {
                "identifier": "ResolveReflectName",
                "newPage": false,
                "searchKey": "reflect.ResolveReflectName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ResolveReflectName(s string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ResolveReflectName(s string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#clearLayoutCache",
              "documentation": {
                "identifier": "clearLayoutCache",
                "newPage": false,
                "searchKey": "reflect.clearLayoutCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func clearLayoutCache()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc clearLayoutCache()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/reflect#SetArgRegs",
              "documentation": {
                "identifier": "SetArgRegs",
                "newPage": false,
                "searchKey": "reflect.SetArgRegs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetArgRegs(ints, floats int, floatSize uintptr) (oldInts, oldFloats int, oldFloatSize uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetArgRegs(ints, floats int, floatSize uintptr) (oldInts, oldFloats int, oldFloatSize uintptr)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
