{
  "pathID": "/std/text/template",
  "documentation": {
    "identifier": "template",
    "newPage": true,
    "searchKey": "std/text/template",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package template"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package template implements data-driven templates for generating textual output. \n\nTo generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks. \n\nTemplates are executed by applying them to a data structure. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. Execution of the template walks the structure and sets the cursor, represented by a period '.' and called \"dot\", to the value at the current location in the structure as execution proceeds. \n\nThe input text for a template is UTF-8-encoded text in any format. \"Actions\"--data evaluations or control structures--are delimited by \"{{\" and \"}}\"; all text outside actions is copied to the output unchanged. Except for raw strings, actions may not span newlines, although comments can. \n\nOnce parsed, a template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. \n\nHere is a trivial example that prints \"17 items are made of wool\". \n\n```\ntype Inventory struct {\n\tMaterial string\n\tCount    uint\n}\nsweaters := Inventory{\"wool\", 17}\ntmpl, err := template.New(\"test\").Parse(\"{{.Count}} items are made of {{.Material}}\")\nif err != nil { panic(err) }\nerr = tmpl.Execute(os.Stdout, sweaters)\nif err != nil { panic(err) }\n\n```\nMore intricate examples appear below. \n\n### hdr-Text_and_spacesText and spaces\nBy default, all text between actions is copied verbatim when the template is executed. For example, the string \" items are made of \" in the example above appears on standard output when the program is run. \n\nHowever, to aid in formatting template source code, if an action's left delimiter (by default \"{{\") is followed immediately by a minus sign and white space, all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (\"}}\") is preceded by white space and a minus sign, all leading white space is trimmed from the immediately following text. In these trim markers, the white space must be present: \"{{- 3}}\" is like \"{{3}}\" but trims the immediately preceding text, while \"{{-3}}\" parses as an action containing the number -3. \n\nFor instance, when executing the template whose source is \n\n```\n\"{{23 -}} < {{- 45}}\"\n\n```\nthe generated output would be \n\n```\n\"23<45\"\n\n```\nFor this trimming, the definition of white space characters is the same as in Go: space, horizontal tab, carriage return, and newline. \n\n### hdr-ActionsActions\nHere is the list of actions. \"Arguments\" and \"pipelines\" are evaluations of data, defined in detail in the corresponding sections that follow. \n\n```\n{{/* a comment */}}\n{{- /* a comment with white space trimmed from preceding and following text */ -}}\n\tA comment; discarded. May contain newlines.\n\tComments do not nest and must start and end at the\n\tdelimiters, as shown here.\n\n{{pipeline}}\n\tThe default textual representation (the same as would be\n\tprinted by fmt.Print) of the value of the pipeline is copied\n\tto the output.\n\n{{if pipeline}} T1 {{end}}\n\tIf the value of the pipeline is empty, no output is generated;\n\totherwise, T1 is executed. The empty values are false, 0, any\n\tnil pointer or interface value, and any array, slice, map, or\n\tstring of length zero.\n\tDot is unaffected.\n\n{{if pipeline}} T1 {{else}} T0 {{end}}\n\tIf the value of the pipeline is empty, T0 is executed;\n\totherwise, T1 is executed. Dot is unaffected.\n\n{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}\n\tTo simplify the appearance of if-else chains, the else action\n\tof an if may include another if directly; the effect is exactly\n\tthe same as writing\n\t\t{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}\n\n{{range pipeline}} T1 {{end}}\n\tThe value of the pipeline must be an array, slice, map, or channel.\n\tIf the value of the pipeline has length zero, nothing is output;\n\totherwise, dot is set to the successive elements of the array,\n\tslice, or map and T1 is executed. If the value is a map and the\n\tkeys are of basic type with a defined order, the elements will be\n\tvisited in sorted key order.\n\n{{range pipeline}} T1 {{else}} T0 {{end}}\n\tThe value of the pipeline must be an array, slice, map, or channel.\n\tIf the value of the pipeline has length zero, dot is unaffected and\n\tT0 is executed; otherwise, dot is set to the successive elements\n\tof the array, slice, or map and T1 is executed.\n\n{{template \"name\"}}\n\tThe template with the specified name is executed with nil data.\n\n{{template \"name\" pipeline}}\n\tThe template with the specified name is executed with dot set\n\tto the value of the pipeline.\n\n{{block \"name\" pipeline}} T1 {{end}}\n\tA block is shorthand for defining a template\n\t\t{{define \"name\"}} T1 {{end}}\n\tand then executing it in place\n\t\t{{template \"name\" pipeline}}\n\tThe typical use is to define a set of root templates that are\n\tthen customized by redefining the block templates within.\n\n{{with pipeline}} T1 {{end}}\n\tIf the value of the pipeline is empty, no output is generated;\n\totherwise, dot is set to the value of the pipeline and T1 is\n\texecuted.\n\n{{with pipeline}} T1 {{else}} T0 {{end}}\n\tIf the value of the pipeline is empty, dot is unaffected and T0\n\tis executed; otherwise, dot is set to the value of the pipeline\n\tand T1 is executed.\n\n```\n### hdr-ArgumentsArguments\nAn argument is a simple value, denoted by one of the following. \n\n```\n- A boolean, string, character, integer, floating-point, imaginary\n  or complex constant in Go syntax. These behave like Go's untyped\n  constants. Note that, as in Go, whether a large integer constant\n  overflows when assigned or passed to a function can depend on whether\n  the host machine's ints are 32 or 64 bits.\n- The keyword nil, representing an untyped Go nil.\n- The character '.' (period):\n\t.\n  The result is the value of dot.\n- A variable name, which is a (possibly empty) alphanumeric string\n  preceded by a dollar sign, such as\n\t$piOver2\n  or\n\t$\n  The result is the value of the variable.\n  Variables are described below.\n- The name of a field of the data, which must be a struct, preceded\n  by a period, such as\n\t.Field\n  The result is the value of the field. Field invocations may be\n  chained:\n    .Field1.Field2\n  Fields can also be evaluated on variables, including chaining:\n    $x.Field1.Field2\n- The name of a key of the data, which must be a map, preceded\n  by a period, such as\n\t.Key\n  The result is the map element value indexed by the key.\n  Key invocations may be chained and combined with fields to any\n  depth:\n    .Field1.Key1.Field2.Key2\n  Although the key must be an alphanumeric identifier, unlike with\n  field names they do not need to start with an upper case letter.\n  Keys can also be evaluated on variables, including chaining:\n    $x.key1.key2\n- The name of a niladic method of the data, preceded by a period,\n  such as\n\t.Method\n  The result is the value of invoking the method with dot as the\n  receiver, dot.Method(). Such a method must have one return value (of\n  any type) or two return values, the second of which is an error.\n  If it has two and the returned error is non-nil, execution terminates\n  and an error is returned to the caller as the value of Execute.\n  Method invocations may be chained and combined with fields and keys\n  to any depth:\n    .Field1.Key1.Method1.Field2.Key2.Method2\n  Methods can also be evaluated on variables, including chaining:\n    $x.Method1.Field\n- The name of a niladic function, such as\n\tfun\n  The result is the value of invoking the function, fun(). The return\n  types and values behave as in methods. Functions and function\n  names are described below.\n- A parenthesized instance of one the above, for grouping. The result\n  may be accessed by a field or map key invocation.\n\tprint (.F1 arg1) (.F2 arg2)\n\t(.StructValuedMethod \"arg\").Field\n\n```\nArguments may evaluate to any type; if they are pointers the implementation automatically indirects to the base type when required. If an evaluation yields a function value, such as a function-valued field of a struct, the function is not invoked automatically, but it can be used as a truth value for an if action and the like. To invoke it, use the call function, defined below. \n\n### hdr-PipelinesPipelines\nA pipeline is a possibly chained sequence of \"commands\". A command is a simple value (argument) or a function or method call, possibly with multiple arguments: \n\n```\nArgument\n\tThe result is the value of evaluating the argument.\n.Method [Argument...]\n\tThe method can be alone or the last element of a chain but,\n\tunlike methods in the middle of a chain, it can take arguments.\n\tThe result is the value of calling the method with the\n\targuments:\n\t\tdot.Method(Argument1, etc.)\nfunctionName [Argument...]\n\tThe result is the value of calling the function associated\n\twith the name:\n\t\tfunction(Argument1, etc.)\n\tFunctions and function names are described below.\n\n```\nA pipeline may be \"chained\" by separating a sequence of commands with pipeline characters '|'. In a chained pipeline, the result of each command is passed as the last argument of the following command. The output of the final command in the pipeline is the value of the pipeline. \n\nThe output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute. \n\n### hdr-VariablesVariables\nA pipeline inside an action may initialize a variable to capture the result. The initialization has syntax \n\n```\n$variable := pipeline\n\n```\nwhere $variable is the name of the variable. An action that declares a variable produces no output. \n\nVariables previously declared can also be assigned, using the syntax \n\n```\n$variable = pipeline\n\n```\nIf a \"range\" action initializes a variable, the variable is set to the successive elements of the iteration. Also, a \"range\" may declare two variables, separated by a comma: \n\n```\nrange $index, $element := pipeline\n\n```\nin which case $index and $element are set to the successive values of the array/slice index or map key and element, respectively. Note that if there is only one variable, it is assigned the element; this is opposite to the convention in Go range clauses. \n\nA variable's scope extends to the \"end\" action of the control structure (\"if\", \"with\", or \"range\") in which it is declared, or to the end of the template if there is no such control structure. A template invocation does not inherit variables from the point of its invocation. \n\nWhen execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot. \n\n### hdr-ExamplesExamples\nHere are some example one-line templates demonstrating pipelines and variables. All produce the quoted word \"output\": \n\n```\n{{\"\\\"output\\\"\"}}\n\tA string constant.\n{{`\"output\"`}}\n\tA raw string constant.\n{{printf \"%q\" \"output\"}}\n\tA function call.\n{{\"output\" | printf \"%q\"}}\n\tA function call whose final argument comes from the previous\n\tcommand.\n{{printf \"%q\" (print \"out\" \"put\")}}\n\tA parenthesized argument.\n{{\"put\" | printf \"%s%s\" \"out\" | printf \"%q\"}}\n\tA more elaborate call.\n{{\"output\" | printf \"%s\" | printf \"%q\"}}\n\tA longer chain.\n{{with \"output\"}}{{printf \"%q\" .}}{{end}}\n\tA with action using dot.\n{{with $x := \"output\" | printf \"%q\"}}{{$x}}{{end}}\n\tA with action that creates and uses a variable.\n{{with $x := \"output\"}}{{printf \"%q\" $x}}{{end}}\n\tA with action that uses the variable in another action.\n{{with $x := \"output\"}}{{$x | printf \"%q\"}}{{end}}\n\tThe same, but pipelined.\n\n```\n### hdr-FunctionsFunctions\nDuring execution functions are found in two function maps: first in the template, then in the global function map. By default, no functions are defined in the template but the Funcs method can be used to add them. \n\nPredefined global functions are named as follows. \n\n```\nand\n\tReturns the boolean AND of its arguments by returning the\n\tfirst empty argument or the last argument, that is,\n\t\"and x y\" behaves as \"if x then y else x\". All the\n\targuments are evaluated.\ncall\n\tReturns the result of calling the first argument, which\n\tmust be a function, with the remaining arguments as parameters.\n\tThus \"call .X.Y 1 2\" is, in Go notation, dot.X.Y(1, 2) where\n\tY is a func-valued field, map entry, or the like.\n\tThe first argument must be the result of an evaluation\n\tthat yields a value of function type (as distinct from\n\ta predefined function such as print). The function must\n\treturn either one or two result values, the second of which\n\tis of type error. If the arguments don't match the function\n\tor the returned error value is non-nil, execution stops.\nhtml\n\tReturns the escaped HTML equivalent of the textual\n\trepresentation of its arguments. This function is unavailable\n\tin html/template, with a few exceptions.\nindex\n\tReturns the result of indexing its first argument by the\n\tfollowing arguments. Thus \"index x 1 2 3\" is, in Go syntax,\n\tx[1][2][3]. Each indexed item must be a map, slice, or array.\nslice\n\tslice returns the result of slicing its first argument by the\n\tremaining arguments. Thus \"slice x 1 2\" is, in Go syntax, x[1:2],\n\twhile \"slice x\" is x[:], \"slice x 1\" is x[1:], and \"slice x 1 2 3\"\n\tis x[1:2:3]. The first argument must be a string, slice, or array.\njs\n\tReturns the escaped JavaScript equivalent of the textual\n\trepresentation of its arguments.\nlen\n\tReturns the integer length of its argument.\nnot\n\tReturns the boolean negation of its single argument.\nor\n\tReturns the boolean OR of its arguments by returning the\n\tfirst non-empty argument or the last argument, that is,\n\t\"or x y\" behaves as \"if x then x else y\". All the\n\targuments are evaluated.\nprint\n\tAn alias for fmt.Sprint\nprintf\n\tAn alias for fmt.Sprintf\nprintln\n\tAn alias for fmt.Sprintln\nurlquery\n\tReturns the escaped value of the textual representation of\n\tits arguments in a form suitable for embedding in a URL query.\n\tThis function is unavailable in html/template, with a few\n\texceptions.\n\n```\nThe boolean functions take any zero value to be false and a non-zero value to be true. \n\nThere is also a set of binary comparison operators defined as functions: \n\n```\neq\n\tReturns the boolean truth of arg1 == arg2\nne\n\tReturns the boolean truth of arg1 != arg2\nlt\n\tReturns the boolean truth of arg1 < arg2\nle\n\tReturns the boolean truth of arg1 <= arg2\ngt\n\tReturns the boolean truth of arg1 > arg2\nge\n\tReturns the boolean truth of arg1 >= arg2\n\n```\nFor simpler multi-way equality tests, eq (only) accepts two or more arguments and compares the second and subsequent to the first, returning in effect \n\n```\narg1==arg2 || arg1==arg3 || arg1==arg4 ...\n\n```\n(Unlike with || in Go, however, eq is a function call and all the arguments will be evaluated.) \n\nThe comparison functions work on any values whose type Go defines as comparable. For basic types such as integers, the rules are relaxed: size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on. \n\n### hdr-Associated_templatesAssociated templates\nEach template is named by a string specified when it is created. Also, each template is associated with zero or more other templates that it may invoke by name; such associations are transitive and form a name space of templates. \n\nA template may use a template invocation to instantiate another associated template; see the explanation of the \"template\" action above. The name must be that of a template associated with the template that contains the invocation. \n\n### hdr-Nested_template_definitionsNested template definitions\nWhen parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program. \n\nThe syntax of such definitions is to surround each template declaration with a \"define\" and \"end\" action. \n\nThe define action names the template being created by providing a string constant. Here is a simple example: \n\n```\n`{{define \"T1\"}}ONE{{end}}\n{{define \"T2\"}}TWO{{end}}\n{{define \"T3\"}}{{template \"T1\"}} {{template \"T2\"}}{{end}}\n{{template \"T3\"}}`\n\n```\nThis defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text \n\n```\nONE TWO\n\n```\nBy construction, a template may reside in only one association. If it's necessary to have a template addressable from multiple associations, the template definition must be parsed multiple times to create distinct *Template values, or must be copied with the Clone or AddParseTree method. \n\nParse may be called multiple times to assemble the various associated templates; see the ParseFiles and ParseGlob functions and methods for simple ways to parse related templates stored in files. \n\nA template may be executed directly or through ExecuteTemplate, which executes an associated template identified by name. To invoke our example above, we might write, \n\n```\nerr := tmpl.Execute(os.Stdout, \"no data needed\")\nif err != nil {\n\tlog.Fatalf(\"execution failed: %s\", err)\n}\n\n```\nor to invoke a particular template explicitly by name, \n\n```\nerr := tmpl.ExecuteTemplate(os.Stdout, \"T2\", \"no data needed\")\nif err != nil {\n\tlog.Fatalf(\"execution failed: %s\", err)\n}\n\n```\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/std/text/template#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/text/template#invalidKind",
              "documentation": {
                "identifier": "invalidKind",
                "newPage": false,
                "searchKey": "template.invalidKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const invalidKind"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst invalidKind kind = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#boolKind",
              "documentation": {
                "identifier": "boolKind",
                "newPage": false,
                "searchKey": "template.boolKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boolKind"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boolKind\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#complexKind",
              "documentation": {
                "identifier": "complexKind",
                "newPage": false,
                "searchKey": "template.complexKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const complexKind"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst complexKind\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#intKind",
              "documentation": {
                "identifier": "intKind",
                "newPage": false,
                "searchKey": "template.intKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const intKind"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst intKind\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#floatKind",
              "documentation": {
                "identifier": "floatKind",
                "newPage": false,
                "searchKey": "template.floatKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const floatKind"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst floatKind\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#stringKind",
              "documentation": {
                "identifier": "stringKind",
                "newPage": false,
                "searchKey": "template.stringKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stringKind"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stringKind\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#uintKind",
              "documentation": {
                "identifier": "uintKind",
                "newPage": false,
                "searchKey": "template.uintKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const uintKind"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst uintKind\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#mapInvalid",
              "documentation": {
                "identifier": "mapInvalid",
                "newPage": false,
                "searchKey": "template.mapInvalid",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mapInvalid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mapInvalid missingKeyAction = iota // Return an invalid reflect.Value.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#mapZeroValue",
              "documentation": {
                "identifier": "mapZeroValue",
                "newPage": false,
                "searchKey": "template.mapZeroValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mapZeroValue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mapZeroValue // Return the zero value for the map element.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#mapError",
              "documentation": {
                "identifier": "mapError",
                "newPage": false,
                "searchKey": "template.mapError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mapError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mapError // Error out\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#execErrorText",
              "documentation": {
                "identifier": "execErrorText",
                "newPage": false,
                "searchKey": "template.execErrorText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const execErrorText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst execErrorText = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#treeTemplate",
              "documentation": {
                "identifier": "treeTemplate",
                "newPage": false,
                "searchKey": "template.treeTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const treeTemplate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst treeTemplate = ...\n```\n\nUse different delimiters to test Set.Delims. Also test the trimming of leading and trailing spaces. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#testTemplates",
              "documentation": {
                "identifier": "testTemplates",
                "newPage": false,
                "searchKey": "template.testTemplates",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const testTemplates"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst testTemplates = `{{define \"one\"}}one{{end}}{{define \"two\"}}two{{end}}`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#alwaysErrorText",
              "documentation": {
                "identifier": "alwaysErrorText",
                "newPage": false,
                "searchKey": "template.alwaysErrorText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alwaysErrorText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alwaysErrorText = \"always be failing\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#noError",
              "documentation": {
                "identifier": "noError",
                "newPage": false,
                "searchKey": "template.noError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const noError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst noError = true\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#hasError",
              "documentation": {
                "identifier": "hasError",
                "newPage": false,
                "searchKey": "template.hasError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hasError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hasError = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#multiText1",
              "documentation": {
                "identifier": "multiText1",
                "newPage": false,
                "searchKey": "template.multiText1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const multiText1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst multiText1 = `\n\t{{define \"x\"}}TEXT{{end}}\n\t{{define \"dotV\"}}{{.V}}{{end}}\n`\n```\n\nThese strings are also in testdata/*. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#multiText2",
              "documentation": {
                "identifier": "multiText2",
                "newPage": false,
                "searchKey": "template.multiText2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const multiText2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst multiText2 = `\n\t{{define \"dot\"}}{{.}}{{end}}\n\t{{define \"nested\"}}{{template \"dot\" .}}{{end}}\n`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#cloneText1",
              "documentation": {
                "identifier": "cloneText1",
                "newPage": false,
                "searchKey": "template.cloneText1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cloneText1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cloneText1 = `{{define \"a\"}}{{template \"b\"}}{{template \"c\"}}{{end}}`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#cloneText2",
              "documentation": {
                "identifier": "cloneText2",
                "newPage": false,
                "searchKey": "template.cloneText2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cloneText2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cloneText2 = `{{define \"b\"}}b{{end}}`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#cloneText3",
              "documentation": {
                "identifier": "cloneText3",
                "newPage": false,
                "searchKey": "template.cloneText3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cloneText3"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cloneText3 = `{{define \"c\"}}root{{end}}`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#cloneText4",
              "documentation": {
                "identifier": "cloneText4",
                "newPage": false,
                "searchKey": "template.cloneText4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cloneText4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cloneText4 = `{{define \"c\"}}clone{{end}}`\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/text/template#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/text/template#maxExecDepth",
              "documentation": {
                "identifier": "maxExecDepth",
                "newPage": false,
                "searchKey": "template.maxExecDepth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var maxExecDepth"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar maxExecDepth = initMaxExecDepth()\n```\n\nmaxExecDepth specifies the maximum stack depth of templates within templates. This limit is only practically reached by accidentally recursive template invocations. This limit allows us to return an error instead of triggering a stack overflow. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#zero",
              "documentation": {
                "identifier": "zero",
                "newPage": false,
                "searchKey": "template.zero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var zero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zero reflect.Value\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#missingVal",
              "documentation": {
                "identifier": "missingVal",
                "newPage": false,
                "searchKey": "template.missingVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var missingVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar missingVal = reflect.ValueOf(missingValType{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#errorType",
              "documentation": {
                "identifier": "errorType",
                "newPage": false,
                "searchKey": "template.errorType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errorType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errorType = reflect.TypeOf((*error)(nil)).Elem()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#fmtStringerType",
              "documentation": {
                "identifier": "fmtStringerType",
                "newPage": false,
                "searchKey": "template.fmtStringerType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fmtStringerType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fmtStringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#reflectValueType",
              "documentation": {
                "identifier": "reflectValueType",
                "newPage": false,
                "searchKey": "template.reflectValueType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var reflectValueType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar reflectValueType = reflect.TypeOf((*reflect.Value)(nil)).Elem()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#builtinFuncsOnce",
              "documentation": {
                "identifier": "builtinFuncsOnce",
                "newPage": false,
                "searchKey": "template.builtinFuncsOnce",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var builtinFuncsOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar builtinFuncsOnce struct {\n\tsync.Once\n\tv map[string]reflect.Value\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#errBadComparisonType",
              "documentation": {
                "identifier": "errBadComparisonType",
                "newPage": false,
                "searchKey": "template.errBadComparisonType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errBadComparisonType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errBadComparisonType = errors.New(\"invalid type for comparison\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#errBadComparison",
              "documentation": {
                "identifier": "errBadComparison",
                "newPage": false,
                "searchKey": "template.errBadComparison",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errBadComparison"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errBadComparison = errors.New(\"incompatible types for comparison\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#errNoComparison",
              "documentation": {
                "identifier": "errNoComparison",
                "newPage": false,
                "searchKey": "template.errNoComparison",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNoComparison"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNoComparison = errors.New(\"missing argument for comparison\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#htmlQuot",
              "documentation": {
                "identifier": "htmlQuot",
                "newPage": false,
                "searchKey": "template.htmlQuot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlQuot"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlQuot = []byte(\"&#34;\") // shorter than \"&quot;\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#htmlApos",
              "documentation": {
                "identifier": "htmlApos",
                "newPage": false,
                "searchKey": "template.htmlApos",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlApos"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlApos = []byte(\"&#39;\") // shorter than \"&apos;\" and apos was not in HTML until HTML5\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#htmlAmp",
              "documentation": {
                "identifier": "htmlAmp",
                "newPage": false,
                "searchKey": "template.htmlAmp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlAmp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlAmp = []byte(\"&amp;\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#htmlLt",
              "documentation": {
                "identifier": "htmlLt",
                "newPage": false,
                "searchKey": "template.htmlLt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlLt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlLt = []byte(\"&lt;\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#htmlGt",
              "documentation": {
                "identifier": "htmlGt",
                "newPage": false,
                "searchKey": "template.htmlGt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlGt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlGt = []byte(\"&gt;\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#htmlNull",
              "documentation": {
                "identifier": "htmlNull",
                "newPage": false,
                "searchKey": "template.htmlNull",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlNull"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlNull = []byte(\"\\uFFFD\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#jsLowUni",
              "documentation": {
                "identifier": "jsLowUni",
                "newPage": false,
                "searchKey": "template.jsLowUni",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsLowUni"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsLowUni = []byte(`\\u00`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#hex",
              "documentation": {
                "identifier": "hex",
                "newPage": false,
                "searchKey": "template.hex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var hex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hex = []byte(\"0123456789ABCDEF\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#jsBackslash",
              "documentation": {
                "identifier": "jsBackslash",
                "newPage": false,
                "searchKey": "template.jsBackslash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsBackslash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsBackslash = []byte(`\\\\`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#jsApos",
              "documentation": {
                "identifier": "jsApos",
                "newPage": false,
                "searchKey": "template.jsApos",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsApos"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsApos = []byte(`\\'`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#jsQuot",
              "documentation": {
                "identifier": "jsQuot",
                "newPage": false,
                "searchKey": "template.jsQuot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsQuot"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsQuot = []byte(`\\\"`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#jsLt",
              "documentation": {
                "identifier": "jsLt",
                "newPage": false,
                "searchKey": "template.jsLt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsLt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsLt = []byte(`\\u003C`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#jsGt",
              "documentation": {
                "identifier": "jsGt",
                "newPage": false,
                "searchKey": "template.jsGt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsGt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsGt = []byte(`\\u003E`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#jsAmp",
              "documentation": {
                "identifier": "jsAmp",
                "newPage": false,
                "searchKey": "template.jsAmp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsAmp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsAmp = []byte(`\\u0026`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#jsEq",
              "documentation": {
                "identifier": "jsEq",
                "newPage": false,
                "searchKey": "template.jsEq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsEq"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsEq = []byte(`\\u003D`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#debug",
              "documentation": {
                "identifier": "debug",
                "newPage": false,
                "searchKey": "template.debug",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var debug"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar debug = flag.Bool(\"debug\", false, \"show the errors produced by the tests\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#siVal",
              "documentation": {
                "identifier": "siVal",
                "newPage": false,
                "searchKey": "template.siVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var siVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar siVal = I(S{\"a\", \"b\"})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#tVal",
              "documentation": {
                "identifier": "tVal",
                "newPage": false,
                "searchKey": "template.tVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tVal = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#tSliceOfNil",
              "documentation": {
                "identifier": "tSliceOfNil",
                "newPage": false,
                "searchKey": "template.tSliceOfNil",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tSliceOfNil"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tSliceOfNil = []*T{nil}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#iVal",
              "documentation": {
                "identifier": "iVal",
                "newPage": false,
                "searchKey": "template.iVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var iVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar iVal I = tVal\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#myError",
              "documentation": {
                "identifier": "myError",
                "newPage": false,
                "searchKey": "template.myError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var myError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar myError = errors.New(\"my error\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#bigInt",
              "documentation": {
                "identifier": "bigInt",
                "newPage": false,
                "searchKey": "template.bigInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bigInt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bigInt = fmt.Sprintf(\"0x%x\", int(1<<uint(reflect.TypeOf(0).Bits()-1)-1))\n```\n\nbigInt and bigUint are hex string representing numbers either side of the max int boundary. We do it this way so the test doesn't depend on ints being 32 bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#bigUint",
              "documentation": {
                "identifier": "bigUint",
                "newPage": false,
                "searchKey": "template.bigUint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bigUint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bigUint = fmt.Sprintf(\"0x%x\", uint(1<<uint(reflect.TypeOf(0).Bits()-1)))\n```\n\nbigInt and bigUint are hex string representing numbers either side of the max int boundary. We do it this way so the test doesn't depend on ints being 32 bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#execTests",
              "documentation": {
                "identifier": "execTests",
                "newPage": false,
                "searchKey": "template.execTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var execTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar execTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#delimPairs",
              "documentation": {
                "identifier": "delimPairs",
                "newPage": false,
                "searchKey": "template.delimPairs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var delimPairs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar delimPairs = []string{\n\t\"\", \"\",\n\t\"{{\", \"}}\",\n\t\"<<\", \">>\",\n\t\"|\", \"|\",\n\t\"(日)\", \"(本)\",\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#cmpTests",
              "documentation": {
                "identifier": "cmpTests",
                "newPage": false,
                "searchKey": "template.cmpTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cmpTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cmpTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#alwaysError",
              "documentation": {
                "identifier": "alwaysError",
                "newPage": false,
                "searchKey": "template.alwaysError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var alwaysError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar alwaysError = errors.New(alwaysErrorText)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#multiParseTests",
              "documentation": {
                "identifier": "multiParseTests",
                "newPage": false,
                "searchKey": "template.multiParseTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var multiParseTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar multiParseTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#multiExecTests",
              "documentation": {
                "identifier": "multiExecTests",
                "newPage": false,
                "searchKey": "template.multiExecTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var multiExecTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar multiExecTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#templateFileExecTests",
              "documentation": {
                "identifier": "templateFileExecTests",
                "newPage": false,
                "searchKey": "template.templateFileExecTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var templateFileExecTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar templateFileExecTests = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/text/template#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/text/template#state",
              "documentation": {
                "identifier": "state",
                "newPage": false,
                "searchKey": "template.state",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type state struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype state struct {\n\ttmpl  *Template\n\twr    io.Writer\n\tnode  parse.Node // current node, for errors\n\tvars  []variable // push-down stack of variable values.\n\tdepth int        // the height of the stack of executing templates.\n}\n```\n\nstate represents the state of an execution. It's not part of the template so that multiple executions of the same template can execute in parallel. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#state.push",
                    "documentation": {
                      "identifier": "state.push",
                      "newPage": false,
                      "searchKey": "template.state.push",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) push(name string, value reflect.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) push(name string, value reflect.Value)\n```\n\npush pushes a new variable on the stack. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.mark",
                    "documentation": {
                      "identifier": "state.mark",
                      "newPage": false,
                      "searchKey": "template.state.mark",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) mark() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) mark() int\n```\n\nmark returns the length of the variable stack. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.pop",
                    "documentation": {
                      "identifier": "state.pop",
                      "newPage": false,
                      "searchKey": "template.state.pop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) pop(mark int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) pop(mark int)\n```\n\npop pops the variable stack up to the mark. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.setVar",
                    "documentation": {
                      "identifier": "state.setVar",
                      "newPage": false,
                      "searchKey": "template.state.setVar",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) setVar(name string, value reflect.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) setVar(name string, value reflect.Value)\n```\n\nsetVar overwrites the last declared variable with the given name. Used by variable assignments. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.setTopVar",
                    "documentation": {
                      "identifier": "state.setTopVar",
                      "newPage": false,
                      "searchKey": "template.state.setTopVar",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) setTopVar(n int, value reflect.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) setTopVar(n int, value reflect.Value)\n```\n\nsetTopVar overwrites the top-nth variable on the stack. Used by range iterations. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.varValue",
                    "documentation": {
                      "identifier": "state.varValue",
                      "newPage": false,
                      "searchKey": "template.state.varValue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) varValue(name string) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) varValue(name string) reflect.Value\n```\n\nvarValue returns the value of the named variable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.at",
                    "documentation": {
                      "identifier": "state.at",
                      "newPage": false,
                      "searchKey": "template.state.at",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) at(node parse.Node)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) at(node parse.Node)\n```\n\nat marks the state to be on node n, for error reporting. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.errorf",
                    "documentation": {
                      "identifier": "state.errorf",
                      "newPage": false,
                      "searchKey": "template.state.errorf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) errorf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) errorf(format string, args ...interface{})\n```\n\nerrorf records an ExecError and terminates processing. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.writeError",
                    "documentation": {
                      "identifier": "state.writeError",
                      "newPage": false,
                      "searchKey": "template.state.writeError",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) writeError(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) writeError(err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.walk",
                    "documentation": {
                      "identifier": "state.walk",
                      "newPage": false,
                      "searchKey": "template.state.walk",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) walk(dot reflect.Value, node parse.Node)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) walk(dot reflect.Value, node parse.Node)\n```\n\nWalk functions step through the major pieces of the template structure, generating output as they go. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.walkIfOrWith",
                    "documentation": {
                      "identifier": "state.walkIfOrWith",
                      "newPage": false,
                      "searchKey": "template.state.walkIfOrWith",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list, elseList *parse.ListNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list, elseList *parse.ListNode)\n```\n\nwalkIfOrWith walks an 'if' or 'with' node. The two control structures are identical in behavior except that 'with' sets dot. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.walkRange",
                    "documentation": {
                      "identifier": "state.walkRange",
                      "newPage": false,
                      "searchKey": "template.state.walkRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) walkRange(dot reflect.Value, r *parse.RangeNode)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.walkTemplate",
                    "documentation": {
                      "identifier": "state.walkTemplate",
                      "newPage": false,
                      "searchKey": "template.state.walkTemplate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalPipeline",
                    "documentation": {
                      "identifier": "state.evalPipeline",
                      "newPage": false,
                      "searchKey": "template.state.evalPipeline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalPipeline(dot reflect.Value, pipe *parse.PipeNode) (value reflect.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalPipeline(dot reflect.Value, pipe *parse.PipeNode) (value reflect.Value)\n```\n\nevalPipeline returns the value acquired by evaluating a pipeline. If the pipeline has a variable declaration, the variable will be pushed on the stack. Callers should therefore pop the stack after they are finished executing commands depending on the pipeline value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.notAFunction",
                    "documentation": {
                      "identifier": "state.notAFunction",
                      "newPage": false,
                      "searchKey": "template.state.notAFunction",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) notAFunction(args []parse.Node, final reflect.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) notAFunction(args []parse.Node, final reflect.Value)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalCommand",
                    "documentation": {
                      "identifier": "state.evalCommand",
                      "newPage": false,
                      "searchKey": "template.state.evalCommand",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalCommand(dot reflect.Value, cmd *parse.CommandNode, final reflect.Value) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalCommand(dot reflect.Value, cmd *parse.CommandNode, final reflect.Value) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.idealConstant",
                    "documentation": {
                      "identifier": "state.idealConstant",
                      "newPage": false,
                      "searchKey": "template.state.idealConstant",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) idealConstant(constant *parse.NumberNode) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) idealConstant(constant *parse.NumberNode) reflect.Value\n```\n\nidealConstant is called to return the value of a number in a context where we don't know the type. In that case, the syntax of the number tells us its type, and we use Go rules to resolve. Note there is no such thing as a uint ideal constant in this situation - the value must be of int type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalFieldNode",
                    "documentation": {
                      "identifier": "state.evalFieldNode",
                      "newPage": false,
                      "searchKey": "template.state.evalFieldNode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalFieldNode(dot reflect.Value, field *parse.FieldNode, args []parse.Node, final reflect.Value) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalFieldNode(dot reflect.Value, field *parse.FieldNode, args []parse.Node, final reflect.Value) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalChainNode",
                    "documentation": {
                      "identifier": "state.evalChainNode",
                      "newPage": false,
                      "searchKey": "template.state.evalChainNode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalChainNode(dot reflect.Value, chain *parse.ChainNode, args []parse.Node, final reflect.Value) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalChainNode(dot reflect.Value, chain *parse.ChainNode, args []parse.Node, final reflect.Value) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalVariableNode",
                    "documentation": {
                      "identifier": "state.evalVariableNode",
                      "newPage": false,
                      "searchKey": "template.state.evalVariableNode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalVariableNode(dot reflect.Value, variable *parse.VariableNode, args []parse.Node, final reflect.Value) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalVariableNode(dot reflect.Value, variable *parse.VariableNode, args []parse.Node, final reflect.Value) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalFieldChain",
                    "documentation": {
                      "identifier": "state.evalFieldChain",
                      "newPage": false,
                      "searchKey": "template.state.evalFieldChain",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalFieldChain(dot, receiver reflect.Value, node parse.Node, ident []string, args []parse.Node, final reflect.Value) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalFieldChain(dot, receiver reflect.Value, node parse.Node, ident []string, args []parse.Node, final reflect.Value) reflect.Value\n```\n\nevalFieldChain evaluates .X.Y.Z possibly followed by arguments. dot is the environment in which to evaluate arguments, while receiver is the value being walked along the chain. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalFunction",
                    "documentation": {
                      "identifier": "state.evalFunction",
                      "newPage": false,
                      "searchKey": "template.state.evalFunction",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalFunction(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalFunction(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalField",
                    "documentation": {
                      "identifier": "state.evalField",
                      "newPage": false,
                      "searchKey": "template.state.evalField",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalField(dot reflect.Value, fieldName string, node parse.Node, args []parse.Node, final, receiver reflect.Value) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalField(dot reflect.Value, fieldName string, node parse.Node, args []parse.Node, final, receiver reflect.Value) reflect.Value\n```\n\nevalField evaluates an expression like (.Field) or (.Field arg1 arg2). The 'final' argument represents the return value from the preceding value of the pipeline, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalCall",
                    "documentation": {
                      "identifier": "state.evalCall",
                      "newPage": false,
                      "searchKey": "template.state.evalCall",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalCall(dot, fun reflect.Value, node parse.Node, name string, args []parse.Node, final reflect.Value) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalCall(dot, fun reflect.Value, node parse.Node, name string, args []parse.Node, final reflect.Value) reflect.Value\n```\n\nevalCall executes a function or method call. If it's a method, fun already has the receiver bound, so it looks just like a function call. The arg list, if non-nil, includes (in the manner of the shell), arg[0] as the function itself. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.validateType",
                    "documentation": {
                      "identifier": "state.validateType",
                      "newPage": false,
                      "searchKey": "template.state.validateType",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Value\n```\n\nvalidateType guarantees that the value is valid and assignable to the type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalArg",
                    "documentation": {
                      "identifier": "state.evalArg",
                      "newPage": false,
                      "searchKey": "template.state.evalArg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalArg(dot reflect.Value, typ reflect.Type, n parse.Node) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalArg(dot reflect.Value, typ reflect.Type, n parse.Node) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalBool",
                    "documentation": {
                      "identifier": "state.evalBool",
                      "newPage": false,
                      "searchKey": "template.state.evalBool",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalBool(typ reflect.Type, n parse.Node) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalBool(typ reflect.Type, n parse.Node) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalString",
                    "documentation": {
                      "identifier": "state.evalString",
                      "newPage": false,
                      "searchKey": "template.state.evalString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalString(typ reflect.Type, n parse.Node) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalString(typ reflect.Type, n parse.Node) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalInteger",
                    "documentation": {
                      "identifier": "state.evalInteger",
                      "newPage": false,
                      "searchKey": "template.state.evalInteger",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalInteger(typ reflect.Type, n parse.Node) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalInteger(typ reflect.Type, n parse.Node) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalUnsignedInteger",
                    "documentation": {
                      "identifier": "state.evalUnsignedInteger",
                      "newPage": false,
                      "searchKey": "template.state.evalUnsignedInteger",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalUnsignedInteger(typ reflect.Type, n parse.Node) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalUnsignedInteger(typ reflect.Type, n parse.Node) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalFloat",
                    "documentation": {
                      "identifier": "state.evalFloat",
                      "newPage": false,
                      "searchKey": "template.state.evalFloat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalFloat(typ reflect.Type, n parse.Node) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalFloat(typ reflect.Type, n parse.Node) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalComplex",
                    "documentation": {
                      "identifier": "state.evalComplex",
                      "newPage": false,
                      "searchKey": "template.state.evalComplex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalComplex(typ reflect.Type, n parse.Node) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalComplex(typ reflect.Type, n parse.Node) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.evalEmptyInterface",
                    "documentation": {
                      "identifier": "state.evalEmptyInterface",
                      "newPage": false,
                      "searchKey": "template.state.evalEmptyInterface",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) evalEmptyInterface(dot reflect.Value, n parse.Node) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) evalEmptyInterface(dot reflect.Value, n parse.Node) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#state.printValue",
                    "documentation": {
                      "identifier": "state.printValue",
                      "newPage": false,
                      "searchKey": "template.state.printValue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *state) printValue(n parse.Node, v reflect.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *state) printValue(n parse.Node, v reflect.Value)\n```\n\nprintValue writes the textual representation of the value to the output of the template. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#variable",
              "documentation": {
                "identifier": "variable",
                "newPage": false,
                "searchKey": "template.variable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type variable struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype variable struct {\n\tname  string\n\tvalue reflect.Value\n}\n```\n\nvariable holds the dynamic value of a variable such as $, $x etc. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#missingValType",
              "documentation": {
                "identifier": "missingValType",
                "newPage": false,
                "searchKey": "template.missingValType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type missingValType struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype missingValType struct{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#ExecError",
              "documentation": {
                "identifier": "ExecError",
                "newPage": false,
                "searchKey": "template.ExecError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ExecError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ExecError struct {\n\tName string // Name of template.\n\tErr  error  // Pre-formatted error.\n}\n```\n\nExecError is the custom error type returned when Execute has an error evaluating its template. (If a write error occurs, the actual error is returned; it will not be of type ExecError.) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#ExecError.Error",
                    "documentation": {
                      "identifier": "ExecError.Error",
                      "newPage": false,
                      "searchKey": "template.ExecError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e ExecError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e ExecError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#ExecError.Unwrap",
                    "documentation": {
                      "identifier": "ExecError.Unwrap",
                      "newPage": false,
                      "searchKey": "template.ExecError.Unwrap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e ExecError) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e ExecError) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#writeError",
              "documentation": {
                "identifier": "writeError",
                "newPage": false,
                "searchKey": "template.writeError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type writeError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype writeError struct {\n\tErr error // Original error.\n}\n```\n\nwriteError is the wrapper type used internally when Execute has an error writing to its output. We strip the wrapper in errRecover. Note that this is not an implementation of error, so it cannot escape from the package as an error value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#FuncMap",
              "documentation": {
                "identifier": "FuncMap",
                "newPage": false,
                "searchKey": "template.FuncMap",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FuncMap map[string]interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FuncMap map[string]interface{}\n```\n\nFuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error. \n\nErrors returned by Execute wrap the underlying error; call errors.As to uncover them. \n\nWhen template execution invokes a function with an argument list, that list must be assignable to the function's parameter types. Functions meant to apply to arguments of arbitrary type can use parameters of type interface{} or of type reflect.Value. Similarly, functions meant to return a result of arbitrary type can return interface{} or reflect.Value. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#builtins",
                    "documentation": {
                      "identifier": "builtins",
                      "newPage": false,
                      "searchKey": "template.builtins",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func builtins() FuncMap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc builtins() FuncMap\n```\n\nbuiltins returns the FuncMap. It is not a global variable so the linker can dead code eliminate more when this isn't called. See golang.org/issue/36021. TODO: revert this back to a global map once golang.org/issue/2559 is fixed. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#kind",
              "documentation": {
                "identifier": "kind",
                "newPage": false,
                "searchKey": "template.kind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type kind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype kind int\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#basicKind",
                    "documentation": {
                      "identifier": "basicKind",
                      "newPage": false,
                      "searchKey": "template.basicKind",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func basicKind(v reflect.Value) (kind, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc basicKind(v reflect.Value) (kind, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#missingKeyAction",
              "documentation": {
                "identifier": "missingKeyAction",
                "newPage": false,
                "searchKey": "template.missingKeyAction",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type missingKeyAction int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype missingKeyAction int\n```\n\nmissingKeyAction defines how to respond to indexing a map with a key that is not present. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#option",
              "documentation": {
                "identifier": "option",
                "newPage": false,
                "searchKey": "template.option",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type option struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype option struct {\n\tmissingKey missingKeyAction\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#common",
              "documentation": {
                "identifier": "common",
                "newPage": false,
                "searchKey": "template.common",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type common struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype common struct {\n\ttmpl   map[string]*Template // Map from name to defined templates.\n\tmuTmpl sync.RWMutex         // protects tmpl\n\toption option\n\t// We use two maps, one for parsing and one for execution.\n\t// This separation makes the API cleaner since it doesn't\n\t// expose reflection to the client.\n\tmuFuncs    sync.RWMutex // protects parseFuncs and execFuncs\n\tparseFuncs FuncMap\n\texecFuncs  map[string]reflect.Value\n}\n```\n\ncommon holds the information shared by related templates. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#Template",
              "documentation": {
                "identifier": "Template",
                "newPage": false,
                "searchKey": "template.Template",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Template struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Template struct {\n\tname string\n\t*parse.Tree\n\t*common\n\tleftDelim  string\n\trightDelim string\n}\n```\n\nTemplate is the representation of a parsed template. The *parse.Tree field is exported only for use by html/template and should be treated as unexported by all other clients. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#Must",
                    "documentation": {
                      "identifier": "Must",
                      "newPage": false,
                      "searchKey": "template.Must",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Must(t *Template, err error) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Must(t *Template, err error) *Template\n```\n\nMust is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as \n\n```\nvar t = template.Must(template.New(\"name\").Parse(\"text\"))\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#ParseFiles",
                    "documentation": {
                      "identifier": "ParseFiles",
                      "newPage": false,
                      "searchKey": "template.ParseFiles",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseFiles(filenames ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseFiles(filenames ...string) (*Template, error)\n```\n\nParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil. \n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#parseFiles",
                    "documentation": {
                      "identifier": "parseFiles",
                      "newPage": false,
                      "searchKey": "template.parseFiles",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error)\n```\n\nparseFiles is the helper for the method and function. If the argument template is nil, it is created from the first file. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#ParseGlob",
                    "documentation": {
                      "identifier": "ParseGlob",
                      "newPage": false,
                      "searchKey": "template.ParseGlob",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseGlob(pattern string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseGlob(pattern string) (*Template, error)\n```\n\nParseGlob creates a new Template and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern. \n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#parseGlob",
                    "documentation": {
                      "identifier": "parseGlob",
                      "newPage": false,
                      "searchKey": "template.parseGlob",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseGlob(t *Template, pattern string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseGlob(t *Template, pattern string) (*Template, error)\n```\n\nparseGlob is the implementation of the function and method ParseGlob. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#ParseFS",
                    "documentation": {
                      "identifier": "ParseFS",
                      "newPage": false,
                      "searchKey": "template.ParseFS",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseFS(fsys fs.FS, patterns ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseFS(fsys fs.FS, patterns ...string) (*Template, error)\n```\n\nParseFS is like ParseFiles or ParseGlob but reads from the file system fsys instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#parseFS",
                    "documentation": {
                      "identifier": "parseFS",
                      "newPage": false,
                      "searchKey": "template.parseFS",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#New",
                    "documentation": {
                      "identifier": "New",
                      "newPage": false,
                      "searchKey": "template.New",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func New(name string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc New(name string) *Template\n```\n\nNew allocates a new, undefined template with the given name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.ExecuteTemplate",
                    "documentation": {
                      "identifier": "Template.ExecuteTemplate",
                      "newPage": false,
                      "searchKey": "template.Template.ExecuteTemplate",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error\n```\n\nExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.Execute",
                    "documentation": {
                      "identifier": "Template.Execute",
                      "newPage": false,
                      "searchKey": "template.Template.Execute",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Execute(wr io.Writer, data interface{}) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Execute(wr io.Writer, data interface{}) error\n```\n\nExecute applies a parsed template to the specified data object, and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. \n\nIf data is a reflect.Value, the template applies to the concrete value that the reflect.Value holds, as in fmt.Print. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.execute",
                    "documentation": {
                      "identifier": "Template.execute",
                      "newPage": false,
                      "searchKey": "template.Template.execute",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) execute(wr io.Writer, data interface{}) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) execute(wr io.Writer, data interface{}) (err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.DefinedTemplates",
                    "documentation": {
                      "identifier": "Template.DefinedTemplates",
                      "newPage": false,
                      "searchKey": "template.Template.DefinedTemplates",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) DefinedTemplates() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) DefinedTemplates() string\n```\n\nDefinedTemplates returns a string listing the defined templates, prefixed by the string \"; defined templates are: \". If there are none, it returns the empty string. For generating an error message here and in html/template. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.ParseFiles",
                    "documentation": {
                      "identifier": "Template.ParseFiles",
                      "newPage": false,
                      "searchKey": "template.Template.ParseFiles",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) ParseFiles(filenames ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) ParseFiles(filenames ...string) (*Template, error)\n```\n\nParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. Since the templates created by ParseFiles are named by the base names of the argument files, t should usually have the name of one of the (base) names of the files. If it does not, depending on t's contents before calling ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to execute a valid template. \n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.ParseGlob",
                    "documentation": {
                      "identifier": "Template.ParseGlob",
                      "newPage": false,
                      "searchKey": "template.Template.ParseGlob",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) ParseGlob(pattern string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) ParseGlob(pattern string) (*Template, error)\n```\n\nParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern. \n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.ParseFS",
                    "documentation": {
                      "identifier": "Template.ParseFS",
                      "newPage": false,
                      "searchKey": "template.Template.ParseFS",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error)\n```\n\nParseFS is like ParseFiles or ParseGlob but reads from the file system fsys instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.Option",
                    "documentation": {
                      "identifier": "Template.Option",
                      "newPage": false,
                      "searchKey": "template.Template.Option",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Option(opt ...string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Option(opt ...string) *Template\n```\n\nOption sets options for the template. Options are described by strings, either a simple string or \"key=value\". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics. \n\nKnown options: \n\nmissingkey: Control the behavior during execution if a map is indexed with a key that is not present in the map. \n\n```\n\"missingkey=default\" or \"missingkey=invalid\"\n\tThe default behavior: Do nothing and continue execution.\n\tIf printed, the result of the index operation is the string\n\t\"<no value>\".\n\"missingkey=zero\"\n\tThe operation returns the zero value for the map type's element.\n\"missingkey=error\"\n\tExecution stops immediately with an error.\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.setOption",
                    "documentation": {
                      "identifier": "Template.setOption",
                      "newPage": false,
                      "searchKey": "template.Template.setOption",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) setOption(opt string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) setOption(opt string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.Name",
                    "documentation": {
                      "identifier": "Template.Name",
                      "newPage": false,
                      "searchKey": "template.Template.Name",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Name() string\n```\n\nName returns the name of the template. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.New",
                    "documentation": {
                      "identifier": "Template.New",
                      "newPage": false,
                      "searchKey": "template.Template.New",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) New(name string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) New(name string) *Template\n```\n\nNew allocates a new, undefined template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action. \n\nBecause associated templates share underlying data, template construction cannot be done safely in parallel. Once the templates are constructed, they can be executed in parallel. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.init",
                    "documentation": {
                      "identifier": "Template.init",
                      "newPage": false,
                      "searchKey": "template.Template.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) init()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) init()\n```\n\ninit guarantees that t has a valid common structure. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.Clone",
                    "documentation": {
                      "identifier": "Template.Clone",
                      "newPage": false,
                      "searchKey": "template.Template.Clone",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Clone() (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Clone() (*Template, error)\n```\n\nClone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to Parse in the copy will add templates to the copy but not to the original. Clone can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.copy",
                    "documentation": {
                      "identifier": "Template.copy",
                      "newPage": false,
                      "searchKey": "template.Template.copy",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) copy(c *common) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) copy(c *common) *Template\n```\n\ncopy returns a shallow copy of t, with common set to the argument. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.AddParseTree",
                    "documentation": {
                      "identifier": "Template.AddParseTree",
                      "newPage": false,
                      "searchKey": "template.Template.AddParseTree",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)\n```\n\nAddParseTree associates the argument parse tree with the template t, giving it the specified name. If the template has not been defined, this tree becomes its definition. If it has been defined and already has that name, the existing definition is replaced; otherwise a new template is created, defined, and returned. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.Templates",
                    "documentation": {
                      "identifier": "Template.Templates",
                      "newPage": false,
                      "searchKey": "template.Template.Templates",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Templates() []*Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Templates() []*Template\n```\n\nTemplates returns a slice of defined templates associated with t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.Delims",
                    "documentation": {
                      "identifier": "Template.Delims",
                      "newPage": false,
                      "searchKey": "template.Template.Delims",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Delims(left, right string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Delims(left, right string) *Template\n```\n\nDelims sets the action delimiters to the specified strings, to be used in subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.Funcs",
                    "documentation": {
                      "identifier": "Template.Funcs",
                      "newPage": false,
                      "searchKey": "template.Template.Funcs",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Funcs(funcMap FuncMap) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Funcs(funcMap FuncMap) *Template\n```\n\nFuncs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type or if the name cannot be used syntactically as a function in a template. It is legal to overwrite elements of the map. The return value is the template, so calls can be chained. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.Lookup",
                    "documentation": {
                      "identifier": "Template.Lookup",
                      "newPage": false,
                      "searchKey": "template.Template.Lookup",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Lookup(name string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Lookup(name string) *Template\n```\n\nLookup returns the template with the given name that is associated with t. It returns nil if there is no such template or the template has no definition. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.Parse",
                    "documentation": {
                      "identifier": "Template.Parse",
                      "newPage": false,
                      "searchKey": "template.Template.Parse",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Parse(text string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Parse(text string) (*Template, error)\n```\n\nParse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself. \n\nTemplates can be redefined in successive calls to Parse. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#Template.associate",
                    "documentation": {
                      "identifier": "Template.associate",
                      "newPage": false,
                      "searchKey": "template.Template.associate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) associate(new *Template, tree *parse.Tree) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) associate(new *Template, tree *parse.Tree) bool\n```\n\nassociate installs the new template into the group of templates associated with t. The two are already known to share the common structure. The boolean return value reports whether to store this tree as t.Tree. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#T",
              "documentation": {
                "identifier": "T",
                "newPage": false,
                "searchKey": "template.T",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type T struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype T struct {\n\t// Basics\n\tTrue        bool\n\tI           int\n\tU16         uint16\n\tX, S        string\n\tFloatZero   float64\n\tComplexZero complex128\n\t// Nested structs.\n\tU *U\n\t// Struct with String method.\n\tV0     V\n\tV1, V2 *V\n\t// Struct with Error method.\n\tW0     W\n\tW1, W2 *W\n\t// Slices\n\tSI      []int\n\tSICap   []int\n\tSIEmpty []int\n\tSB      []bool\n\t// Arrays\n\tAI [3]int\n\t// Maps\n\tMSI      map[string]int\n\tMSIone   map[string]int // one element, for deterministic output\n\tMSIEmpty map[string]int\n\tMXI      map[interface{}]int\n\tMII      map[int]int\n\tMI32S    map[int32]string\n\tMI64S    map[int64]string\n\tMUI32S   map[uint32]string\n\tMUI64S   map[uint64]string\n\tMI8S     map[int8]string\n\tMUI8S    map[uint8]string\n\tSMSI     []map[string]int\n\t// Empty interfaces; used to see if we can dig inside one.\n\tEmpty0 interface{} // nil\n\tEmpty1 interface{}\n\tEmpty2 interface{}\n\tEmpty3 interface{}\n\tEmpty4 interface{}\n\t// Non-empty interfaces.\n\tNonEmptyInterface         I\n\tNonEmptyInterfacePtS      *I\n\tNonEmptyInterfaceNil      I\n\tNonEmptyInterfaceTypedNil I\n\t// Stringer.\n\tStr fmt.Stringer\n\tErr error\n\t// Pointers\n\tPI  *int\n\tPS  *string\n\tPSI *[]int\n\tNIL *int\n\t// Function (not method)\n\tBinaryFunc      func(string, string) string\n\tVariadicFunc    func(...string) string\n\tVariadicFuncInt func(int, ...string) string\n\tNilOKFunc       func(*int) bool\n\tErrFunc         func() (string, error)\n\tPanicFunc       func() string\n\t// Template to test evaluation of templates.\n\tTmpl *Template\n\t// Unexported field; cannot be accessed by template.\n\tunexported int\n}\n```\n\nT has lots of interesting pieces to use to test execution. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#T.Method0",
                    "documentation": {
                      "identifier": "T.Method0",
                      "newPage": false,
                      "searchKey": "template.T.Method0",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Method0() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Method0() string\n```\n\nSimple methods with and without arguments. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#T.Method1",
                    "documentation": {
                      "identifier": "T.Method1",
                      "newPage": false,
                      "searchKey": "template.T.Method1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Method1(a int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Method1(a int) int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#T.Method2",
                    "documentation": {
                      "identifier": "T.Method2",
                      "newPage": false,
                      "searchKey": "template.T.Method2",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Method2(a uint16, b string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Method2(a uint16, b string) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#T.Method3",
                    "documentation": {
                      "identifier": "T.Method3",
                      "newPage": false,
                      "searchKey": "template.T.Method3",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Method3(v interface{}) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Method3(v interface{}) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#T.Copy",
                    "documentation": {
                      "identifier": "T.Copy",
                      "newPage": false,
                      "searchKey": "template.T.Copy",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Copy() *T"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Copy() *T\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#T.MAdd",
                    "documentation": {
                      "identifier": "T.MAdd",
                      "newPage": false,
                      "searchKey": "template.T.MAdd",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) MAdd(a int, b []int) []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) MAdd(a int, b []int) []int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#T.MyError",
                    "documentation": {
                      "identifier": "T.MyError",
                      "newPage": false,
                      "searchKey": "template.T.MyError",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) MyError(error bool) (bool, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) MyError(error bool) (bool, error)\n```\n\nMyError returns a value and an error according to its argument. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/text/template#T.GetU",
                    "documentation": {
                      "identifier": "T.GetU",
                      "newPage": false,
                      "searchKey": "template.T.GetU",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) GetU() *U"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) GetU() *U\n```\n\nA few methods to test chaining. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#S",
              "documentation": {
                "identifier": "S",
                "newPage": false,
                "searchKey": "template.S",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type S []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype S []string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#S.Method0",
                    "documentation": {
                      "identifier": "S.Method0",
                      "newPage": false,
                      "searchKey": "template.S.Method0",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (S) Method0() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (S) Method0() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#U",
              "documentation": {
                "identifier": "U",
                "newPage": false,
                "searchKey": "template.U",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type U struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype U struct {\n\tV string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#U.TrueFalse",
                    "documentation": {
                      "identifier": "U.TrueFalse",
                      "newPage": false,
                      "searchKey": "template.U.TrueFalse",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (u *U) TrueFalse(b bool) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (u *U) TrueFalse(b bool) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#V",
              "documentation": {
                "identifier": "V",
                "newPage": false,
                "searchKey": "template.V",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type V struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype V struct {\n\tj int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#V.String",
                    "documentation": {
                      "identifier": "V.String",
                      "newPage": false,
                      "searchKey": "template.V.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v *V) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v *V) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#W",
              "documentation": {
                "identifier": "W",
                "newPage": false,
                "searchKey": "template.W",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type W struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype W struct {\n\tk int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#W.Error",
                    "documentation": {
                      "identifier": "W.Error",
                      "newPage": false,
                      "searchKey": "template.W.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *W) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *W) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#I",
              "documentation": {
                "identifier": "I",
                "newPage": false,
                "searchKey": "template.I",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type I interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype I interface {\n\tMethod0() string\n}\n```\n\nA non-empty interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#execTest",
              "documentation": {
                "identifier": "execTest",
                "newPage": false,
                "searchKey": "template.execTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type execTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype execTest struct {\n\tname   string\n\tinput  string\n\toutput string\n\tdata   interface{}\n\tok     bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#CustomError",
              "documentation": {
                "identifier": "CustomError",
                "newPage": false,
                "searchKey": "template.CustomError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type CustomError struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype CustomError struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#CustomError.Error",
                    "documentation": {
                      "identifier": "CustomError.Error",
                      "newPage": false,
                      "searchKey": "template.CustomError.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*CustomError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*CustomError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#Tree",
              "documentation": {
                "identifier": "Tree",
                "newPage": false,
                "searchKey": "template.Tree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Tree struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Tree struct {\n\tVal         int\n\tLeft, Right *Tree\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#cmpTest",
              "documentation": {
                "identifier": "cmpTest",
                "newPage": false,
                "searchKey": "template.cmpTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cmpTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cmpTest struct {\n\texpr  string\n\ttruth string\n\tok    bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#ErrorWriter",
              "documentation": {
                "identifier": "ErrorWriter",
                "newPage": false,
                "searchKey": "template.ErrorWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ErrorWriter int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ErrorWriter int\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/text/template#ErrorWriter.Write",
                    "documentation": {
                      "identifier": "ErrorWriter.Write",
                      "newPage": false,
                      "searchKey": "template.ErrorWriter.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e ErrorWriter) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e ErrorWriter) Write(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#multiParseTest",
              "documentation": {
                "identifier": "multiParseTest",
                "newPage": false,
                "searchKey": "template.multiParseTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type multiParseTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype multiParseTest struct {\n\tname    string\n\tinput   string\n\tok      bool\n\tnames   []string\n\tresults []string\n}\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/text/template#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/text/template#initMaxExecDepth",
              "documentation": {
                "identifier": "initMaxExecDepth",
                "newPage": false,
                "searchKey": "template.initMaxExecDepth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func initMaxExecDepth() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc initMaxExecDepth() int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#doublePercent",
              "documentation": {
                "identifier": "doublePercent",
                "newPage": false,
                "searchKey": "template.doublePercent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func doublePercent(str string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc doublePercent(str string) string\n```\n\ndoublePercent returns the string with %'s replaced by %%, if necessary, so it can be used safely inside a Printf format string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#errRecover",
              "documentation": {
                "identifier": "errRecover",
                "newPage": false,
                "searchKey": "template.errRecover",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func errRecover(errp *error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errRecover(errp *error)\n```\n\nerrRecover is the handler that turns panics into returns from the top level of Parse. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#IsTrue",
              "documentation": {
                "identifier": "IsTrue",
                "newPage": false,
                "searchKey": "template.IsTrue",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsTrue(val interface{}) (truth, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsTrue(val interface{}) (truth, ok bool)\n```\n\nIsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#isTrue",
              "documentation": {
                "identifier": "isTrue",
                "newPage": false,
                "searchKey": "template.isTrue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isTrue(val reflect.Value) (truth, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isTrue(val reflect.Value) (truth, ok bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#isRuneInt",
              "documentation": {
                "identifier": "isRuneInt",
                "newPage": false,
                "searchKey": "template.isRuneInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isRuneInt(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isRuneInt(s string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#isHexInt",
              "documentation": {
                "identifier": "isHexInt",
                "newPage": false,
                "searchKey": "template.isHexInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isHexInt(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isHexInt(s string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#canBeNil",
              "documentation": {
                "identifier": "canBeNil",
                "newPage": false,
                "searchKey": "template.canBeNil",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func canBeNil(typ reflect.Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc canBeNil(typ reflect.Type) bool\n```\n\ncanBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#indirect",
              "documentation": {
                "identifier": "indirect",
                "newPage": false,
                "searchKey": "template.indirect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func indirect(v reflect.Value) (rv reflect.Value, isNil bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc indirect(v reflect.Value) (rv reflect.Value, isNil bool)\n```\n\nindirect returns the item at the end of indirection, and a bool to indicate if it's nil. If the returned bool is true, the returned value's kind will be either a pointer or interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#indirectInterface",
              "documentation": {
                "identifier": "indirectInterface",
                "newPage": false,
                "searchKey": "template.indirectInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func indirectInterface(v reflect.Value) reflect.Value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc indirectInterface(v reflect.Value) reflect.Value\n```\n\nindirectInterface returns the concrete value in an interface value, or else the zero reflect.Value. That is, if v represents the interface value x, the result is the same as reflect.ValueOf(x): the fact that x was an interface value is forgotten. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#printableValue",
              "documentation": {
                "identifier": "printableValue",
                "newPage": false,
                "searchKey": "template.printableValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printableValue(v reflect.Value) (interface{}, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printableValue(v reflect.Value) (interface{}, bool)\n```\n\nprintableValue returns the, possibly indirected, interface value inside v that is best for a call to formatted printer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#builtinFuncs",
              "documentation": {
                "identifier": "builtinFuncs",
                "newPage": false,
                "searchKey": "template.builtinFuncs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func builtinFuncs() map[string]reflect.Value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc builtinFuncs() map[string]reflect.Value\n```\n\nbuiltinFuncsOnce lazily computes & caches the builtinFuncs map. TODO: revert this back to a global map once golang.org/issue/2559 is fixed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#createValueFuncs",
              "documentation": {
                "identifier": "createValueFuncs",
                "newPage": false,
                "searchKey": "template.createValueFuncs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func createValueFuncs(funcMap FuncMap) map[string]reflect.Value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc createValueFuncs(funcMap FuncMap) map[string]reflect.Value\n```\n\ncreateValueFuncs turns a FuncMap into a map[string]reflect.Value \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#addValueFuncs",
              "documentation": {
                "identifier": "addValueFuncs",
                "newPage": false,
                "searchKey": "template.addValueFuncs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addValueFuncs(out map[string]reflect.Value, in FuncMap)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addValueFuncs(out map[string]reflect.Value, in FuncMap)\n```\n\naddValueFuncs adds to values the functions in funcs, converting them to reflect.Values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#addFuncs",
              "documentation": {
                "identifier": "addFuncs",
                "newPage": false,
                "searchKey": "template.addFuncs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addFuncs(out, in FuncMap)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addFuncs(out, in FuncMap)\n```\n\naddFuncs adds to values the functions in funcs. It does no checking of the input - call addValueFuncs first. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#goodFunc",
              "documentation": {
                "identifier": "goodFunc",
                "newPage": false,
                "searchKey": "template.goodFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goodFunc(typ reflect.Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goodFunc(typ reflect.Type) bool\n```\n\ngoodFunc reports whether the function or method has the right result signature. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#goodName",
              "documentation": {
                "identifier": "goodName",
                "newPage": false,
                "searchKey": "template.goodName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goodName(name string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goodName(name string) bool\n```\n\ngoodName reports whether the function name is a valid identifier. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#findFunction",
              "documentation": {
                "identifier": "findFunction",
                "newPage": false,
                "searchKey": "template.findFunction",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func findFunction(name string, tmpl *Template) (reflect.Value, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc findFunction(name string, tmpl *Template) (reflect.Value, bool)\n```\n\nfindFunction looks for a function in the template, and global map. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#prepareArg",
              "documentation": {
                "identifier": "prepareArg",
                "newPage": false,
                "searchKey": "template.prepareArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error)\n```\n\nprepareArg checks if value can be used as an argument of type argType, and converts an invalid value to appropriate zero if possible. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#intLike",
              "documentation": {
                "identifier": "intLike",
                "newPage": false,
                "searchKey": "template.intLike",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func intLike(typ reflect.Kind) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc intLike(typ reflect.Kind) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#indexArg",
              "documentation": {
                "identifier": "indexArg",
                "newPage": false,
                "searchKey": "template.indexArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func indexArg(index reflect.Value, cap int) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc indexArg(index reflect.Value, cap int) (int, error)\n```\n\nindexArg checks if a reflect.Value can be used as an index, and converts it to int if possible. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#index",
              "documentation": {
                "identifier": "index",
                "newPage": false,
                "searchKey": "template.index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func index(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc index(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error)\n```\n\nindex returns the result of indexing its first argument by the following arguments. Thus \"index x 1 2 3\" is, in Go syntax, x[1][2][3]. Each indexed item must be a map, slice, or array. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#slice",
              "documentation": {
                "identifier": "slice",
                "newPage": false,
                "searchKey": "template.slice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func slice(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc slice(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error)\n```\n\nslice returns the result of slicing its first argument by the remaining arguments. Thus \"slice x 1 2\" is, in Go syntax, x[1:2], while \"slice x\" is x[:], \"slice x 1\" is x[1:], and \"slice x 1 2 3\" is x[1:2:3]. The first argument must be a string, slice, or array. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#length",
              "documentation": {
                "identifier": "length",
                "newPage": false,
                "searchKey": "template.length",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func length(item reflect.Value) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc length(item reflect.Value) (int, error)\n```\n\nlength returns the length of the item, with an error if it has no defined length. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#call",
              "documentation": {
                "identifier": "call",
                "newPage": false,
                "searchKey": "template.call",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call(fn reflect.Value, args ...reflect.Value) (reflect.Value, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call(fn reflect.Value, args ...reflect.Value) (reflect.Value, error)\n```\n\ncall returns the result of evaluating the first argument as a function. The function must return 1 result, or 2 results, the second of which is an error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#safeCall",
              "documentation": {
                "identifier": "safeCall",
                "newPage": false,
                "searchKey": "template.safeCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func safeCall(fun reflect.Value, args []reflect.Value) (val reflect.Value, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc safeCall(fun reflect.Value, args []reflect.Value) (val reflect.Value, err error)\n```\n\nsafeCall runs fun.Call(args), and returns the resulting value and error, if any. If the call panics, the panic value is returned as an error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#truth",
              "documentation": {
                "identifier": "truth",
                "newPage": false,
                "searchKey": "template.truth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func truth(arg reflect.Value) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc truth(arg reflect.Value) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#and",
              "documentation": {
                "identifier": "and",
                "newPage": false,
                "searchKey": "template.and",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func and(arg0 reflect.Value, args ...reflect.Value) reflect.Value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc and(arg0 reflect.Value, args ...reflect.Value) reflect.Value\n```\n\nand computes the Boolean AND of its arguments, returning the first false argument it encounters, or the last argument. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#or",
              "documentation": {
                "identifier": "or",
                "newPage": false,
                "searchKey": "template.or",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func or(arg0 reflect.Value, args ...reflect.Value) reflect.Value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc or(arg0 reflect.Value, args ...reflect.Value) reflect.Value\n```\n\nor computes the Boolean OR of its arguments, returning the first true argument it encounters, or the last argument. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#not",
              "documentation": {
                "identifier": "not",
                "newPage": false,
                "searchKey": "template.not",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func not(arg reflect.Value) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc not(arg reflect.Value) bool\n```\n\nnot returns the Boolean negation of its argument. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#eq",
              "documentation": {
                "identifier": "eq",
                "newPage": false,
                "searchKey": "template.eq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func eq(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc eq(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)\n```\n\neq evaluates the comparison a == b || a == c || ... \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#ne",
              "documentation": {
                "identifier": "ne",
                "newPage": false,
                "searchKey": "template.ne",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ne(arg1, arg2 reflect.Value) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ne(arg1, arg2 reflect.Value) (bool, error)\n```\n\nne evaluates the comparison a != b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#lt",
              "documentation": {
                "identifier": "lt",
                "newPage": false,
                "searchKey": "template.lt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lt(arg1, arg2 reflect.Value) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lt(arg1, arg2 reflect.Value) (bool, error)\n```\n\nlt evaluates the comparison a < b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#le",
              "documentation": {
                "identifier": "le",
                "newPage": false,
                "searchKey": "template.le",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func le(arg1, arg2 reflect.Value) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc le(arg1, arg2 reflect.Value) (bool, error)\n```\n\nle evaluates the comparison <= b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#gt",
              "documentation": {
                "identifier": "gt",
                "newPage": false,
                "searchKey": "template.gt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gt(arg1, arg2 reflect.Value) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gt(arg1, arg2 reflect.Value) (bool, error)\n```\n\ngt evaluates the comparison a > b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#ge",
              "documentation": {
                "identifier": "ge",
                "newPage": false,
                "searchKey": "template.ge",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ge(arg1, arg2 reflect.Value) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ge(arg1, arg2 reflect.Value) (bool, error)\n```\n\nge evaluates the comparison a >= b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#HTMLEscape",
              "documentation": {
                "identifier": "HTMLEscape",
                "newPage": false,
                "searchKey": "template.HTMLEscape",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HTMLEscape(w io.Writer, b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HTMLEscape(w io.Writer, b []byte)\n```\n\nHTMLEscape writes to w the escaped HTML equivalent of the plain text data b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#HTMLEscapeString",
              "documentation": {
                "identifier": "HTMLEscapeString",
                "newPage": false,
                "searchKey": "template.HTMLEscapeString",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HTMLEscapeString(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HTMLEscapeString(s string) string\n```\n\nHTMLEscapeString returns the escaped HTML equivalent of the plain text data s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#HTMLEscaper",
              "documentation": {
                "identifier": "HTMLEscaper",
                "newPage": false,
                "searchKey": "template.HTMLEscaper",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HTMLEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HTMLEscaper(args ...interface{}) string\n```\n\nHTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#JSEscape",
              "documentation": {
                "identifier": "JSEscape",
                "newPage": false,
                "searchKey": "template.JSEscape",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func JSEscape(w io.Writer, b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc JSEscape(w io.Writer, b []byte)\n```\n\nJSEscape writes to w the escaped JavaScript equivalent of the plain text data b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#JSEscapeString",
              "documentation": {
                "identifier": "JSEscapeString",
                "newPage": false,
                "searchKey": "template.JSEscapeString",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func JSEscapeString(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc JSEscapeString(s string) string\n```\n\nJSEscapeString returns the escaped JavaScript equivalent of the plain text data s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#jsIsSpecial",
              "documentation": {
                "identifier": "jsIsSpecial",
                "newPage": false,
                "searchKey": "template.jsIsSpecial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func jsIsSpecial(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc jsIsSpecial(r rune) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#JSEscaper",
              "documentation": {
                "identifier": "JSEscaper",
                "newPage": false,
                "searchKey": "template.JSEscaper",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func JSEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc JSEscaper(args ...interface{}) string\n```\n\nJSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#URLQueryEscaper",
              "documentation": {
                "identifier": "URLQueryEscaper",
                "newPage": false,
                "searchKey": "template.URLQueryEscaper",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func URLQueryEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc URLQueryEscaper(args ...interface{}) string\n```\n\nURLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#evalArgs",
              "documentation": {
                "identifier": "evalArgs",
                "newPage": false,
                "searchKey": "template.evalArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func evalArgs(args []interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc evalArgs(args []interface{}) string\n```\n\nevalArgs formats the list of arguments into a string. It is therefore equivalent to \n\n```\nfmt.Sprint(args...)\n\n```\nexcept that each argument is indirected (if a pointer), as required, using the same rules as the default string evaluation during template execution. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#readFileOS",
              "documentation": {
                "identifier": "readFileOS",
                "newPage": false,
                "searchKey": "template.readFileOS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readFileOS(file string) (name string, b []byte, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readFileOS(file string) (name string, b []byte, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#readFileFS",
              "documentation": {
                "identifier": "readFileFS",
                "newPage": false,
                "searchKey": "template.readFileFS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readFileFS(fsys fs.FS) func(string) (string, []byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readFileFS(fsys fs.FS) func(string) (string, []byte, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#newInt",
              "documentation": {
                "identifier": "newInt",
                "newPage": false,
                "searchKey": "template.newInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newInt(n int) *int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newInt(n int) *int\n```\n\nHelpers for creation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#newString",
              "documentation": {
                "identifier": "newString",
                "newPage": false,
                "searchKey": "template.newString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newString(s string) *string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newString(s string) *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#newIntSlice",
              "documentation": {
                "identifier": "newIntSlice",
                "newPage": false,
                "searchKey": "template.newIntSlice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newIntSlice(n ...int) *[]int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newIntSlice(n ...int) *[]int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#typeOf",
              "documentation": {
                "identifier": "typeOf",
                "newPage": false,
                "searchKey": "template.typeOf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typeOf(arg interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typeOf(arg interface{}) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#zeroArgs",
              "documentation": {
                "identifier": "zeroArgs",
                "newPage": false,
                "searchKey": "template.zeroArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func zeroArgs() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc zeroArgs() string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#oneArg",
              "documentation": {
                "identifier": "oneArg",
                "newPage": false,
                "searchKey": "template.oneArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func oneArg(a string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc oneArg(a string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#twoArgs",
              "documentation": {
                "identifier": "twoArgs",
                "newPage": false,
                "searchKey": "template.twoArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func twoArgs(a, b string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc twoArgs(a, b string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#dddArg",
              "documentation": {
                "identifier": "dddArg",
                "newPage": false,
                "searchKey": "template.dddArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dddArg(a int, b ...string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dddArg(a int, b ...string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#count",
              "documentation": {
                "identifier": "count",
                "newPage": false,
                "searchKey": "template.count",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func count(n int) chan string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc count(n int) chan string\n```\n\ncount returns a channel that will deliver n sequential 1-letter strings starting at \"a\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#vfunc",
              "documentation": {
                "identifier": "vfunc",
                "newPage": false,
                "searchKey": "template.vfunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func vfunc(V, *V) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc vfunc(V, *V) string\n```\n\nvfunc takes a *V and a V \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#valueString",
              "documentation": {
                "identifier": "valueString",
                "newPage": false,
                "searchKey": "template.valueString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func valueString(v string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc valueString(v string) string\n```\n\nvalueString takes a string, not a pointer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#returnInt",
              "documentation": {
                "identifier": "returnInt",
                "newPage": false,
                "searchKey": "template.returnInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func returnInt() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc returnInt() int\n```\n\nreturnInt returns an int \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#add",
              "documentation": {
                "identifier": "add",
                "newPage": false,
                "searchKey": "template.add",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func add(args ...int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc add(args ...int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#echo",
              "documentation": {
                "identifier": "echo",
                "newPage": false,
                "searchKey": "template.echo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func echo(arg interface{}) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc echo(arg interface{}) interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#makemap",
              "documentation": {
                "identifier": "makemap",
                "newPage": false,
                "searchKey": "template.makemap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makemap(arg ...string) map[string]string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makemap(arg ...string) map[string]string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#stringer",
              "documentation": {
                "identifier": "stringer",
                "newPage": false,
                "searchKey": "template.stringer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringer(s fmt.Stringer) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringer(s fmt.Stringer) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#mapOfThree",
              "documentation": {
                "identifier": "mapOfThree",
                "newPage": false,
                "searchKey": "template.mapOfThree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapOfThree() interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapOfThree() interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#testExecute",
              "documentation": {
                "identifier": "testExecute",
                "newPage": false,
                "searchKey": "template.testExecute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testExecute(execTests []execTest, template *Template, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testExecute(execTests []execTest, template *Template, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestExecute",
              "documentation": {
                "identifier": "TestExecute",
                "newPage": false,
                "searchKey": "template.TestExecute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecute(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecute(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestDelims",
              "documentation": {
                "identifier": "TestDelims",
                "newPage": false,
                "searchKey": "template.TestDelims",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDelims(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDelims(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestExecuteError",
              "documentation": {
                "identifier": "TestExecuteError",
                "newPage": false,
                "searchKey": "template.TestExecuteError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecuteError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecuteError(t *testing.T)\n```\n\nCheck that an error from a method flows back to the top. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestExecError",
              "documentation": {
                "identifier": "TestExecError",
                "newPage": false,
                "searchKey": "template.TestExecError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecError(t *testing.T)\n```\n\nCheck that an error from a nested template contains all the relevant information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestExecError_CustomError",
              "documentation": {
                "identifier": "TestExecError_CustomError",
                "newPage": false,
                "searchKey": "template.TestExecError_CustomError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecError_CustomError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecError_CustomError(t *testing.T)\n```\n\nCheck that a custom error can be returned. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestJSEscaping",
              "documentation": {
                "identifier": "TestJSEscaping",
                "newPage": false,
                "searchKey": "template.TestJSEscaping",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestJSEscaping(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestJSEscaping(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestTree",
              "documentation": {
                "identifier": "TestTree",
                "newPage": false,
                "searchKey": "template.TestTree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTree(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTree(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestExecuteOnNewTemplate",
              "documentation": {
                "identifier": "TestExecuteOnNewTemplate",
                "newPage": false,
                "searchKey": "template.TestExecuteOnNewTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecuteOnNewTemplate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecuteOnNewTemplate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestMessageForExecuteEmpty",
              "documentation": {
                "identifier": "TestMessageForExecuteEmpty",
                "newPage": false,
                "searchKey": "template.TestMessageForExecuteEmpty",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMessageForExecuteEmpty(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMessageForExecuteEmpty(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestFinalForPrintf",
              "documentation": {
                "identifier": "TestFinalForPrintf",
                "newPage": false,
                "searchKey": "template.TestFinalForPrintf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFinalForPrintf(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFinalForPrintf(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestComparison",
              "documentation": {
                "identifier": "TestComparison",
                "newPage": false,
                "searchKey": "template.TestComparison",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestComparison(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestComparison(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestMissingMapKey",
              "documentation": {
                "identifier": "TestMissingMapKey",
                "newPage": false,
                "searchKey": "template.TestMissingMapKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMissingMapKey(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMissingMapKey(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestUnterminatedStringError",
              "documentation": {
                "identifier": "TestUnterminatedStringError",
                "newPage": false,
                "searchKey": "template.TestUnterminatedStringError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnterminatedStringError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnterminatedStringError(t *testing.T)\n```\n\nTest that the error message for multiline unterminated string refers to the line number of the opening quote. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestExecuteGivesExecError",
              "documentation": {
                "identifier": "TestExecuteGivesExecError",
                "newPage": false,
                "searchKey": "template.TestExecuteGivesExecError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecuteGivesExecError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecuteGivesExecError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#funcNameTestFunc",
              "documentation": {
                "identifier": "funcNameTestFunc",
                "newPage": false,
                "searchKey": "template.funcNameTestFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcNameTestFunc() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcNameTestFunc() int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestGoodFuncNames",
              "documentation": {
                "identifier": "TestGoodFuncNames",
                "newPage": false,
                "searchKey": "template.TestGoodFuncNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGoodFuncNames(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGoodFuncNames(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestBadFuncNames",
              "documentation": {
                "identifier": "TestBadFuncNames",
                "newPage": false,
                "searchKey": "template.TestBadFuncNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBadFuncNames(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBadFuncNames(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#testBadFuncName",
              "documentation": {
                "identifier": "testBadFuncName",
                "newPage": false,
                "searchKey": "template.testBadFuncName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testBadFuncName(name string, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testBadFuncName(name string, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestBlock",
              "documentation": {
                "identifier": "TestBlock",
                "newPage": false,
                "searchKey": "template.TestBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBlock(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBlock(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestEvalFieldErrors",
              "documentation": {
                "identifier": "TestEvalFieldErrors",
                "newPage": false,
                "searchKey": "template.TestEvalFieldErrors",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEvalFieldErrors(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEvalFieldErrors(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestMaxExecDepth",
              "documentation": {
                "identifier": "TestMaxExecDepth",
                "newPage": false,
                "searchKey": "template.TestMaxExecDepth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMaxExecDepth(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMaxExecDepth(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestAddrOfIndex",
              "documentation": {
                "identifier": "TestAddrOfIndex",
                "newPage": false,
                "searchKey": "template.TestAddrOfIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAddrOfIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAddrOfIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestInterfaceValues",
              "documentation": {
                "identifier": "TestInterfaceValues",
                "newPage": false,
                "searchKey": "template.TestInterfaceValues",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInterfaceValues(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInterfaceValues(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestExecutePanicDuringCall",
              "documentation": {
                "identifier": "TestExecutePanicDuringCall",
                "newPage": false,
                "searchKey": "template.TestExecutePanicDuringCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecutePanicDuringCall(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecutePanicDuringCall(t *testing.T)\n```\n\nCheck that panics during calls are recovered and returned as errors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestIssue31810",
              "documentation": {
                "identifier": "TestIssue31810",
                "newPage": false,
                "searchKey": "template.TestIssue31810",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue31810(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue31810(t *testing.T)\n```\n\nIssue 31810. Check that a parenthesized first argument behaves properly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestIssue43065",
              "documentation": {
                "identifier": "TestIssue43065",
                "newPage": false,
                "searchKey": "template.TestIssue43065",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue43065(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue43065(t *testing.T)\n```\n\nIssue 43065, range over send only channel \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestIssue39807",
              "documentation": {
                "identifier": "TestIssue39807",
                "newPage": false,
                "searchKey": "template.TestIssue39807",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue39807(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue39807(t *testing.T)\n```\n\nIssue 39807: data race in html/template & text/template \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestMultiParse",
              "documentation": {
                "identifier": "TestMultiParse",
                "newPage": false,
                "searchKey": "template.TestMultiParse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMultiParse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMultiParse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestMultiExecute",
              "documentation": {
                "identifier": "TestMultiExecute",
                "newPage": false,
                "searchKey": "template.TestMultiExecute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMultiExecute(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMultiExecute(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestParseFiles",
              "documentation": {
                "identifier": "TestParseFiles",
                "newPage": false,
                "searchKey": "template.TestParseFiles",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseFiles(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseFiles(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestParseGlob",
              "documentation": {
                "identifier": "TestParseGlob",
                "newPage": false,
                "searchKey": "template.TestParseGlob",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseGlob(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseGlob(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestParseFS",
              "documentation": {
                "identifier": "TestParseFS",
                "newPage": false,
                "searchKey": "template.TestParseFS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseFS(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseFS(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestParseFilesWithData",
              "documentation": {
                "identifier": "TestParseFilesWithData",
                "newPage": false,
                "searchKey": "template.TestParseFilesWithData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseFilesWithData(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseFilesWithData(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestParseGlobWithData",
              "documentation": {
                "identifier": "TestParseGlobWithData",
                "newPage": false,
                "searchKey": "template.TestParseGlobWithData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseGlobWithData(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseGlobWithData(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestClone",
              "documentation": {
                "identifier": "TestClone",
                "newPage": false,
                "searchKey": "template.TestClone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestClone(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestClone(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestAddParseTree",
              "documentation": {
                "identifier": "TestAddParseTree",
                "newPage": false,
                "searchKey": "template.TestAddParseTree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAddParseTree(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAddParseTree(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestAddParseTreeToUnparsedTemplate",
              "documentation": {
                "identifier": "TestAddParseTreeToUnparsedTemplate",
                "newPage": false,
                "searchKey": "template.TestAddParseTreeToUnparsedTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAddParseTreeToUnparsedTemplate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAddParseTreeToUnparsedTemplate(t *testing.T)\n```\n\nIssue 7032 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestRedefinition",
              "documentation": {
                "identifier": "TestRedefinition",
                "newPage": false,
                "searchKey": "template.TestRedefinition",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRedefinition(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRedefinition(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestEmptyTemplateCloneCrash",
              "documentation": {
                "identifier": "TestEmptyTemplateCloneCrash",
                "newPage": false,
                "searchKey": "template.TestEmptyTemplateCloneCrash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEmptyTemplateCloneCrash(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEmptyTemplateCloneCrash(t *testing.T)\n```\n\nIssue 10879 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestTemplateLookUp",
              "documentation": {
                "identifier": "TestTemplateLookUp",
                "newPage": false,
                "searchKey": "template.TestTemplateLookUp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTemplateLookUp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTemplateLookUp(t *testing.T)\n```\n\nIssue 10910, 10926 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestNew",
              "documentation": {
                "identifier": "TestNew",
                "newPage": false,
                "searchKey": "template.TestNew",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNew(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNew(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestParse",
              "documentation": {
                "identifier": "TestParse",
                "newPage": false,
                "searchKey": "template.TestParse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestEmptyTemplate",
              "documentation": {
                "identifier": "TestEmptyTemplate",
                "newPage": false,
                "searchKey": "template.TestEmptyTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEmptyTemplate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEmptyTemplate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/text/template#TestIssue19294",
              "documentation": {
                "identifier": "TestIssue19294",
                "newPage": false,
                "searchKey": "template.TestIssue19294",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue19294(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue19294(t *testing.T)\n```\n\nIssue 19249 was a regression in 1.8 caused by the handling of empty templates added in that release, which got different answers depending on the order templates appeared in the internal map. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/std/text/template/parse"
    }
  ]
}
