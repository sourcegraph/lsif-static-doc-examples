{
  "pathID": "/std/net",
  "documentation": {
    "identifier": "net",
    "newPage": true,
    "searchKey": "std/net",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package net"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets. \n\nAlthough the package provides access to low-level networking primitives, most clients will need only the basic interface provided by the Dial, Listen, and Accept functions and the associated Conn and Listener interfaces. The crypto/tls package uses the same interfaces and similar Dial and Listen functions. \n\nThe Dial function connects to a server: \n\n```\nconn, err := net.Dial(\"tcp\", \"golang.org:80\")\nif err != nil {\n\t// handle error\n}\nfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\nstatus, err := bufio.NewReader(conn).ReadString('\\n')\n// ...\n\n```\nThe Listen function creates servers: \n\n```\nln, err := net.Listen(\"tcp\", \":8080\")\nif err != nil {\n\t// handle error\n}\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\t// handle error\n\t}\n\tgo handleConnection(conn)\n}\n\n```\n### hdr-Name_ResolutionName Resolution\nThe method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system. \n\nOn Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo. \n\nBy default the pure Go resolver is used, because a blocked DNS request consumes only a goroutine, while a blocked C call consumes an operating system thread. When cgo is available, the cgo-based resolver is used instead under a variety of conditions: on systems that do not let programs make direct DNS requests (OS X), when the LOCALDOMAIN environment variable is present (even if empty), when the RES_OPTIONS or HOSTALIASES environment variable is non-empty, when the ASR_CONFIG environment variable is non-empty (OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the Go resolver does not implement, and when the name being looked up ends in .local or is an mDNS name. \n\nThe resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in: \n\n```\nexport GODEBUG=netdns=go    # force pure Go resolver\nexport GODEBUG=netdns=cgo   # force cgo resolver\n\n```\nThe decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag. \n\nA numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print debugging information about its decisions. To force a particular resolver while also printing debugging information, join the two settings by a plus sign, as in GODEBUG=netdns=go+1. \n\nOn Plan 9, the resolver always accesses /net/cs and /net/dns. \n\nOn Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery. \n\n"
  },
  "children": [
    {
      "pathID": "/std/net/internal"
    },
    {
      "node": {
        "pathID": "/std/net#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/net#scopeInterfaceLocal",
              "documentation": {
                "identifier": "scopeInterfaceLocal",
                "newPage": false,
                "searchKey": "net.scopeInterfaceLocal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scopeInterfaceLocal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scopeInterfaceLocal scope = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#scopeLinkLocal",
              "documentation": {
                "identifier": "scopeLinkLocal",
                "newPage": false,
                "searchKey": "net.scopeLinkLocal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scopeLinkLocal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scopeLinkLocal scope = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#scopeAdminLocal",
              "documentation": {
                "identifier": "scopeAdminLocal",
                "newPage": false,
                "searchKey": "net.scopeAdminLocal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scopeAdminLocal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scopeAdminLocal scope = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#scopeSiteLocal",
              "documentation": {
                "identifier": "scopeSiteLocal",
                "newPage": false,
                "searchKey": "net.scopeSiteLocal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scopeSiteLocal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scopeSiteLocal scope = 0x5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#scopeOrgLocal",
              "documentation": {
                "identifier": "scopeOrgLocal",
                "newPage": false,
                "searchKey": "net.scopeOrgLocal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scopeOrgLocal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scopeOrgLocal scope = 0x8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#scopeGlobal",
              "documentation": {
                "identifier": "scopeGlobal",
                "newPage": false,
                "searchKey": "net.scopeGlobal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scopeGlobal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scopeGlobal scope = 0xe\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#defaultTCPKeepAlive",
              "documentation": {
                "identifier": "defaultTCPKeepAlive",
                "newPage": false,
                "searchKey": "net.defaultTCPKeepAlive",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const defaultTCPKeepAlive"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst defaultTCPKeepAlive = 15 * time.Second\n```\n\ndefaultTCPKeepAlive is a default constant value for TCPKeepAlive times See golang.org/issue/31510 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#useTCPOnly",
              "documentation": {
                "identifier": "useTCPOnly",
                "newPage": false,
                "searchKey": "net.useTCPOnly",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const useTCPOnly"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst useTCPOnly = true\n```\n\nto be used as a useTCP parameter to exchange \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#useUDPOrTCP",
              "documentation": {
                "identifier": "useUDPOrTCP",
                "newPage": false,
                "searchKey": "net.useUDPOrTCP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const useUDPOrTCP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst useUDPOrTCP = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hostLookupCgo",
              "documentation": {
                "identifier": "hostLookupCgo",
                "newPage": false,
                "searchKey": "net.hostLookupCgo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hostLookupCgo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hostLookupCgo hostLookupOrder = iota\n```\n\nhostLookupCgo means defer to cgo. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hostLookupFilesDNS",
              "documentation": {
                "identifier": "hostLookupFilesDNS",
                "newPage": false,
                "searchKey": "net.hostLookupFilesDNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hostLookupFilesDNS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hostLookupFilesDNS // files first\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hostLookupDNSFiles",
              "documentation": {
                "identifier": "hostLookupDNSFiles",
                "newPage": false,
                "searchKey": "net.hostLookupDNSFiles",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hostLookupDNSFiles"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hostLookupDNSFiles // dns first\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hostLookupFiles",
              "documentation": {
                "identifier": "hostLookupFiles",
                "newPage": false,
                "searchKey": "net.hostLookupFiles",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hostLookupFiles"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hostLookupFiles // only files\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hostLookupDNS",
              "documentation": {
                "identifier": "hostLookupDNS",
                "newPage": false,
                "searchKey": "net.hostLookupDNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hostLookupDNS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hostLookupDNS // only DNS\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readSyscallName",
              "documentation": {
                "identifier": "readSyscallName",
                "newPage": false,
                "searchKey": "net.readSyscallName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const readSyscallName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst readSyscallName = \"read\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readFromSyscallName",
              "documentation": {
                "identifier": "readFromSyscallName",
                "newPage": false,
                "searchKey": "net.readFromSyscallName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const readFromSyscallName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst readFromSyscallName = \"recvfrom\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readMsgSyscallName",
              "documentation": {
                "identifier": "readMsgSyscallName",
                "newPage": false,
                "searchKey": "net.readMsgSyscallName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const readMsgSyscallName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst readMsgSyscallName = \"recvmsg\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#writeSyscallName",
              "documentation": {
                "identifier": "writeSyscallName",
                "newPage": false,
                "searchKey": "net.writeSyscallName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const writeSyscallName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst writeSyscallName = \"write\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#writeToSyscallName",
              "documentation": {
                "identifier": "writeToSyscallName",
                "newPage": false,
                "searchKey": "net.writeToSyscallName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const writeToSyscallName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst writeToSyscallName = \"sendto\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#writeMsgSyscallName",
              "documentation": {
                "identifier": "writeMsgSyscallName",
                "newPage": false,
                "searchKey": "net.writeMsgSyscallName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const writeMsgSyscallName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst writeMsgSyscallName = \"sendmsg\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cacheMaxAge",
              "documentation": {
                "identifier": "cacheMaxAge",
                "newPage": false,
                "searchKey": "net.cacheMaxAge",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cacheMaxAge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cacheMaxAge = 5 * time.Second\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#FlagUp",
              "documentation": {
                "identifier": "FlagUp",
                "newPage": false,
                "searchKey": "net.FlagUp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FlagUp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FlagUp Flags = 1 << iota // interface is up\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#FlagBroadcast",
              "documentation": {
                "identifier": "FlagBroadcast",
                "newPage": false,
                "searchKey": "net.FlagBroadcast",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FlagBroadcast"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FlagBroadcast // interface supports broadcast access capability\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#FlagLoopback",
              "documentation": {
                "identifier": "FlagLoopback",
                "newPage": false,
                "searchKey": "net.FlagLoopback",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FlagLoopback"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FlagLoopback // interface is a loopback interface\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#FlagPointToPoint",
              "documentation": {
                "identifier": "FlagPointToPoint",
                "newPage": false,
                "searchKey": "net.FlagPointToPoint",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FlagPointToPoint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FlagPointToPoint // interface belongs to a point-to-point link\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#FlagMulticast",
              "documentation": {
                "identifier": "FlagMulticast",
                "newPage": false,
                "searchKey": "net.FlagMulticast",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FlagMulticast"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FlagMulticast // interface supports multicast access capability\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv4len",
              "documentation": {
                "identifier": "IPv4len",
                "newPage": false,
                "searchKey": "net.IPv4len",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const IPv4len"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IPv4len = 4\n```\n\nIP address lengths (bytes). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv6len",
              "documentation": {
                "identifier": "IPv6len",
                "newPage": false,
                "searchKey": "net.IPv6len",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const IPv6len"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IPv6len = 16\n```\n\nIP address lengths (bytes). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#maxProtoLength",
              "documentation": {
                "identifier": "maxProtoLength",
                "newPage": false,
                "searchKey": "net.maxProtoLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxProtoLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxProtoLength = len(\"RSVP-E2E-IGNORE\") + 10 // with room to grow\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#maxPortBufSize",
              "documentation": {
                "identifier": "maxPortBufSize",
                "newPage": false,
                "searchKey": "net.maxPortBufSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxPortBufSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxPortBufSize = len(\"mobility-header\") + 10\n```\n\nmaxPortBufSize is the longest reasonable name of a service (non-numeric port). Currently the longest known IANA-unregistered name is \"mobility-header\", so we use that length, plus some slop in case something longer is added in the future. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hexDigit",
              "documentation": {
                "identifier": "hexDigit",
                "newPage": false,
                "searchKey": "net.hexDigit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hexDigit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hexDigit = \"0123456789abcdef\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#big",
              "documentation": {
                "identifier": "big",
                "newPage": false,
                "searchKey": "net.big",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const big"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst big = 0xFFFFFF\n```\n\nBigger than we need, not too big to worry about overflow \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#sysTCP_KEEPINTVL",
              "documentation": {
                "identifier": "sysTCP_KEEPINTVL",
                "newPage": false,
                "searchKey": "net.sysTCP_KEEPINTVL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sysTCP_KEEPINTVL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sysTCP_KEEPINTVL = 0x101\n```\n\nsyscall.TCP_KEEPINTVL is missing on some darwin architectures. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readMsgFlags",
              "documentation": {
                "identifier": "readMsgFlags",
                "newPage": false,
                "searchKey": "net.readMsgFlags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const readMsgFlags"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst readMsgFlags = 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#someTimeout",
              "documentation": {
                "identifier": "someTimeout",
                "newPage": false,
                "searchKey": "net.someTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const someTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst someTimeout = 10 * time.Second\n```\n\nsomeTimeout is used just to test that net.Conn implementations don't explode when their SetFooDeadline methods are called. It isn't actually used for testing timeouts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#slowDst4",
              "documentation": {
                "identifier": "slowDst4",
                "newPage": false,
                "searchKey": "net.slowDst4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const slowDst4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst slowDst4 = \"198.18.0.254\"\n```\n\nDefine a pair of blackholed (IPv4, IPv6) addresses, for which dialTCP is expected to hang until the timeout elapses. These addresses are reserved for benchmarking by RFC 6890. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#slowDst6",
              "documentation": {
                "identifier": "slowDst6",
                "newPage": false,
                "searchKey": "net.slowDst6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const slowDst6"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst slowDst6 = \"2001:2::254\"\n```\n\nDefine a pair of blackholed (IPv4, IPv6) addresses, for which dialTCP is expected to hang until the timeout elapses. These addresses are reserved for benchmarking by RFC 6890. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ubuntuTrustyAvahi",
              "documentation": {
                "identifier": "ubuntuTrustyAvahi",
                "newPage": false,
                "searchKey": "net.ubuntuTrustyAvahi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ubuntuTrustyAvahi"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ubuntuTrustyAvahi = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#newton",
              "documentation": {
                "identifier": "newton",
                "newPage": false,
                "searchKey": "net.newton",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const newton"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst newton = \"../testdata/Isaac.Newton-Opticks.txt\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#newtonLen",
              "documentation": {
                "identifier": "newtonLen",
                "newPage": false,
                "searchKey": "net.newtonLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const newtonLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst newtonLen = 567198\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#newtonSHA256",
              "documentation": {
                "identifier": "newtonSHA256",
                "newPage": false,
                "searchKey": "net.newtonSHA256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const newtonSHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst newtonSHA256 = \"d4a9ac22462b35e7821a4f2706c211093da678620a8f9997989ee7cf8d507bbd\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoAddrInfoFlags",
              "documentation": {
                "identifier": "cgoAddrInfoFlags",
                "newPage": false,
                "searchKey": "net.cgoAddrInfoFlags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cgoAddrInfoFlags"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cgoAddrInfoFlags = (C.AI_CANONNAME | C.AI_V4MAPPED | C.AI_ALL) & C.AI_MASK\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#nameinfoLen",
              "documentation": {
                "identifier": "nameinfoLen",
                "newPage": false,
                "searchKey": "net.nameinfoLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const nameinfoLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst nameinfoLen = 64\n```\n\nThese are roughly enough for the following: \n\nSource\t\tEncoding\t\t\tMaximum length of single name entry Unicast DNS\t\tASCII or\t\t\t<=253 + a NUL terminator \n\n```\nUnicode in RFC 5892\t\t252 * total number of labels + delimiters + a NUL terminator\n\n```\nMulticast DNS\tUTF-8 in RFC 5198 or\t\t<=253 + a NUL terminator \n\n```\nthe same as unicast DNS ASCII\t<=253 + a NUL terminator\n\n```\nLocal database\tvarious\t\t\t\tdepends on implementation \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#maxNameinfoLen",
              "documentation": {
                "identifier": "maxNameinfoLen",
                "newPage": false,
                "searchKey": "net.maxNameinfoLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxNameinfoLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxNameinfoLen = 4096\n```\n\nThese are roughly enough for the following: \n\nSource\t\tEncoding\t\t\tMaximum length of single name entry Unicast DNS\t\tASCII or\t\t\t<=253 + a NUL terminator \n\n```\nUnicode in RFC 5892\t\t252 * total number of labels + delimiters + a NUL terminator\n\n```\nMulticast DNS\tUTF-8 in RFC 5198 or\t\t<=253 + a NUL terminator \n\n```\nthe same as unicast DNS ASCII\t<=253 + a NUL terminator\n\n```\nLocal database\tvarious\t\t\t\tdepends on implementation \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/net#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/net#rfc6724policyTable",
              "documentation": {
                "identifier": "rfc6724policyTable",
                "newPage": false,
                "searchKey": "net.rfc6724policyTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var rfc6724policyTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar rfc6724policyTable = ...\n```\n\nRFC 6724 section 2.1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#confOnce",
              "documentation": {
                "identifier": "confOnce",
                "newPage": false,
                "searchKey": "net.confOnce",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var confOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar confOnce sync.Once // guards init of confVal via initConfVal\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#confVal",
              "documentation": {
                "identifier": "confVal",
                "newPage": false,
                "searchKey": "net.confVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var confVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar confVal = &conf{goos: runtime.GOOS}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errLameReferral",
              "documentation": {
                "identifier": "errLameReferral",
                "newPage": false,
                "searchKey": "net.errLameReferral",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errLameReferral"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errLameReferral = errors.New(\"lame referral\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errCannotUnmarshalDNSMessage",
              "documentation": {
                "identifier": "errCannotUnmarshalDNSMessage",
                "newPage": false,
                "searchKey": "net.errCannotUnmarshalDNSMessage",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errCannotUnmarshalDNSMessage"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errCannotUnmarshalDNSMessage = errors.New(\"cannot unmarshal DNS message\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errCannotMarshalDNSMessage",
              "documentation": {
                "identifier": "errCannotMarshalDNSMessage",
                "newPage": false,
                "searchKey": "net.errCannotMarshalDNSMessage",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errCannotMarshalDNSMessage"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errCannotMarshalDNSMessage = errors.New(\"cannot marshal DNS message\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errServerMisbehaving",
              "documentation": {
                "identifier": "errServerMisbehaving",
                "newPage": false,
                "searchKey": "net.errServerMisbehaving",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errServerMisbehaving"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errServerMisbehaving = errors.New(\"server misbehaving\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errInvalidDNSResponse",
              "documentation": {
                "identifier": "errInvalidDNSResponse",
                "newPage": false,
                "searchKey": "net.errInvalidDNSResponse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errInvalidDNSResponse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errInvalidDNSResponse = errors.New(\"invalid DNS response\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errNoAnswerFromDNSServer",
              "documentation": {
                "identifier": "errNoAnswerFromDNSServer",
                "newPage": false,
                "searchKey": "net.errNoAnswerFromDNSServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNoAnswerFromDNSServer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNoAnswerFromDNSServer = errors.New(\"no answer from DNS server\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errServerTemporarilyMisbehaving",
              "documentation": {
                "identifier": "errServerTemporarilyMisbehaving",
                "newPage": false,
                "searchKey": "net.errServerTemporarilyMisbehaving",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errServerTemporarilyMisbehaving"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errServerTemporarilyMisbehaving = errors.New(\"server misbehaving\")\n```\n\nerrServerTemporarilyMisbehaving is like errServerMisbehaving, except that when it gets translated to a DNSError, the IsTemporary field gets set to true. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#resolvConf",
              "documentation": {
                "identifier": "resolvConf",
                "newPage": false,
                "searchKey": "net.resolvConf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var resolvConf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar resolvConf resolverConfig\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupOrderName",
              "documentation": {
                "identifier": "lookupOrderName",
                "newPage": false,
                "searchKey": "net.lookupOrderName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupOrderName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupOrderName = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#defaultNS",
              "documentation": {
                "identifier": "defaultNS",
                "newPage": false,
                "searchKey": "net.defaultNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultNS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultNS = []string{\"127.0.0.1:53\", \"[::1]:53\"}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#getHostname",
              "documentation": {
                "identifier": "getHostname",
                "newPage": false,
                "searchKey": "net.getHostname",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var getHostname"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar getHostname = os.Hostname // variable for testing\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testHookDialTCP",
              "documentation": {
                "identifier": "testHookDialTCP",
                "newPage": false,
                "searchKey": "net.testHookDialTCP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookDialTCP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookDialTCP func(ctx context.Context, net string, laddr, raddr *TCPAddr) (*TCPConn, error)\n```\n\nif non-nil, overrides dialTCP. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testHookHostsPath",
              "documentation": {
                "identifier": "testHookHostsPath",
                "newPage": false,
                "searchKey": "net.testHookHostsPath",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookHostsPath"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookHostsPath = \"/etc/hosts\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testHookLookupIP",
              "documentation": {
                "identifier": "testHookLookupIP",
                "newPage": false,
                "searchKey": "net.testHookLookupIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookLookupIP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookLookupIP = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testHookSetKeepAlive",
              "documentation": {
                "identifier": "testHookSetKeepAlive",
                "newPage": false,
                "searchKey": "net.testHookSetKeepAlive",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookSetKeepAlive"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookSetKeepAlive = func(time.Duration) {}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testHookDialChannel",
              "documentation": {
                "identifier": "testHookDialChannel",
                "newPage": false,
                "searchKey": "net.testHookDialChannel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookDialChannel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookDialChannel = func() {} // for golang.org/issue/5349\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testHookCanceledDial",
              "documentation": {
                "identifier": "testHookCanceledDial",
                "newPage": false,
                "searchKey": "net.testHookCanceledDial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookCanceledDial"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookCanceledDial = func() {} // for golang.org/issue/16523\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#socketFunc",
              "documentation": {
                "identifier": "socketFunc",
                "newPage": false,
                "searchKey": "net.socketFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var socketFunc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar socketFunc func(int, int, int) (int, error) = syscall.Socket\n```\n\nPlaceholders for socket system calls. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#connectFunc",
              "documentation": {
                "identifier": "connectFunc",
                "newPage": false,
                "searchKey": "net.connectFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var connectFunc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar connectFunc func(int, syscall.Sockaddr) error = syscall.Connect\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#listenFunc",
              "documentation": {
                "identifier": "listenFunc",
                "newPage": false,
                "searchKey": "net.listenFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var listenFunc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar listenFunc func(int, int) error = syscall.Listen\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#getsockoptIntFunc",
              "documentation": {
                "identifier": "getsockoptIntFunc",
                "newPage": false,
                "searchKey": "net.getsockoptIntFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var getsockoptIntFunc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar getsockoptIntFunc func(int, int, int) (int, error) = syscall.GetsockoptInt\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hosts",
              "documentation": {
                "identifier": "hosts",
                "newPage": false,
                "searchKey": "net.hosts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var hosts"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hosts struct {\n\tsync.Mutex\n\n\t// Key for the list of literal IP addresses must be a host\n\t// name. It would be part of DNS labels, a FQDN or an absolute\n\t// FQDN.\n\t// For now the key is converted to lower case for convenience.\n\tbyName map[string][]string\n\n\t// Key for the list of host names must be a literal IP address\n\t// including IPv6 address with zone identifier.\n\t// We don't support old-classful IP address notation.\n\tbyAddr map[string][]string\n\n\texpire time.Time\n\tpath   string\n\tmtime  time.Time\n\tsize   int64\n} = ...\n```\n\nhosts contains known host entries. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errInvalidInterface",
              "documentation": {
                "identifier": "errInvalidInterface",
                "newPage": false,
                "searchKey": "net.errInvalidInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errInvalidInterface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errInvalidInterface = errors.New(\"invalid network interface\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errInvalidInterfaceIndex",
              "documentation": {
                "identifier": "errInvalidInterfaceIndex",
                "newPage": false,
                "searchKey": "net.errInvalidInterfaceIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errInvalidInterfaceIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errInvalidInterfaceIndex = errors.New(\"invalid network interface index\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errInvalidInterfaceName",
              "documentation": {
                "identifier": "errInvalidInterfaceName",
                "newPage": false,
                "searchKey": "net.errInvalidInterfaceName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errInvalidInterfaceName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errInvalidInterfaceName = errors.New(\"invalid network interface name\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errNoSuchInterface",
              "documentation": {
                "identifier": "errNoSuchInterface",
                "newPage": false,
                "searchKey": "net.errNoSuchInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNoSuchInterface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNoSuchInterface = errors.New(\"no such network interface\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errNoSuchMulticastInterface",
              "documentation": {
                "identifier": "errNoSuchMulticastInterface",
                "newPage": false,
                "searchKey": "net.errNoSuchMulticastInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNoSuchMulticastInterface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNoSuchMulticastInterface = errors.New(\"no such multicast network interface\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#flagNames",
              "documentation": {
                "identifier": "flagNames",
                "newPage": false,
                "searchKey": "net.flagNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var flagNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar flagNames = []string{\n\t\"up\",\n\t\"broadcast\",\n\t\"loopback\",\n\t\"pointtopoint\",\n\t\"multicast\",\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#zoneCache",
              "documentation": {
                "identifier": "zoneCache",
                "newPage": false,
                "searchKey": "net.zoneCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var zoneCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zoneCache = ipv6ZoneCache{\n\ttoIndex: make(map[string]int),\n\ttoName:  make(map[int]string),\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#v4InV6Prefix",
              "documentation": {
                "identifier": "v4InV6Prefix",
                "newPage": false,
                "searchKey": "net.v4InV6Prefix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var v4InV6Prefix"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar v4InV6Prefix = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv4bcast",
              "documentation": {
                "identifier": "IPv4bcast",
                "newPage": false,
                "searchKey": "net.IPv4bcast",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv4bcast"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv4bcast = IPv4(255, 255, 255, 255) // limited broadcast\n\n```\n\nWell-known IPv4 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv4allsys",
              "documentation": {
                "identifier": "IPv4allsys",
                "newPage": false,
                "searchKey": "net.IPv4allsys",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv4allsys"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv4allsys = IPv4(224, 0, 0, 1) // all systems\n\n```\n\nWell-known IPv4 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv4allrouter",
              "documentation": {
                "identifier": "IPv4allrouter",
                "newPage": false,
                "searchKey": "net.IPv4allrouter",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv4allrouter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv4allrouter = IPv4(224, 0, 0, 2) // all routers\n\n```\n\nWell-known IPv4 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv4zero",
              "documentation": {
                "identifier": "IPv4zero",
                "newPage": false,
                "searchKey": "net.IPv4zero",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv4zero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv4zero = IPv4(0, 0, 0, 0) // all zeros\n\n```\n\nWell-known IPv4 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv6zero",
              "documentation": {
                "identifier": "IPv6zero",
                "newPage": false,
                "searchKey": "net.IPv6zero",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv6zero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv6zero = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n```\n\nWell-known IPv6 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv6unspecified",
              "documentation": {
                "identifier": "IPv6unspecified",
                "newPage": false,
                "searchKey": "net.IPv6unspecified",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv6unspecified"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv6unspecified = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n```\n\nWell-known IPv6 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv6loopback",
              "documentation": {
                "identifier": "IPv6loopback",
                "newPage": false,
                "searchKey": "net.IPv6loopback",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv6loopback"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv6loopback = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}\n```\n\nWell-known IPv6 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv6interfacelocalallnodes",
              "documentation": {
                "identifier": "IPv6interfacelocalallnodes",
                "newPage": false,
                "searchKey": "net.IPv6interfacelocalallnodes",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv6interfacelocalallnodes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv6interfacelocalallnodes = IP{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}\n```\n\nWell-known IPv6 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv6linklocalallnodes",
              "documentation": {
                "identifier": "IPv6linklocalallnodes",
                "newPage": false,
                "searchKey": "net.IPv6linklocalallnodes",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv6linklocalallnodes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv6linklocalallnodes = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}\n```\n\nWell-known IPv6 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPv6linklocalallrouters",
              "documentation": {
                "identifier": "IPv6linklocalallrouters",
                "newPage": false,
                "searchKey": "net.IPv6linklocalallrouters",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var IPv6linklocalallrouters"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IPv6linklocalallrouters = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}\n```\n\nWell-known IPv6 addresses \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#classAMask",
              "documentation": {
                "identifier": "classAMask",
                "newPage": false,
                "searchKey": "net.classAMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var classAMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar classAMask = IPv4Mask(0xff, 0, 0, 0)\n```\n\nDefault route masks for IPv4. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#classBMask",
              "documentation": {
                "identifier": "classBMask",
                "newPage": false,
                "searchKey": "net.classBMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var classBMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar classBMask = IPv4Mask(0xff, 0xff, 0, 0)\n```\n\nDefault route masks for IPv4. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#classCMask",
              "documentation": {
                "identifier": "classCMask",
                "newPage": false,
                "searchKey": "net.classCMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var classCMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar classCMask = IPv4Mask(0xff, 0xff, 0xff, 0)\n```\n\nDefault route masks for IPv4. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipStackCaps",
              "documentation": {
                "identifier": "ipStackCaps",
                "newPage": false,
                "searchKey": "net.ipStackCaps",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipStackCaps"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipStackCaps ipStackCapabilities\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#protocols",
              "documentation": {
                "identifier": "protocols",
                "newPage": false,
                "searchKey": "net.protocols",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var protocols"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar protocols = ...\n```\n\nprotocols contains minimal mappings between internet protocol names and numbers for platforms that don't have a complete list of protocol numbers. \n\nSee [https://www.iana.org/assignments/protocol-numbers](https://www.iana.org/assignments/protocol-numbers) \n\nOn Unix, this map is augmented by readProtocols via lookupProtocol. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#services",
              "documentation": {
                "identifier": "services",
                "newPage": false,
                "searchKey": "net.services",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var services"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar services = ...\n```\n\nservices contains minimal mappings between services names and port numbers for platforms that don't have a complete list of port numbers. \n\nSee [https://www.iana.org/assignments/service-names-port-numbers](https://www.iana.org/assignments/service-names-port-numbers) \n\nOn Unix, this map is augmented by readServices via goLookupPort. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsWaitGroup",
              "documentation": {
                "identifier": "dnsWaitGroup",
                "newPage": false,
                "searchKey": "net.dnsWaitGroup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dnsWaitGroup"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dnsWaitGroup sync.WaitGroup\n```\n\ndnsWaitGroup can be used by tests to wait for all DNS goroutines to complete. This avoids races on the test hooks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#DefaultResolver",
              "documentation": {
                "identifier": "DefaultResolver",
                "newPage": false,
                "searchKey": "net.DefaultResolver",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var DefaultResolver"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar DefaultResolver = &Resolver{}\n```\n\nDefaultResolver is the resolver used by the package-level Lookup functions and by Dialers without a specified Resolver. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#onceReadProtocols",
              "documentation": {
                "identifier": "onceReadProtocols",
                "newPage": false,
                "searchKey": "net.onceReadProtocols",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var onceReadProtocols"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar onceReadProtocols sync.Once\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#netGo",
              "documentation": {
                "identifier": "netGo",
                "newPage": false,
                "searchKey": "net.netGo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var netGo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar netGo bool // set true in cgo_stub.go for build tag \"netgo\" (or no cgo)\n\n```\n\nnetGo and netCgo contain the state of the build tags used to build this binary, and whether cgo is available. conf.go mirrors these into conf for easier testing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#netCgo",
              "documentation": {
                "identifier": "netCgo",
                "newPage": false,
                "searchKey": "net.netCgo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var netCgo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar netCgo bool // set true in conf_netcgo.go for build tag \"netcgo\"\n\n```\n\nnetGo and netCgo contain the state of the build tags used to build this binary, and whether cgo is available. conf.go mirrors these into conf for easier testing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#listenerBacklogCache",
              "documentation": {
                "identifier": "listenerBacklogCache",
                "newPage": false,
                "searchKey": "net.listenerBacklogCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var listenerBacklogCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar listenerBacklogCache struct {\n\tsync.Once\n\tval int\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errNoSuitableAddress",
              "documentation": {
                "identifier": "errNoSuitableAddress",
                "newPage": false,
                "searchKey": "net.errNoSuitableAddress",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNoSuitableAddress"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNoSuitableAddress = errors.New(\"no suitable address found\")\n```\n\nVarious errors contained in OpError. \n\nFor connection setup operations. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errMissingAddress",
              "documentation": {
                "identifier": "errMissingAddress",
                "newPage": false,
                "searchKey": "net.errMissingAddress",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errMissingAddress"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errMissingAddress = errors.New(\"missing address\")\n```\n\nVarious errors contained in OpError. \n\nFor connection setup and write operations. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errCanceled",
              "documentation": {
                "identifier": "errCanceled",
                "newPage": false,
                "searchKey": "net.errCanceled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errCanceled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errCanceled = errors.New(\"operation was canceled\")\n```\n\nVarious errors contained in OpError. \n\nFor both read and write operations. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ErrWriteToConnected",
              "documentation": {
                "identifier": "ErrWriteToConnected",
                "newPage": false,
                "searchKey": "net.ErrWriteToConnected",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrWriteToConnected"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrWriteToConnected = errors.New(\"use of WriteTo with pre-connected connection\")\n```\n\nVarious errors contained in OpError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#aLongTimeAgo",
              "documentation": {
                "identifier": "aLongTimeAgo",
                "newPage": false,
                "searchKey": "net.aLongTimeAgo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var aLongTimeAgo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar aLongTimeAgo = time.Unix(1, 0)\n```\n\naLongTimeAgo is a non-zero time, far in the past, used for immediate cancellation of dials. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#noDeadline",
              "documentation": {
                "identifier": "noDeadline",
                "newPage": false,
                "searchKey": "net.noDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var noDeadline"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar noDeadline = time.Time{}\n```\n\nnonDeadline and noCancel are just zero values for readability with functions taking too many parameters. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#noCancel",
              "documentation": {
                "identifier": "noCancel",
                "newPage": false,
                "searchKey": "net.noCancel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var noCancel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar noCancel = (chan struct{})(nil)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errTimeout",
              "documentation": {
                "identifier": "errTimeout",
                "newPage": false,
                "searchKey": "net.errTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errTimeout error = &timeoutError{}\n```\n\nerrTimeout exists to return the historical \"i/o timeout\" string for context.DeadlineExceeded. See mapErr. It is also used when Dialer.Deadline is exceeded. \n\nTODO(iant): We could consider changing this to os.ErrDeadlineExceeded in the future, but note that that would conflict with the TODO at mapErr that suggests changing it to context.DeadlineExceeded. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errNoSuchHost",
              "documentation": {
                "identifier": "errNoSuchHost",
                "newPage": false,
                "searchKey": "net.errNoSuchHost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNoSuchHost"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNoSuchHost = errors.New(\"no such host\")\n```\n\nVarious errors contained in DNSError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errClosed",
              "documentation": {
                "identifier": "errClosed",
                "newPage": false,
                "searchKey": "net.errClosed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errClosed = poll.ErrNetClosing\n```\n\nerrClosed exists just so that the docs for ErrClosed don't mention the internal package poll. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ErrClosed",
              "documentation": {
                "identifier": "ErrClosed",
                "newPage": false,
                "searchKey": "net.ErrClosed",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrClosed error = errClosed\n```\n\nErrClosed is the error returned by an I/O call on a network connection that has already been closed, or that is closed by another goroutine before the I/O is completed. This may be wrapped in another error, and should normally be tested using errors.Is(err, net.ErrClosed). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#threadLimit",
              "documentation": {
                "identifier": "threadLimit",
                "newPage": false,
                "searchKey": "net.threadLimit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var threadLimit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar threadLimit chan struct{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#threadOnce",
              "documentation": {
                "identifier": "threadOnce",
                "newPage": false,
                "searchKey": "net.threadOnce",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var threadOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar threadOnce sync.Once\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#onceReadServices",
              "documentation": {
                "identifier": "onceReadServices",
                "newPage": false,
                "searchKey": "net.onceReadServices",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var onceReadServices"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar onceReadServices sync.Once\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#defaultResolvConf",
              "documentation": {
                "identifier": "defaultResolvConf",
                "newPage": false,
                "searchKey": "net.defaultResolvConf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultResolvConf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultResolvConf = ...\n```\n\nrepresents a dnsConfig returned by parsing a nonexistent resolv.conf \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#prohibitionaryDialArgTests",
              "documentation": {
                "identifier": "prohibitionaryDialArgTests",
                "newPage": false,
                "searchKey": "net.prohibitionaryDialArgTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var prohibitionaryDialArgTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar prohibitionaryDialArgTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#goResolver",
              "documentation": {
                "identifier": "goResolver",
                "newPage": false,
                "searchKey": "net.goResolver",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var goResolver"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar goResolver = Resolver{PreferGo: true}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAddr",
              "documentation": {
                "identifier": "TestAddr",
                "newPage": false,
                "searchKey": "net.TestAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var TestAddr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar TestAddr = [4]byte{0xc0, 0x00, 0x02, 0x01}\n```\n\nTest address from 192.0.2.0/24 block, reserved by RFC 5737 for documentation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAddr6",
              "documentation": {
                "identifier": "TestAddr6",
                "newPage": false,
                "searchKey": "net.TestAddr6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var TestAddr6"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar TestAddr6 = [16]byte{0x20, 0x01, 0x0d, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}\n```\n\nTest address from 2001:db8::/32 block, reserved by RFC 3849 for documentation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsTransportFallbackTests",
              "documentation": {
                "identifier": "dnsTransportFallbackTests",
                "newPage": false,
                "searchKey": "net.dnsTransportFallbackTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dnsTransportFallbackTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dnsTransportFallbackTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#specialDomainNameTests",
              "documentation": {
                "identifier": "specialDomainNameTests",
                "newPage": false,
                "searchKey": "net.specialDomainNameTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var specialDomainNameTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar specialDomainNameTests = ...\n```\n\nSee RFC 6761 for further information about the reserved, pseudo domain names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#fakeDNSServerSuccessful",
              "documentation": {
                "identifier": "fakeDNSServerSuccessful",
                "newPage": false,
                "searchKey": "net.fakeDNSServerSuccessful",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fakeDNSServerSuccessful"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fakeDNSServerSuccessful = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#updateResolvConfTests",
              "documentation": {
                "identifier": "updateResolvConfTests",
                "newPage": false,
                "searchKey": "net.updateResolvConfTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var updateResolvConfTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar updateResolvConfTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#goLookupIPWithResolverConfigTests",
              "documentation": {
                "identifier": "goLookupIPWithResolverConfigTests",
                "newPage": false,
                "searchKey": "net.goLookupIPWithResolverConfigTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var goLookupIPWithResolverConfigTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar goLookupIPWithResolverConfigTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsReadConfigTests",
              "documentation": {
                "identifier": "dnsReadConfigTests",
                "newPage": false,
                "searchKey": "net.dnsReadConfigTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dnsReadConfigTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dnsReadConfigTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsDefaultSearchTests",
              "documentation": {
                "identifier": "dnsDefaultSearchTests",
                "newPage": false,
                "searchKey": "net.dnsDefaultSearchTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dnsDefaultSearchTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dnsDefaultSearchTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsNameTests",
              "documentation": {
                "identifier": "dnsNameTests",
                "newPage": false,
                "searchKey": "net.dnsNameTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dnsNameTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dnsNameTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dialErrorTests",
              "documentation": {
                "identifier": "dialErrorTests",
                "newPage": false,
                "searchKey": "net.dialErrorTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dialErrorTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dialErrorTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#listenErrorTests",
              "documentation": {
                "identifier": "listenErrorTests",
                "newPage": false,
                "searchKey": "net.listenErrorTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var listenErrorTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar listenErrorTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#listenPacketErrorTests",
              "documentation": {
                "identifier": "listenPacketErrorTests",
                "newPage": false,
                "searchKey": "net.listenPacketErrorTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var listenPacketErrorTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar listenPacketErrorTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errTimedout",
              "documentation": {
                "identifier": "errTimedout",
                "newPage": false,
                "searchKey": "net.errTimedout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errTimedout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errTimedout = syscall.ETIMEDOUT\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#errOpNotSupported",
              "documentation": {
                "identifier": "errOpNotSupported",
                "newPage": false,
                "searchKey": "net.errOpNotSupported",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errOpNotSupported"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errOpNotSupported = syscall.EOPNOTSUPP\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#abortedConnRequestErrors",
              "documentation": {
                "identifier": "abortedConnRequestErrors",
                "newPage": false,
                "searchKey": "net.abortedConnRequestErrors",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var abortedConnRequestErrors"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar abortedConnRequestErrors = []error{syscall.ECONNABORTED} // see accept in fd_unix.go\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dialGoogleTests",
              "documentation": {
                "identifier": "dialGoogleTests",
                "newPage": false,
                "searchKey": "net.dialGoogleTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dialGoogleTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dialGoogleTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#literalAddrs4",
              "documentation": {
                "identifier": "literalAddrs4",
                "newPage": false,
                "searchKey": "net.literalAddrs4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var literalAddrs4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar literalAddrs4 = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#literalAddrs6",
              "documentation": {
                "identifier": "literalAddrs6",
                "newPage": false,
                "searchKey": "net.literalAddrs6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var literalAddrs6"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar literalAddrs6 = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#fileConnTests",
              "documentation": {
                "identifier": "fileConnTests",
                "newPage": false,
                "searchKey": "net.fileConnTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fileConnTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fileConnTests = []struct {\n\tnetwork string\n}{\n\t{\"tcp\"},\n\t{\"udp\"},\n\t{\"unix\"},\n\t{\"unixpacket\"},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#fileListenerTests",
              "documentation": {
                "identifier": "fileListenerTests",
                "newPage": false,
                "searchKey": "net.fileListenerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fileListenerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fileListenerTests = []struct {\n\tnetwork string\n}{\n\t{\"tcp\"},\n\t{\"unix\"},\n\t{\"unixpacket\"},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#filePacketConnTests",
              "documentation": {
                "identifier": "filePacketConnTests",
                "newPage": false,
                "searchKey": "net.filePacketConnTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var filePacketConnTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar filePacketConnTests = []struct {\n\tnetwork string\n}{\n\t{\"udp\"},\n\t{\"unixgram\"},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupStaticHostTests",
              "documentation": {
                "identifier": "lookupStaticHostTests",
                "newPage": false,
                "searchKey": "net.lookupStaticHostTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupStaticHostTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupStaticHostTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupStaticAddrTests",
              "documentation": {
                "identifier": "lookupStaticAddrTests",
                "newPage": false,
                "searchKey": "net.lookupStaticAddrTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupStaticAddrTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupStaticAddrTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseIPTests",
              "documentation": {
                "identifier": "parseIPTests",
                "newPage": false,
                "searchKey": "net.parseIPTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var parseIPTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar parseIPTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipStringTests",
              "documentation": {
                "identifier": "ipStringTests",
                "newPage": false,
                "searchKey": "net.ipStringTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipStringTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipStringTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#sink",
              "documentation": {
                "identifier": "sink",
                "newPage": false,
                "searchKey": "net.sink",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sink"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sink string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipMaskTests",
              "documentation": {
                "identifier": "ipMaskTests",
                "newPage": false,
                "searchKey": "net.ipMaskTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipMaskTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipMaskTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipMaskStringTests",
              "documentation": {
                "identifier": "ipMaskStringTests",
                "newPage": false,
                "searchKey": "net.ipMaskStringTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipMaskStringTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipMaskStringTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseCIDRTests",
              "documentation": {
                "identifier": "parseCIDRTests",
                "newPage": false,
                "searchKey": "net.parseCIDRTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var parseCIDRTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar parseCIDRTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipNetContainsTests",
              "documentation": {
                "identifier": "ipNetContainsTests",
                "newPage": false,
                "searchKey": "net.ipNetContainsTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipNetContainsTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipNetContainsTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipNetStringTests",
              "documentation": {
                "identifier": "ipNetStringTests",
                "newPage": false,
                "searchKey": "net.ipNetStringTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipNetStringTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipNetStringTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cidrMaskTests",
              "documentation": {
                "identifier": "cidrMaskTests",
                "newPage": false,
                "searchKey": "net.cidrMaskTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cidrMaskTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cidrMaskTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#v4addr",
              "documentation": {
                "identifier": "v4addr",
                "newPage": false,
                "searchKey": "net.v4addr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var v4addr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar v4addr = IP{192, 168, 0, 1}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#v4mappedv6addr",
              "documentation": {
                "identifier": "v4mappedv6addr",
                "newPage": false,
                "searchKey": "net.v4mappedv6addr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var v4mappedv6addr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar v4mappedv6addr = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 192, 168, 0, 1}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#v6addr",
              "documentation": {
                "identifier": "v6addr",
                "newPage": false,
                "searchKey": "net.v6addr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var v6addr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar v6addr = IP{0x20, 0x1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0x1, 0x23, 0, 0x12, 0, 0x1}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#v4mask",
              "documentation": {
                "identifier": "v4mask",
                "newPage": false,
                "searchKey": "net.v4mask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var v4mask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar v4mask = IPMask{255, 255, 255, 0}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#v4mappedv6mask",
              "documentation": {
                "identifier": "v4mappedv6mask",
                "newPage": false,
                "searchKey": "net.v4mappedv6mask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var v4mappedv6mask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar v4mappedv6mask = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#v6mask",
              "documentation": {
                "identifier": "v6mask",
                "newPage": false,
                "searchKey": "net.v6mask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var v6mask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar v6mask = IPMask{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#badaddr",
              "documentation": {
                "identifier": "badaddr",
                "newPage": false,
                "searchKey": "net.badaddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var badaddr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badaddr = IP{192, 168, 0}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#badmask",
              "documentation": {
                "identifier": "badmask",
                "newPage": false,
                "searchKey": "net.badmask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var badmask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badmask = IPMask{255, 255, 0}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#v4maskzero",
              "documentation": {
                "identifier": "v4maskzero",
                "newPage": false,
                "searchKey": "net.v4maskzero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var v4maskzero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar v4maskzero = IPMask{0, 0, 0, 0}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#networkNumberAndMaskTests",
              "documentation": {
                "identifier": "networkNumberAndMaskTests",
                "newPage": false,
                "searchKey": "net.networkNumberAndMaskTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var networkNumberAndMaskTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar networkNumberAndMaskTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipAddrFamilyTests",
              "documentation": {
                "identifier": "ipAddrFamilyTests",
                "newPage": false,
                "searchKey": "net.ipAddrFamilyTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipAddrFamilyTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipAddrFamilyTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipAddrScopeTests",
              "documentation": {
                "identifier": "ipAddrScopeTests",
                "newPage": false,
                "searchKey": "net.ipAddrScopeTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipAddrScopeTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipAddrScopeTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#resolveIPAddrTests",
              "documentation": {
                "identifier": "resolveIPAddrTests",
                "newPage": false,
                "searchKey": "net.resolveIPAddrTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var resolveIPAddrTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar resolveIPAddrTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipConnLocalNameTests",
              "documentation": {
                "identifier": "ipConnLocalNameTests",
                "newPage": false,
                "searchKey": "net.ipConnLocalNameTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipConnLocalNameTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipConnLocalNameTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testInetaddr",
              "documentation": {
                "identifier": "testInetaddr",
                "newPage": false,
                "searchKey": "net.testInetaddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testInetaddr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testInetaddr = func(ip IPAddr) Addr { return &TCPAddr{IP: ip.IP, Port: 5682, Zone: ip.Zone} }\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#addrListTests",
              "documentation": {
                "identifier": "addrListTests",
                "newPage": false,
                "searchKey": "net.addrListTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var addrListTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar addrListTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#tcpListenerTests",
              "documentation": {
                "identifier": "tcpListenerTests",
                "newPage": false,
                "searchKey": "net.tcpListenerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tcpListenerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tcpListenerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#udpListenerTests",
              "documentation": {
                "identifier": "udpListenerTests",
                "newPage": false,
                "searchKey": "net.udpListenerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var udpListenerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar udpListenerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dualStackTCPListenerTests",
              "documentation": {
                "identifier": "dualStackTCPListenerTests",
                "newPage": false,
                "searchKey": "net.dualStackTCPListenerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dualStackTCPListenerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dualStackTCPListenerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dualStackUDPListenerTests",
              "documentation": {
                "identifier": "dualStackUDPListenerTests",
                "newPage": false,
                "searchKey": "net.dualStackUDPListenerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dualStackUDPListenerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dualStackUDPListenerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipv4MulticastListenerTests",
              "documentation": {
                "identifier": "ipv4MulticastListenerTests",
                "newPage": false,
                "searchKey": "net.ipv4MulticastListenerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipv4MulticastListenerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipv4MulticastListenerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipv6MulticastListenerTests",
              "documentation": {
                "identifier": "ipv6MulticastListenerTests",
                "newPage": false,
                "searchKey": "net.ipv6MulticastListenerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipv6MulticastListenerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipv6MulticastListenerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupGoogleSRVTests",
              "documentation": {
                "identifier": "lookupGoogleSRVTests",
                "newPage": false,
                "searchKey": "net.lookupGoogleSRVTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupGoogleSRVTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupGoogleSRVTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#backoffDuration",
              "documentation": {
                "identifier": "backoffDuration",
                "newPage": false,
                "searchKey": "net.backoffDuration",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var backoffDuration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar backoffDuration = [...]time.Duration{time.Second, 5 * time.Second, 30 * time.Second}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupGmailMXTests",
              "documentation": {
                "identifier": "lookupGmailMXTests",
                "newPage": false,
                "searchKey": "net.lookupGmailMXTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupGmailMXTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupGmailMXTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupGmailNSTests",
              "documentation": {
                "identifier": "lookupGmailNSTests",
                "newPage": false,
                "searchKey": "net.lookupGmailNSTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupGmailNSTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupGmailNSTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupGmailTXTTests",
              "documentation": {
                "identifier": "lookupGmailTXTTests",
                "newPage": false,
                "searchKey": "net.lookupGmailTXTTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupGmailTXTTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupGmailTXTTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupGooglePublicDNSAddrTests",
              "documentation": {
                "identifier": "lookupGooglePublicDNSAddrTests",
                "newPage": false,
                "searchKey": "net.lookupGooglePublicDNSAddrTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupGooglePublicDNSAddrTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupGooglePublicDNSAddrTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupCNAMETests",
              "documentation": {
                "identifier": "lookupCNAMETests",
                "newPage": false,
                "searchKey": "net.lookupCNAMETests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupCNAMETests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupCNAMETests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupGoogleHostTests",
              "documentation": {
                "identifier": "lookupGoogleHostTests",
                "newPage": false,
                "searchKey": "net.lookupGoogleHostTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupGoogleHostTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupGoogleHostTests = []struct {\n\tname string\n}{\n\t{\"google.com\"},\n\t{\"google.com.\"},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupGoogleIPTests",
              "documentation": {
                "identifier": "lookupGoogleIPTests",
                "newPage": false,
                "searchKey": "net.lookupGoogleIPTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lookupGoogleIPTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lookupGoogleIPTests = []struct {\n\tname string\n}{\n\t{\"google.com\"},\n\t{\"google.com.\"},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#revAddrTests",
              "documentation": {
                "identifier": "revAddrTests",
                "newPage": false,
                "searchKey": "net.revAddrTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var revAddrTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar revAddrTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipVersionTests",
              "documentation": {
                "identifier": "ipVersionTests",
                "newPage": false,
                "searchKey": "net.ipVersionTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipVersionTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipVersionTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseMACTests",
              "documentation": {
                "identifier": "parseMACTests",
                "newPage": false,
                "searchKey": "net.parseMACTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var parseMACTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar parseMACTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#sw",
              "documentation": {
                "identifier": "sw",
                "newPage": false,
                "searchKey": "net.sw",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sw"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sw socktest.Switch\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testHookUninstaller",
              "documentation": {
                "identifier": "testHookUninstaller",
                "newPage": false,
                "searchKey": "net.testHookUninstaller",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookUninstaller"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookUninstaller sync.Once\n```\n\nuninstallTestHooks runs just before a run of benchmarks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testTCPBig",
              "documentation": {
                "identifier": "testTCPBig",
                "newPage": false,
                "searchKey": "net.testTCPBig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testTCPBig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testTCPBig = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testDNSFlood",
              "documentation": {
                "identifier": "testDNSFlood",
                "newPage": false,
                "searchKey": "net.testDNSFlood",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testDNSFlood"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testDNSFlood = flag.Bool(\"dnsflood\", false, \"whether to test DNS query flooding\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testIPv4",
              "documentation": {
                "identifier": "testIPv4",
                "newPage": false,
                "searchKey": "net.testIPv4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testIPv4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testIPv4 = flag.Bool(\"ipv4\", true, \"assume external IPv4 connectivity exists\")\n```\n\nIf external IPv4 connectivity exists, we can try dialing non-node/interface local scope IPv4 addresses. On Windows, Lookup APIs may not return IPv4-related resource records when a node has no external IPv4 connectivity. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testIPv6",
              "documentation": {
                "identifier": "testIPv6",
                "newPage": false,
                "searchKey": "net.testIPv6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testIPv6"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testIPv6 = flag.Bool(\"ipv6\", false, \"assume external IPv6 connectivity exists\")\n```\n\nIf external IPv6 connectivity exists, we can try dialing non-node/interface local scope IPv6 addresses. On Windows, Lookup APIs may not return IPv6-related resource records when a node has no external IPv6 connectivity. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipv6LinkLocalUnicastTCPTests",
              "documentation": {
                "identifier": "ipv6LinkLocalUnicastTCPTests",
                "newPage": false,
                "searchKey": "net.ipv6LinkLocalUnicastTCPTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipv6LinkLocalUnicastTCPTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipv6LinkLocalUnicastTCPTests []ipv6LinkLocalUnicastTest\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipv6LinkLocalUnicastUDPTests",
              "documentation": {
                "identifier": "ipv6LinkLocalUnicastUDPTests",
                "newPage": false,
                "searchKey": "net.ipv6LinkLocalUnicastUDPTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ipv6LinkLocalUnicastUDPTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ipv6LinkLocalUnicastUDPTests []ipv6LinkLocalUnicastTest\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#origSocket",
              "documentation": {
                "identifier": "origSocket",
                "newPage": false,
                "searchKey": "net.origSocket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var origSocket"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar origSocket = socketFunc\n```\n\nPlaceholders for saving original socket system calls. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#origClose",
              "documentation": {
                "identifier": "origClose",
                "newPage": false,
                "searchKey": "net.origClose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var origClose"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar origClose = poll.CloseFunc\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#origConnect",
              "documentation": {
                "identifier": "origConnect",
                "newPage": false,
                "searchKey": "net.origConnect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var origConnect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar origConnect = connectFunc\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#origListen",
              "documentation": {
                "identifier": "origListen",
                "newPage": false,
                "searchKey": "net.origListen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var origListen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar origListen = listenFunc\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#origAccept",
              "documentation": {
                "identifier": "origAccept",
                "newPage": false,
                "searchKey": "net.origAccept",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var origAccept"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar origAccept = poll.AcceptFunc\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#origGetsockoptInt",
              "documentation": {
                "identifier": "origGetsockoptInt",
                "newPage": false,
                "searchKey": "net.origGetsockoptInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var origGetsockoptInt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar origGetsockoptInt = getsockoptIntFunc\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#extraTestHookInstallers",
              "documentation": {
                "identifier": "extraTestHookInstallers",
                "newPage": false,
                "searchKey": "net.extraTestHookInstallers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var extraTestHookInstallers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar extraTestHookInstallers []func()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#extraTestHookUninstallers",
              "documentation": {
                "identifier": "extraTestHookUninstallers",
                "newPage": false,
                "searchKey": "net.extraTestHookUninstallers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var extraTestHookUninstallers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar extraTestHookUninstallers []func()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#packetConnTests",
              "documentation": {
                "identifier": "packetConnTests",
                "newPage": false,
                "searchKey": "net.packetConnTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var packetConnTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar packetConnTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#unixEnabledOnAIX",
              "documentation": {
                "identifier": "unixEnabledOnAIX",
                "newPage": false,
                "searchKey": "net.unixEnabledOnAIX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var unixEnabledOnAIX"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar unixEnabledOnAIX bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parsePortTests",
              "documentation": {
                "identifier": "parsePortTests",
                "newPage": false,
                "searchKey": "net.parsePortTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var parsePortTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar parsePortTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#tcpServerTests",
              "documentation": {
                "identifier": "tcpServerTests",
                "newPage": false,
                "searchKey": "net.tcpServerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tcpServerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tcpServerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#unixAndUnixpacketServerTests",
              "documentation": {
                "identifier": "unixAndUnixpacketServerTests",
                "newPage": false,
                "searchKey": "net.unixAndUnixpacketServerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var unixAndUnixpacketServerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar unixAndUnixpacketServerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#udpServerTests",
              "documentation": {
                "identifier": "udpServerTests",
                "newPage": false,
                "searchKey": "net.udpServerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var udpServerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar udpServerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#unixgramServerTests",
              "documentation": {
                "identifier": "unixgramServerTests",
                "newPage": false,
                "searchKey": "net.unixgramServerTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var unixgramServerTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar unixgramServerTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#resolveTCPAddrTests",
              "documentation": {
                "identifier": "resolveTCPAddrTests",
                "newPage": false,
                "searchKey": "net.resolveTCPAddrTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var resolveTCPAddrTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar resolveTCPAddrTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#tcpListenerNameTests",
              "documentation": {
                "identifier": "tcpListenerNameTests",
                "newPage": false,
                "searchKey": "net.tcpListenerNameTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tcpListenerNameTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tcpListenerNameTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dialTimeoutTests",
              "documentation": {
                "identifier": "dialTimeoutTests",
                "newPage": false,
                "searchKey": "net.dialTimeoutTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dialTimeoutTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dialTimeoutTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dialTimeoutMaxDurationTests",
              "documentation": {
                "identifier": "dialTimeoutMaxDurationTests",
                "newPage": false,
                "searchKey": "net.dialTimeoutMaxDurationTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dialTimeoutMaxDurationTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dialTimeoutMaxDurationTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#acceptTimeoutTests",
              "documentation": {
                "identifier": "acceptTimeoutTests",
                "newPage": false,
                "searchKey": "net.acceptTimeoutTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var acceptTimeoutTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar acceptTimeoutTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readTimeoutTests",
              "documentation": {
                "identifier": "readTimeoutTests",
                "newPage": false,
                "searchKey": "net.readTimeoutTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var readTimeoutTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar readTimeoutTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readFromTimeoutTests",
              "documentation": {
                "identifier": "readFromTimeoutTests",
                "newPage": false,
                "searchKey": "net.readFromTimeoutTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var readFromTimeoutTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar readFromTimeoutTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#writeTimeoutTests",
              "documentation": {
                "identifier": "writeTimeoutTests",
                "newPage": false,
                "searchKey": "net.writeTimeoutTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var writeTimeoutTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar writeTimeoutTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#writeToTimeoutTests",
              "documentation": {
                "identifier": "writeToTimeoutTests",
                "newPage": false,
                "searchKey": "net.writeToTimeoutTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var writeToTimeoutTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar writeToTimeoutTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#resolveUDPAddrTests",
              "documentation": {
                "identifier": "resolveUDPAddrTests",
                "newPage": false,
                "searchKey": "net.resolveUDPAddrTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var resolveUDPAddrTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar resolveUDPAddrTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#udpConnLocalNameTests",
              "documentation": {
                "identifier": "udpConnLocalNameTests",
                "newPage": false,
                "searchKey": "net.udpConnLocalNameTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var udpConnLocalNameTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar udpConnLocalNameTests = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/net#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/net#ipAttr",
              "documentation": {
                "identifier": "ipAttr",
                "newPage": false,
                "searchKey": "net.ipAttr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ipAttr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ipAttr struct {\n\tScope      scope\n\tPrecedence uint8\n\tLabel      uint8\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ipAttrOf",
                    "documentation": {
                      "identifier": "ipAttrOf",
                      "newPage": false,
                      "searchKey": "net.ipAttrOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ipAttrOf(ip IP) ipAttr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ipAttrOf(ip IP) ipAttr\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#byRFC6724",
              "documentation": {
                "identifier": "byRFC6724",
                "newPage": false,
                "searchKey": "net.byRFC6724",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type byRFC6724 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byRFC6724 struct {\n\taddrs    []IPAddr // addrs to sort\n\taddrAttr []ipAttr\n\tsrcs     []IP // or nil if unreachable\n\tsrcAttr  []ipAttr\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#byRFC6724.Len",
                    "documentation": {
                      "identifier": "byRFC6724.Len",
                      "newPage": false,
                      "searchKey": "net.byRFC6724.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *byRFC6724) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *byRFC6724) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byRFC6724.Swap",
                    "documentation": {
                      "identifier": "byRFC6724.Swap",
                      "newPage": false,
                      "searchKey": "net.byRFC6724.Swap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *byRFC6724) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *byRFC6724) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byRFC6724.Less",
                    "documentation": {
                      "identifier": "byRFC6724.Less",
                      "newPage": false,
                      "searchKey": "net.byRFC6724.Less",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *byRFC6724) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *byRFC6724) Less(i, j int) bool\n```\n\nLess reports whether i is a better destination address for this host than j. \n\nThe algorithm and variable names comes from RFC 6724 section 6. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#policyTableEntry",
              "documentation": {
                "identifier": "policyTableEntry",
                "newPage": false,
                "searchKey": "net.policyTableEntry",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type policyTableEntry struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype policyTableEntry struct {\n\tPrefix     *IPNet\n\tPrecedence uint8\n\tLabel      uint8\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#policyTable",
              "documentation": {
                "identifier": "policyTable",
                "newPage": false,
                "searchKey": "net.policyTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type policyTable []net.policyTableEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype policyTable []policyTableEntry\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#policyTable.Classify",
                    "documentation": {
                      "identifier": "policyTable.Classify",
                      "newPage": false,
                      "searchKey": "net.policyTable.Classify",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t policyTable) Classify(ip IP) policyTableEntry"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t policyTable) Classify(ip IP) policyTableEntry\n```\n\nClassify returns the policyTableEntry of the entry with the longest matching prefix that contains ip. The table t must be sorted from largest mask size to smallest. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#byMaskLength",
              "documentation": {
                "identifier": "byMaskLength",
                "newPage": false,
                "searchKey": "net.byMaskLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type byMaskLength []net.policyTableEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byMaskLength []policyTableEntry\n```\n\nbyMaskLength sorts policyTableEntry by the size of their Prefix.Mask.Size, from smallest mask, to largest. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#byMaskLength.Len",
                    "documentation": {
                      "identifier": "byMaskLength.Len",
                      "newPage": false,
                      "searchKey": "net.byMaskLength.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byMaskLength) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byMaskLength) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byMaskLength.Swap",
                    "documentation": {
                      "identifier": "byMaskLength.Swap",
                      "newPage": false,
                      "searchKey": "net.byMaskLength.Swap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byMaskLength) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byMaskLength) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byMaskLength.Less",
                    "documentation": {
                      "identifier": "byMaskLength.Less",
                      "newPage": false,
                      "searchKey": "net.byMaskLength.Less",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byMaskLength) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byMaskLength) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#scope",
              "documentation": {
                "identifier": "scope",
                "newPage": false,
                "searchKey": "net.scope",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type scope uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype scope uint8\n```\n\nRFC 6724 section 3.1. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#classifyScope",
                    "documentation": {
                      "identifier": "classifyScope",
                      "newPage": false,
                      "searchKey": "net.classifyScope",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func classifyScope(ip IP) scope"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc classifyScope(ip IP) scope\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#conf",
              "documentation": {
                "identifier": "conf",
                "newPage": false,
                "searchKey": "net.conf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type conf struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype conf struct {\n\t// forceCgoLookupHost forces CGO to always be used, if available.\n\tforceCgoLookupHost bool\n\n\tnetGo  bool // go DNS resolution forced\n\tnetCgo bool // cgo DNS resolution forced\n\n\t// machine has an /etc/mdns.allow file\n\thasMDNSAllow bool\n\n\tgoos          string // the runtime.GOOS, to ease testing\n\tdnsDebugLevel int\n\n\tnss    *nssConf\n\tresolv *dnsConfig\n}\n```\n\nconf represents a system's network configuration. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#systemConf",
                    "documentation": {
                      "identifier": "systemConf",
                      "newPage": false,
                      "searchKey": "net.systemConf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func systemConf() *conf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc systemConf() *conf\n```\n\nsystemConf returns the machine's network configuration. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conf.canUseCgo",
                    "documentation": {
                      "identifier": "conf.canUseCgo",
                      "newPage": false,
                      "searchKey": "net.conf.canUseCgo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conf) canUseCgo() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conf) canUseCgo() bool\n```\n\ncanUseCgo reports whether calling cgo functions is allowed for non-hostname lookups. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conf.hostLookupOrder",
                    "documentation": {
                      "identifier": "conf.hostLookupOrder",
                      "newPage": false,
                      "searchKey": "net.conf.hostLookupOrder",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conf) hostLookupOrder(r *Resolver, hostname string) (ret hostLookupOrder)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conf) hostLookupOrder(r *Resolver, hostname string) (ret hostLookupOrder)\n```\n\nhostLookupOrder determines which strategy to use to resolve hostname. The provided Resolver is optional. nil means to not consider its options. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#Dialer",
              "documentation": {
                "identifier": "Dialer",
                "newPage": false,
                "searchKey": "net.Dialer",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Dialer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Dialer struct {\n\t// Timeout is the maximum amount of time a dial will wait for\n\t// a connect to complete. If Deadline is also set, it may fail\n\t// earlier.\n\t//\n\t// The default is no timeout.\n\t//\n\t// When using TCP and dialing a host name with multiple IP\n\t// addresses, the timeout may be divided between them.\n\t//\n\t// With or without a timeout, the operating system may impose\n\t// its own earlier timeout. For instance, TCP timeouts are\n\t// often around 3 minutes.\n\tTimeout time.Duration\n\n\t// Deadline is the absolute point in time after which dials\n\t// will fail. If Timeout is set, it may fail earlier.\n\t// Zero means no deadline, or dependent on the operating system\n\t// as with the Timeout option.\n\tDeadline time.Time\n\n\t// LocalAddr is the local address to use when dialing an\n\t// address. The address must be of a compatible type for the\n\t// network being dialed.\n\t// If nil, a local address is automatically chosen.\n\tLocalAddr Addr\n\n\t// DualStack previously enabled RFC 6555 Fast Fallback\n\t// support, also known as \"Happy Eyeballs\", in which IPv4 is\n\t// tried soon if IPv6 appears to be misconfigured and\n\t// hanging.\n\t//\n\t// Deprecated: Fast Fallback is enabled by default. To\n\t// disable, set FallbackDelay to a negative value.\n\tDualStack bool\n\n\t// FallbackDelay specifies the length of time to wait before\n\t// spawning a RFC 6555 Fast Fallback connection. That is, this\n\t// is the amount of time to wait for IPv6 to succeed before\n\t// assuming that IPv6 is misconfigured and falling back to\n\t// IPv4.\n\t//\n\t// If zero, a default delay of 300ms is used.\n\t// A negative value disables Fast Fallback support.\n\tFallbackDelay time.Duration\n\n\t// KeepAlive specifies the interval between keep-alive\n\t// probes for an active network connection.\n\t// If zero, keep-alive probes are sent with a default value\n\t// (currently 15 seconds), if supported by the protocol and operating\n\t// system. Network protocols or operating systems that do\n\t// not support keep-alives ignore this field.\n\t// If negative, keep-alive probes are disabled.\n\tKeepAlive time.Duration\n\n\t// Resolver optionally specifies an alternate resolver to use.\n\tResolver *Resolver\n\n\t// Cancel is an optional channel whose closure indicates that\n\t// the dial should be canceled. Not all types of dials support\n\t// cancellation.\n\t//\n\t// Deprecated: Use DialContext instead.\n\tCancel <-chan struct{}\n\n\t// If Control is not nil, it is called after creating the network\n\t// connection but before actually dialing.\n\t//\n\t// Network and address parameters passed to Control method are not\n\t// necessarily the ones passed to Dial. For example, passing \"tcp\" to Dial\n\t// will cause the Control function to be called with \"tcp4\" or \"tcp6\".\n\tControl func(network, address string, c syscall.RawConn) error\n}\n```\n\nA Dialer contains options for connecting to an address. \n\nThe zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function. \n\nIt is safe to call Dialer's methods concurrently. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#Dialer.dualStack",
                    "documentation": {
                      "identifier": "Dialer.dualStack",
                      "newPage": false,
                      "searchKey": "net.Dialer.dualStack",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *Dialer) dualStack() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *Dialer) dualStack() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Dialer.deadline",
                    "documentation": {
                      "identifier": "Dialer.deadline",
                      "newPage": false,
                      "searchKey": "net.Dialer.deadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *Dialer) deadline(ctx context.Context, now time.Time) (earliest time.Time)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *Dialer) deadline(ctx context.Context, now time.Time) (earliest time.Time)\n```\n\ndeadline returns the earliest of: \n\n```\n- now+Timeout\n- d.Deadline\n- the context's deadline\n\n```\nOr zero, if none of Timeout, Deadline, or context's deadline is set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Dialer.resolver",
                    "documentation": {
                      "identifier": "Dialer.resolver",
                      "newPage": false,
                      "searchKey": "net.Dialer.resolver",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *Dialer) resolver() *Resolver"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *Dialer) resolver() *Resolver\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Dialer.fallbackDelay",
                    "documentation": {
                      "identifier": "Dialer.fallbackDelay",
                      "newPage": false,
                      "searchKey": "net.Dialer.fallbackDelay",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *Dialer) fallbackDelay() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *Dialer) fallbackDelay() time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Dialer.Dial",
                    "documentation": {
                      "identifier": "Dialer.Dial",
                      "newPage": false,
                      "searchKey": "net.Dialer.Dial",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *Dialer) Dial(network, address string) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *Dialer) Dial(network, address string) (Conn, error)\n```\n\nDial connects to the address on the named network. \n\nSee func Dial for a description of the network and address parameters. \n\nDial uses context.Background internally; to specify the context, use DialContext. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Dialer.DialContext",
                    "documentation": {
                      "identifier": "Dialer.DialContext",
                      "newPage": false,
                      "searchKey": "net.Dialer.DialContext",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)\n```\n\nDialContext connects to the address on the named network using the provided context. \n\nThe provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection. \n\nWhen using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one. \n\nSee func Dial for a description of the network and address parameters. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#sysDialer",
              "documentation": {
                "identifier": "sysDialer",
                "newPage": false,
                "searchKey": "net.sysDialer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sysDialer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sysDialer struct {\n\tDialer\n\tnetwork, address string\n}\n```\n\nsysDialer contains a Dial's parameters and configuration. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#sysDialer.dialParallel",
                    "documentation": {
                      "identifier": "sysDialer.dialParallel",
                      "newPage": false,
                      "searchKey": "net.sysDialer.dialParallel",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sd *sysDialer) dialParallel(ctx context.Context, primaries, fallbacks addrList) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sd *sysDialer) dialParallel(ctx context.Context, primaries, fallbacks addrList) (Conn, error)\n```\n\ndialParallel races two copies of dialSerial, giving the first a head start. It returns the first established connection and closes the others. Otherwise it returns an error from the first primary address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysDialer.dialSerial",
                    "documentation": {
                      "identifier": "sysDialer.dialSerial",
                      "newPage": false,
                      "searchKey": "net.sysDialer.dialSerial",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sd *sysDialer) dialSerial(ctx context.Context, ras addrList) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sd *sysDialer) dialSerial(ctx context.Context, ras addrList) (Conn, error)\n```\n\ndialSerial connects to a list of addresses in sequence, returning either the first successful connection, or the first error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysDialer.dialSingle",
                    "documentation": {
                      "identifier": "sysDialer.dialSingle",
                      "newPage": false,
                      "searchKey": "net.sysDialer.dialSingle",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sd *sysDialer) dialSingle(ctx context.Context, ra Addr) (c Conn, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sd *sysDialer) dialSingle(ctx context.Context, ra Addr) (c Conn, err error)\n```\n\ndialSingle attempts to establish and returns a single connection to the destination address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysDialer.dialIP",
                    "documentation": {
                      "identifier": "sysDialer.dialIP",
                      "newPage": false,
                      "searchKey": "net.sysDialer.dialIP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sd *sysDialer) dialIP(ctx context.Context, laddr, raddr *IPAddr) (*IPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sd *sysDialer) dialIP(ctx context.Context, laddr, raddr *IPAddr) (*IPConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysDialer.dialTCP",
                    "documentation": {
                      "identifier": "sysDialer.dialTCP",
                      "newPage": false,
                      "searchKey": "net.sysDialer.dialTCP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sd *sysDialer) dialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sd *sysDialer) dialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysDialer.doDialTCP",
                    "documentation": {
                      "identifier": "sysDialer.doDialTCP",
                      "newPage": false,
                      "searchKey": "net.sysDialer.doDialTCP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sd *sysDialer) doDialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sd *sysDialer) doDialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysDialer.dialUDP",
                    "documentation": {
                      "identifier": "sysDialer.dialUDP",
                      "newPage": false,
                      "searchKey": "net.sysDialer.dialUDP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sd *sysDialer) dialUDP(ctx context.Context, laddr, raddr *UDPAddr) (*UDPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sd *sysDialer) dialUDP(ctx context.Context, laddr, raddr *UDPAddr) (*UDPConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysDialer.dialUnix",
                    "documentation": {
                      "identifier": "sysDialer.dialUnix",
                      "newPage": false,
                      "searchKey": "net.sysDialer.dialUnix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sd *sysDialer) dialUnix(ctx context.Context, laddr, raddr *UnixAddr) (*UnixConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sd *sysDialer) dialUnix(ctx context.Context, laddr, raddr *UnixAddr) (*UnixConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#ListenConfig",
              "documentation": {
                "identifier": "ListenConfig",
                "newPage": false,
                "searchKey": "net.ListenConfig",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ListenConfig struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ListenConfig struct {\n\t// If Control is not nil, it is called after creating the network\n\t// connection but before binding it to the operating system.\n\t//\n\t// Network and address parameters passed to Control method are not\n\t// necessarily the ones passed to Listen. For example, passing \"tcp\" to\n\t// Listen will cause the Control function to be called with \"tcp4\" or \"tcp6\".\n\tControl func(network, address string, c syscall.RawConn) error\n\n\t// KeepAlive specifies the keep-alive period for network\n\t// connections accepted by this listener.\n\t// If zero, keep-alives are enabled if supported by the protocol\n\t// and operating system. Network protocols or operating systems\n\t// that do not support keep-alives ignore this field.\n\t// If negative, keep-alives are disabled.\n\tKeepAlive time.Duration\n}\n```\n\nListenConfig contains options for listening to an address. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ListenConfig.Listen",
                    "documentation": {
                      "identifier": "ListenConfig.Listen",
                      "newPage": false,
                      "searchKey": "net.ListenConfig.Listen",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error)\n```\n\nListen announces on the local network address. \n\nSee func Listen for a description of the network and address parameters. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ListenConfig.ListenPacket",
                    "documentation": {
                      "identifier": "ListenConfig.ListenPacket",
                      "newPage": false,
                      "searchKey": "net.ListenConfig.ListenPacket",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (lc *ListenConfig) ListenPacket(ctx context.Context, network, address string) (PacketConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (lc *ListenConfig) ListenPacket(ctx context.Context, network, address string) (PacketConn, error)\n```\n\nListenPacket announces on the local network address. \n\nSee func ListenPacket for a description of the network and address parameters. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#sysListener",
              "documentation": {
                "identifier": "sysListener",
                "newPage": false,
                "searchKey": "net.sysListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sysListener struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sysListener struct {\n\tListenConfig\n\tnetwork, address string\n}\n```\n\nsysListener contains a Listen's parameters and configuration. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#sysListener.listenIP",
                    "documentation": {
                      "identifier": "sysListener.listenIP",
                      "newPage": false,
                      "searchKey": "net.sysListener.listenIP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sl *sysListener) listenIP(ctx context.Context, laddr *IPAddr) (*IPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sl *sysListener) listenIP(ctx context.Context, laddr *IPAddr) (*IPConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysListener.listenTCP",
                    "documentation": {
                      "identifier": "sysListener.listenTCP",
                      "newPage": false,
                      "searchKey": "net.sysListener.listenTCP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysListener.listenUDP",
                    "documentation": {
                      "identifier": "sysListener.listenUDP",
                      "newPage": false,
                      "searchKey": "net.sysListener.listenUDP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sl *sysListener) listenUDP(ctx context.Context, laddr *UDPAddr) (*UDPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sl *sysListener) listenUDP(ctx context.Context, laddr *UDPAddr) (*UDPConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysListener.listenMulticastUDP",
                    "documentation": {
                      "identifier": "sysListener.listenMulticastUDP",
                      "newPage": false,
                      "searchKey": "net.sysListener.listenMulticastUDP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sl *sysListener) listenMulticastUDP(ctx context.Context, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sl *sysListener) listenMulticastUDP(ctx context.Context, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysListener.listenUnix",
                    "documentation": {
                      "identifier": "sysListener.listenUnix",
                      "newPage": false,
                      "searchKey": "net.sysListener.listenUnix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sl *sysListener) listenUnix(ctx context.Context, laddr *UnixAddr) (*UnixListener, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sl *sysListener) listenUnix(ctx context.Context, laddr *UnixAddr) (*UnixListener, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sysListener.listenUnixgram",
                    "documentation": {
                      "identifier": "sysListener.listenUnixgram",
                      "newPage": false,
                      "searchKey": "net.sysListener.listenUnixgram",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sl *sysListener) listenUnixgram(ctx context.Context, laddr *UnixAddr) (*UnixConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sl *sysListener) listenUnixgram(ctx context.Context, laddr *UnixAddr) (*UnixConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#SRV",
              "documentation": {
                "identifier": "SRV",
                "newPage": false,
                "searchKey": "net.SRV",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type SRV struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SRV struct {\n\tTarget   string\n\tPort     uint16\n\tPriority uint16\n\tWeight   uint16\n}\n```\n\nAn SRV represents a single DNS SRV record. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#byPriorityWeight",
              "documentation": {
                "identifier": "byPriorityWeight",
                "newPage": false,
                "searchKey": "net.byPriorityWeight",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type byPriorityWeight []*net.SRV"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byPriorityWeight []*SRV\n```\n\nbyPriorityWeight sorts SRV records by ascending priority and weight. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#byPriorityWeight.Len",
                    "documentation": {
                      "identifier": "byPriorityWeight.Len",
                      "newPage": false,
                      "searchKey": "net.byPriorityWeight.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byPriorityWeight) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byPriorityWeight) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byPriorityWeight.Less",
                    "documentation": {
                      "identifier": "byPriorityWeight.Less",
                      "newPage": false,
                      "searchKey": "net.byPriorityWeight.Less",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byPriorityWeight) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byPriorityWeight) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byPriorityWeight.Swap",
                    "documentation": {
                      "identifier": "byPriorityWeight.Swap",
                      "newPage": false,
                      "searchKey": "net.byPriorityWeight.Swap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byPriorityWeight) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byPriorityWeight) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byPriorityWeight.shuffleByWeight",
                    "documentation": {
                      "identifier": "byPriorityWeight.shuffleByWeight",
                      "newPage": false,
                      "searchKey": "net.byPriorityWeight.shuffleByWeight",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (addrs byPriorityWeight) shuffleByWeight()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (addrs byPriorityWeight) shuffleByWeight()\n```\n\nshuffleByWeight shuffles SRV records by weight using the algorithm described in RFC 2782. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byPriorityWeight.sort",
                    "documentation": {
                      "identifier": "byPriorityWeight.sort",
                      "newPage": false,
                      "searchKey": "net.byPriorityWeight.sort",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (addrs byPriorityWeight) sort()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (addrs byPriorityWeight) sort()\n```\n\nsort reorders SRV records as specified in RFC 2782. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#MX",
              "documentation": {
                "identifier": "MX",
                "newPage": false,
                "searchKey": "net.MX",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type MX struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype MX struct {\n\tHost string\n\tPref uint16\n}\n```\n\nAn MX represents a single DNS MX record. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#byPref",
              "documentation": {
                "identifier": "byPref",
                "newPage": false,
                "searchKey": "net.byPref",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type byPref []*net.MX"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byPref []*MX\n```\n\nbyPref implements sort.Interface to sort MX records by preference \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#byPref.Len",
                    "documentation": {
                      "identifier": "byPref.Len",
                      "newPage": false,
                      "searchKey": "net.byPref.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byPref) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byPref) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byPref.Less",
                    "documentation": {
                      "identifier": "byPref.Less",
                      "newPage": false,
                      "searchKey": "net.byPref.Less",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byPref) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byPref) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byPref.Swap",
                    "documentation": {
                      "identifier": "byPref.Swap",
                      "newPage": false,
                      "searchKey": "net.byPref.Swap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byPref) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byPref) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#byPref.sort",
                    "documentation": {
                      "identifier": "byPref.sort",
                      "newPage": false,
                      "searchKey": "net.byPref.sort",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byPref) sort()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byPref) sort()\n```\n\nsort reorders MX records as specified in RFC 5321. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#NS",
              "documentation": {
                "identifier": "NS",
                "newPage": false,
                "searchKey": "net.NS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type NS struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype NS struct {\n\tHost string\n}\n```\n\nAn NS represents a single DNS NS record. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#resolverConfig",
              "documentation": {
                "identifier": "resolverConfig",
                "newPage": false,
                "searchKey": "net.resolverConfig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type resolverConfig struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype resolverConfig struct {\n\tinitOnce sync.Once // guards init of resolverConfig\n\n\t// ch is used as a semaphore that only allows one lookup at a\n\t// time to recheck resolv.conf.\n\tch          chan struct{} // guards lastChecked and modTime\n\tlastChecked time.Time     // last time resolv.conf was checked\n\n\tmu        sync.RWMutex // protects dnsConfig\n\tdnsConfig *dnsConfig   // parsed resolv.conf structure used in lookups\n}\n```\n\nA resolverConfig represents a DNS stub resolver configuration. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#resolverConfig.init",
                    "documentation": {
                      "identifier": "resolverConfig.init",
                      "newPage": false,
                      "searchKey": "net.resolverConfig.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *resolverConfig) init()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *resolverConfig) init()\n```\n\ninit initializes conf and is only called via conf.initOnce. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#resolverConfig.tryUpdate",
                    "documentation": {
                      "identifier": "resolverConfig.tryUpdate",
                      "newPage": false,
                      "searchKey": "net.resolverConfig.tryUpdate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *resolverConfig) tryUpdate(name string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *resolverConfig) tryUpdate(name string)\n```\n\ntryUpdate tries to update conf with the named resolv.conf file. The name variable only exists for testing. It is otherwise always \"/etc/resolv.conf\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#resolverConfig.tryAcquireSema",
                    "documentation": {
                      "identifier": "resolverConfig.tryAcquireSema",
                      "newPage": false,
                      "searchKey": "net.resolverConfig.tryAcquireSema",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *resolverConfig) tryAcquireSema() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *resolverConfig) tryAcquireSema() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#resolverConfig.releaseSema",
                    "documentation": {
                      "identifier": "resolverConfig.releaseSema",
                      "newPage": false,
                      "searchKey": "net.resolverConfig.releaseSema",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *resolverConfig) releaseSema()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *resolverConfig) releaseSema()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#hostLookupOrder",
              "documentation": {
                "identifier": "hostLookupOrder",
                "newPage": false,
                "searchKey": "net.hostLookupOrder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type hostLookupOrder int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype hostLookupOrder int\n```\n\nhostLookupOrder specifies the order of LookupHost lookup strategies. It is basically a simplified representation of nsswitch.conf. \"files\" means /etc/hosts. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#hostLookupOrder.String",
                    "documentation": {
                      "identifier": "hostLookupOrder.String",
                      "newPage": false,
                      "searchKey": "net.hostLookupOrder.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (o hostLookupOrder) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (o hostLookupOrder) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsConfig",
              "documentation": {
                "identifier": "dnsConfig",
                "newPage": false,
                "searchKey": "net.dnsConfig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dnsConfig struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dnsConfig struct {\n\tservers       []string      // server addresses (in host:port form) to use\n\tsearch        []string      // rooted suffixes to append to local name\n\tndots         int           // number of dots in name to trigger absolute lookup\n\ttimeout       time.Duration // wait before giving up on a query, including retries\n\tattempts      int           // lost packets before giving up on server\n\trotate        bool          // round robin among servers\n\tunknownOpt    bool          // anything unknown was encountered\n\tlookup        []string      // OpenBSD top-level database \"lookup\" order\n\terr           error         // any error that occurs during open of resolv.conf\n\tmtime         time.Time     // time of resolv.conf modification\n\tsoffset       uint32        // used by serverOffset\n\tsingleRequest bool          // use sequential A and AAAA queries instead of parallel queries\n\tuseTCP        bool          // force usage of TCP for DNS resolutions\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#dnsReadConfig",
                    "documentation": {
                      "identifier": "dnsReadConfig",
                      "newPage": false,
                      "searchKey": "net.dnsReadConfig",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func dnsReadConfig(filename string) *dnsConfig"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc dnsReadConfig(filename string) *dnsConfig\n```\n\nSee resolv.conf(5) on a Linux machine. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#dnsConfig.nameList",
                    "documentation": {
                      "identifier": "dnsConfig.nameList",
                      "newPage": false,
                      "searchKey": "net.dnsConfig.nameList",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *dnsConfig) nameList(name string) []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *dnsConfig) nameList(name string) []string\n```\n\nnameList returns a list of names for sequential DNS queries. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#dnsConfig.serverOffset",
                    "documentation": {
                      "identifier": "dnsConfig.serverOffset",
                      "newPage": false,
                      "searchKey": "net.dnsConfig.serverOffset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *dnsConfig) serverOffset() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *dnsConfig) serverOffset() uint32\n```\n\nserverOffset returns an offset that can be used to determine indices of servers in c.servers when making queries. When the rotate option is enabled, this offset increases. Otherwise it is always 0. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#netFD",
              "documentation": {
                "identifier": "netFD",
                "newPage": false,
                "searchKey": "net.netFD",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type netFD struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype netFD struct {\n\tpfd poll.FD\n\n\t// immutable until Close\n\tfamily      int\n\tsotype      int\n\tisConnected bool // handshake completed or use of association with peer\n\tnet         string\n\tladdr       Addr\n\traddr       Addr\n}\n```\n\nNetwork file descriptor. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newFD",
                    "documentation": {
                      "identifier": "newFD",
                      "newPage": false,
                      "searchKey": "net.newFD",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newFD(sysfd, family, sotype int, net string) (*netFD, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newFD(sysfd, family, sotype int, net string) (*netFD, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#newFileFD",
                    "documentation": {
                      "identifier": "newFileFD",
                      "newPage": false,
                      "searchKey": "net.newFileFD",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newFileFD(f *os.File) (*netFD, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newFileFD(f *os.File) (*netFD, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#internetSocket",
                    "documentation": {
                      "identifier": "internetSocket",
                      "newPage": false,
                      "searchKey": "net.internetSocket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func internetSocket(ctx context.Context, net string, laddr, raddr sockaddr, sotype, proto int, mode string, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc internetSocket(ctx context.Context, net string, laddr, raddr sockaddr, sotype, proto int, mode string, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#socket",
                    "documentation": {
                      "identifier": "socket",
                      "newPage": false,
                      "searchKey": "net.socket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error)\n```\n\nsocket returns a network file descriptor that is ready for asynchronous I/O using the network poller. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#unixSocket",
                    "documentation": {
                      "identifier": "unixSocket",
                      "newPage": false,
                      "searchKey": "net.unixSocket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func unixSocket(ctx context.Context, net string, laddr, raddr sockaddr, mode string, ctrlFn func(string, string, syscall.RawConn) error) (*netFD, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc unixSocket(ctx context.Context, net string, laddr, raddr sockaddr, mode string, ctrlFn func(string, string, syscall.RawConn) error) (*netFD, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.setAddr",
                    "documentation": {
                      "identifier": "netFD.setAddr",
                      "newPage": false,
                      "searchKey": "net.netFD.setAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) setAddr(laddr, raddr Addr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) setAddr(laddr, raddr Addr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.Close",
                    "documentation": {
                      "identifier": "netFD.Close",
                      "newPage": false,
                      "searchKey": "net.netFD.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.shutdown",
                    "documentation": {
                      "identifier": "netFD.shutdown",
                      "newPage": false,
                      "searchKey": "net.netFD.shutdown",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) shutdown(how int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) shutdown(how int) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.closeRead",
                    "documentation": {
                      "identifier": "netFD.closeRead",
                      "newPage": false,
                      "searchKey": "net.netFD.closeRead",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) closeRead() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) closeRead() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.closeWrite",
                    "documentation": {
                      "identifier": "netFD.closeWrite",
                      "newPage": false,
                      "searchKey": "net.netFD.closeWrite",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) closeWrite() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) closeWrite() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.Read",
                    "documentation": {
                      "identifier": "netFD.Read",
                      "newPage": false,
                      "searchKey": "net.netFD.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.readFrom",
                    "documentation": {
                      "identifier": "netFD.readFrom",
                      "newPage": false,
                      "searchKey": "net.netFD.readFrom",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) readFrom(p []byte) (n int, sa syscall.Sockaddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) readFrom(p []byte) (n int, sa syscall.Sockaddr, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.readMsg",
                    "documentation": {
                      "identifier": "netFD.readMsg",
                      "newPage": false,
                      "searchKey": "net.netFD.readMsg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) readMsg(p []byte, oob []byte, flags int) (n, oobn, retflags int, sa syscall.Sockaddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) readMsg(p []byte, oob []byte, flags int) (n, oobn, retflags int, sa syscall.Sockaddr, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.Write",
                    "documentation": {
                      "identifier": "netFD.Write",
                      "newPage": false,
                      "searchKey": "net.netFD.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) Write(p []byte) (nn int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) Write(p []byte) (nn int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.writeTo",
                    "documentation": {
                      "identifier": "netFD.writeTo",
                      "newPage": false,
                      "searchKey": "net.netFD.writeTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) writeTo(p []byte, sa syscall.Sockaddr) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) writeTo(p []byte, sa syscall.Sockaddr) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.writeMsg",
                    "documentation": {
                      "identifier": "netFD.writeMsg",
                      "newPage": false,
                      "searchKey": "net.netFD.writeMsg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) writeMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oobn int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) writeMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oobn int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.SetDeadline",
                    "documentation": {
                      "identifier": "netFD.SetDeadline",
                      "newPage": false,
                      "searchKey": "net.netFD.SetDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) SetDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.SetReadDeadline",
                    "documentation": {
                      "identifier": "netFD.SetReadDeadline",
                      "newPage": false,
                      "searchKey": "net.netFD.SetReadDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) SetReadDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) SetReadDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.SetWriteDeadline",
                    "documentation": {
                      "identifier": "netFD.SetWriteDeadline",
                      "newPage": false,
                      "searchKey": "net.netFD.SetWriteDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) SetWriteDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) SetWriteDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.init",
                    "documentation": {
                      "identifier": "netFD.init",
                      "newPage": false,
                      "searchKey": "net.netFD.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) init() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) init() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.name",
                    "documentation": {
                      "identifier": "netFD.name",
                      "newPage": false,
                      "searchKey": "net.netFD.name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.connect",
                    "documentation": {
                      "identifier": "netFD.connect",
                      "newPage": false,
                      "searchKey": "net.netFD.connect",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) connect(ctx context.Context, la, ra syscall.Sockaddr) (rsa syscall.Sockaddr, ret error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) connect(ctx context.Context, la, ra syscall.Sockaddr) (rsa syscall.Sockaddr, ret error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.accept",
                    "documentation": {
                      "identifier": "netFD.accept",
                      "newPage": false,
                      "searchKey": "net.netFD.accept",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) accept() (netfd *netFD, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) accept() (netfd *netFD, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.dup",
                    "documentation": {
                      "identifier": "netFD.dup",
                      "newPage": false,
                      "searchKey": "net.netFD.dup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) dup() (f *os.File, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) dup() (f *os.File, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.ctrlNetwork",
                    "documentation": {
                      "identifier": "netFD.ctrlNetwork",
                      "newPage": false,
                      "searchKey": "net.netFD.ctrlNetwork",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) ctrlNetwork() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) ctrlNetwork() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.addrFunc",
                    "documentation": {
                      "identifier": "netFD.addrFunc",
                      "newPage": false,
                      "searchKey": "net.netFD.addrFunc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) addrFunc() func(syscall.Sockaddr) Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) addrFunc() func(syscall.Sockaddr) Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.dial",
                    "documentation": {
                      "identifier": "netFD.dial",
                      "newPage": false,
                      "searchKey": "net.netFD.dial",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) dial(ctx context.Context, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) dial(ctx context.Context, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.listenStream",
                    "documentation": {
                      "identifier": "netFD.listenStream",
                      "newPage": false,
                      "searchKey": "net.netFD.listenStream",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.listenDatagram",
                    "documentation": {
                      "identifier": "netFD.listenDatagram",
                      "newPage": false,
                      "searchKey": "net.netFD.listenDatagram",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) listenDatagram(laddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) listenDatagram(laddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#netFD.writeBuffers",
                    "documentation": {
                      "identifier": "netFD.writeBuffers",
                      "newPage": false,
                      "searchKey": "net.netFD.writeBuffers",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fd *netFD) writeBuffers(v *Buffers) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fd *netFD) writeBuffers(v *Buffers) (n int64, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#fileAddr",
              "documentation": {
                "identifier": "fileAddr",
                "newPage": false,
                "searchKey": "net.fileAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileAddr string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileAddr string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#fileAddr.Network",
                    "documentation": {
                      "identifier": "fileAddr.Network",
                      "newPage": false,
                      "searchKey": "net.fileAddr.Network",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fileAddr) Network() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fileAddr) Network() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#fileAddr.String",
                    "documentation": {
                      "identifier": "fileAddr.String",
                      "newPage": false,
                      "searchKey": "net.fileAddr.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f fileAddr) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f fileAddr) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#Interface",
              "documentation": {
                "identifier": "Interface",
                "newPage": false,
                "searchKey": "net.Interface",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Interface struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Interface struct {\n\tIndex        int          // positive integer that starts at one, zero is never used\n\tMTU          int          // maximum transmission unit\n\tName         string       // e.g., \"en0\", \"lo0\", \"eth0.100\"\n\tHardwareAddr HardwareAddr // IEEE MAC-48, EUI-48 and EUI-64 form\n\tFlags        Flags        // e.g., FlagUp, FlagLoopback, FlagMulticast\n}\n```\n\nInterface represents a mapping between network interface name and index. It also represents network interface facility information. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#InterfaceByIndex",
                    "documentation": {
                      "identifier": "InterfaceByIndex",
                      "newPage": false,
                      "searchKey": "net.InterfaceByIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func InterfaceByIndex(index int) (*Interface, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc InterfaceByIndex(index int) (*Interface, error)\n```\n\nInterfaceByIndex returns the interface specified by index. \n\nOn Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use InterfaceByName. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#interfaceByIndex",
                    "documentation": {
                      "identifier": "interfaceByIndex",
                      "newPage": false,
                      "searchKey": "net.interfaceByIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func interfaceByIndex(ift []Interface, index int) (*Interface, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc interfaceByIndex(ift []Interface, index int) (*Interface, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#InterfaceByName",
                    "documentation": {
                      "identifier": "InterfaceByName",
                      "newPage": false,
                      "searchKey": "net.InterfaceByName",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func InterfaceByName(name string) (*Interface, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc InterfaceByName(name string) (*Interface, error)\n```\n\nInterfaceByName returns the interface specified by name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ipv4AddrToInterface",
                    "documentation": {
                      "identifier": "ipv4AddrToInterface",
                      "newPage": false,
                      "searchKey": "net.ipv4AddrToInterface",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ipv4AddrToInterface(ip IP) (*Interface, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ipv4AddrToInterface(ip IP) (*Interface, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#loopbackInterface",
                    "documentation": {
                      "identifier": "loopbackInterface",
                      "newPage": false,
                      "searchKey": "net.loopbackInterface",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func loopbackInterface() *Interface"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc loopbackInterface() *Interface\n```\n\nloopbackInterface returns an available logical network interface for loopback tests. It returns nil if no suitable interface is found. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Interface.Addrs",
                    "documentation": {
                      "identifier": "Interface.Addrs",
                      "newPage": false,
                      "searchKey": "net.Interface.Addrs",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ifi *Interface) Addrs() ([]Addr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ifi *Interface) Addrs() ([]Addr, error)\n```\n\nAddrs returns a list of unicast interface addresses for a specific interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Interface.MulticastAddrs",
                    "documentation": {
                      "identifier": "Interface.MulticastAddrs",
                      "newPage": false,
                      "searchKey": "net.Interface.MulticastAddrs",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ifi *Interface) MulticastAddrs() ([]Addr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ifi *Interface) MulticastAddrs() ([]Addr, error)\n```\n\nMulticastAddrs returns a list of multicast, joined group addresses for a specific interface. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#Flags",
              "documentation": {
                "identifier": "Flags",
                "newPage": false,
                "searchKey": "net.Flags",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Flags uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Flags uint\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#linkFlags",
                    "documentation": {
                      "identifier": "linkFlags",
                      "newPage": false,
                      "searchKey": "net.linkFlags",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func linkFlags(rawFlags int) Flags"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc linkFlags(rawFlags int) Flags\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Flags.String",
                    "documentation": {
                      "identifier": "Flags.String",
                      "newPage": false,
                      "searchKey": "net.Flags.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f Flags) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f Flags) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipv6ZoneCache",
              "documentation": {
                "identifier": "ipv6ZoneCache",
                "newPage": false,
                "searchKey": "net.ipv6ZoneCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ipv6ZoneCache struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ipv6ZoneCache struct {\n\tsync.RWMutex                // guard the following\n\tlastFetched  time.Time      // last time routing information was fetched\n\ttoIndex      map[string]int // interface name to its index\n\ttoName       map[int]string // interface index to its name\n}\n```\n\nAn ipv6ZoneCache represents a cache holding partial network interface information. It is used for reducing the cost of IPv6 addressing scope zone resolution. \n\nMultiple names sharing the index are managed by first-come first-served basis for consistency. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ipv6ZoneCache.update",
                    "documentation": {
                      "identifier": "ipv6ZoneCache.update",
                      "newPage": false,
                      "searchKey": "net.ipv6ZoneCache.update",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (zc *ipv6ZoneCache) update(ift []Interface, force bool) (updated bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (zc *ipv6ZoneCache) update(ift []Interface, force bool) (updated bool)\n```\n\nupdate refreshes the network interface information if the cache was last updated more than 1 minute ago, or if force is set. It reports whether the cache was updated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ipv6ZoneCache.name",
                    "documentation": {
                      "identifier": "ipv6ZoneCache.name",
                      "newPage": false,
                      "searchKey": "net.ipv6ZoneCache.name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (zc *ipv6ZoneCache) name(index int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (zc *ipv6ZoneCache) name(index int) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ipv6ZoneCache.index",
                    "documentation": {
                      "identifier": "ipv6ZoneCache.index",
                      "newPage": false,
                      "searchKey": "net.ipv6ZoneCache.index",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (zc *ipv6ZoneCache) index(name string) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (zc *ipv6ZoneCache) index(name string) int\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#IP",
              "documentation": {
                "identifier": "IP",
                "newPage": false,
                "searchKey": "net.IP",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type IP []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype IP []byte\n```\n\nAn IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input. \n\nNote that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#IPv4",
                    "documentation": {
                      "identifier": "IPv4",
                      "newPage": false,
                      "searchKey": "net.IPv4",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func IPv4(a, b, c, d byte) IP"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc IPv4(a, b, c, d byte) IP\n```\n\nIPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#networkNumberAndMask",
                    "documentation": {
                      "identifier": "networkNumberAndMask",
                      "newPage": false,
                      "searchKey": "net.networkNumberAndMask",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func networkNumberAndMask(n *IPNet) (ip IP, m IPMask)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc networkNumberAndMask(n *IPNet) (ip IP, m IPMask)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#parseIPv4",
                    "documentation": {
                      "identifier": "parseIPv4",
                      "newPage": false,
                      "searchKey": "net.parseIPv4",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseIPv4(s string) IP"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseIPv4(s string) IP\n```\n\nParse IPv4 address (d.d.d.d). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#parseIPv6Zone",
                    "documentation": {
                      "identifier": "parseIPv6Zone",
                      "newPage": false,
                      "searchKey": "net.parseIPv6Zone",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseIPv6Zone(s string) (IP, string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseIPv6Zone(s string) (IP, string)\n```\n\nparseIPv6Zone parses s as a literal IPv6 address and its associated zone identifier which is described in RFC 4007. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#parseIPv6",
                    "documentation": {
                      "identifier": "parseIPv6",
                      "newPage": false,
                      "searchKey": "net.parseIPv6",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseIPv6(s string) (ip IP)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseIPv6(s string) (ip IP)\n```\n\nparseIPv6 parses s as a literal IPv6 address described in RFC 4291 and RFC 5952. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ParseIP",
                    "documentation": {
                      "identifier": "ParseIP",
                      "newPage": false,
                      "searchKey": "net.ParseIP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseIP(s string) IP"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseIP(s string) IP\n```\n\nParseIP parses s as an IP address, returning the result. The string s can be in IPv4 dotted decimal (\"192.0.2.1\"), IPv6 (\"2001:db8::68\"), or IPv4-mapped IPv6 (\"::ffff:192.0.2.1\") form. If s is not a valid textual representation of an IP address, ParseIP returns nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#parseIPZone",
                    "documentation": {
                      "identifier": "parseIPZone",
                      "newPage": false,
                      "searchKey": "net.parseIPZone",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseIPZone(s string) (IP, string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseIPZone(s string) (IP, string)\n```\n\nparseIPZone parses s as an IP address, return it and its associated zone identifier (IPv6 only). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ParseCIDR",
                    "documentation": {
                      "identifier": "ParseCIDR",
                      "newPage": false,
                      "searchKey": "net.ParseCIDR",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseCIDR(s string) (IP, *IPNet, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseCIDR(s string) (IP, *IPNet, error)\n```\n\nParseCIDR parses s as a CIDR notation IP address and prefix length, like \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in RFC 4632 and RFC 4291. \n\nIt returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(\"192.0.2.1/24\") returns the IP address 192.0.2.1 and the network 192.0.2.0/24. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#loopbackIP",
                    "documentation": {
                      "identifier": "loopbackIP",
                      "newPage": false,
                      "searchKey": "net.loopbackIP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func loopbackIP(net string) IP"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc loopbackIP(net string) IP\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#interfaceToIPv4Addr",
                    "documentation": {
                      "identifier": "interfaceToIPv4Addr",
                      "newPage": false,
                      "searchKey": "net.interfaceToIPv4Addr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func interfaceToIPv4Addr(ifi *Interface) (IP, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc interfaceToIPv4Addr(ifi *Interface) (IP, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#copyIP",
                    "documentation": {
                      "identifier": "copyIP",
                      "newPage": false,
                      "searchKey": "net.copyIP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func copyIP(x IP) IP"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc copyIP(x IP) IP\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.IsUnspecified",
                    "documentation": {
                      "identifier": "IP.IsUnspecified",
                      "newPage": false,
                      "searchKey": "net.IP.IsUnspecified",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) IsUnspecified() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) IsUnspecified() bool\n```\n\nIsUnspecified reports whether ip is an unspecified address, either the IPv4 address \"0.0.0.0\" or the IPv6 address \"::\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.IsLoopback",
                    "documentation": {
                      "identifier": "IP.IsLoopback",
                      "newPage": false,
                      "searchKey": "net.IP.IsLoopback",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) IsLoopback() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) IsLoopback() bool\n```\n\nIsLoopback reports whether ip is a loopback address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.IsPrivate",
                    "documentation": {
                      "identifier": "IP.IsPrivate",
                      "newPage": false,
                      "searchKey": "net.IP.IsPrivate",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) IsPrivate() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) IsPrivate() bool\n```\n\nIsPrivate reports whether ip is a private address, according to RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.IsMulticast",
                    "documentation": {
                      "identifier": "IP.IsMulticast",
                      "newPage": false,
                      "searchKey": "net.IP.IsMulticast",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) IsMulticast() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) IsMulticast() bool\n```\n\nIsMulticast reports whether ip is a multicast address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.IsInterfaceLocalMulticast",
                    "documentation": {
                      "identifier": "IP.IsInterfaceLocalMulticast",
                      "newPage": false,
                      "searchKey": "net.IP.IsInterfaceLocalMulticast",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) IsInterfaceLocalMulticast() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) IsInterfaceLocalMulticast() bool\n```\n\nIsInterfaceLocalMulticast reports whether ip is an interface-local multicast address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.IsLinkLocalMulticast",
                    "documentation": {
                      "identifier": "IP.IsLinkLocalMulticast",
                      "newPage": false,
                      "searchKey": "net.IP.IsLinkLocalMulticast",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) IsLinkLocalMulticast() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) IsLinkLocalMulticast() bool\n```\n\nIsLinkLocalMulticast reports whether ip is a link-local multicast address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.IsLinkLocalUnicast",
                    "documentation": {
                      "identifier": "IP.IsLinkLocalUnicast",
                      "newPage": false,
                      "searchKey": "net.IP.IsLinkLocalUnicast",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) IsLinkLocalUnicast() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) IsLinkLocalUnicast() bool\n```\n\nIsLinkLocalUnicast reports whether ip is a link-local unicast address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.IsGlobalUnicast",
                    "documentation": {
                      "identifier": "IP.IsGlobalUnicast",
                      "newPage": false,
                      "searchKey": "net.IP.IsGlobalUnicast",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) IsGlobalUnicast() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) IsGlobalUnicast() bool\n```\n\nIsGlobalUnicast reports whether ip is a global unicast address. \n\nThe identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.To4",
                    "documentation": {
                      "identifier": "IP.To4",
                      "newPage": false,
                      "searchKey": "net.IP.To4",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) To4() IP"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) To4() IP\n```\n\nTo4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.To16",
                    "documentation": {
                      "identifier": "IP.To16",
                      "newPage": false,
                      "searchKey": "net.IP.To16",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) To16() IP"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) To16() IP\n```\n\nTo16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.DefaultMask",
                    "documentation": {
                      "identifier": "IP.DefaultMask",
                      "newPage": false,
                      "searchKey": "net.IP.DefaultMask",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) DefaultMask() IPMask"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) DefaultMask() IPMask\n```\n\nDefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.Mask",
                    "documentation": {
                      "identifier": "IP.Mask",
                      "newPage": false,
                      "searchKey": "net.IP.Mask",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) Mask(mask IPMask) IP"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) Mask(mask IPMask) IP\n```\n\nMask returns the result of masking the IP address ip with mask. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.String",
                    "documentation": {
                      "identifier": "IP.String",
                      "newPage": false,
                      "searchKey": "net.IP.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) String() string\n```\n\nString returns the string form of the IP address ip. It returns one of 4 forms: \n\n```\n- \"<nil>\", if ip has length 0\n- dotted decimal (\"192.0.2.1\"), if ip is an IPv4 or IP4-mapped IPv6 address\n- IPv6 (\"2001:db8::1\"), if ip is a valid IPv6 address\n- the hexadecimal form of ip, without punctuation, if no other cases apply\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.MarshalText",
                    "documentation": {
                      "identifier": "IP.MarshalText",
                      "newPage": false,
                      "searchKey": "net.IP.MarshalText",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) MarshalText() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) MarshalText() ([]byte, error)\n```\n\nMarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String, with one exception: When len(ip) is zero, it returns an empty slice. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.UnmarshalText",
                    "documentation": {
                      "identifier": "IP.UnmarshalText",
                      "newPage": false,
                      "searchKey": "net.IP.UnmarshalText",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip *IP) UnmarshalText(text []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip *IP) UnmarshalText(text []byte) error\n```\n\nUnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.Equal",
                    "documentation": {
                      "identifier": "IP.Equal",
                      "newPage": false,
                      "searchKey": "net.IP.Equal",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) Equal(x IP) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) Equal(x IP) bool\n```\n\nEqual reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IP.matchAddrFamily",
                    "documentation": {
                      "identifier": "IP.matchAddrFamily",
                      "newPage": false,
                      "searchKey": "net.IP.matchAddrFamily",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ip IP) matchAddrFamily(x IP) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ip IP) matchAddrFamily(x IP) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPMask",
              "documentation": {
                "identifier": "IPMask",
                "newPage": false,
                "searchKey": "net.IPMask",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type IPMask []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype IPMask []byte\n```\n\nAn IPMask is a bitmask that can be used to manipulate IP addresses for IP addressing and routing. \n\nSee type IPNet and func ParseCIDR for details. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#IPv4Mask",
                    "documentation": {
                      "identifier": "IPv4Mask",
                      "newPage": false,
                      "searchKey": "net.IPv4Mask",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func IPv4Mask(a, b, c, d byte) IPMask"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc IPv4Mask(a, b, c, d byte) IPMask\n```\n\nIPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#CIDRMask",
                    "documentation": {
                      "identifier": "CIDRMask",
                      "newPage": false,
                      "searchKey": "net.CIDRMask",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func CIDRMask(ones, bits int) IPMask"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc CIDRMask(ones, bits int) IPMask\n```\n\nCIDRMask returns an IPMask consisting of 'ones' 1 bits followed by 0s up to a total length of 'bits' bits. For a mask of this form, CIDRMask is the inverse of IPMask.Size. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#networkNumberAndMask",
                    "documentation": {
                      "identifier": "networkNumberAndMask",
                      "newPage": false,
                      "searchKey": "net.networkNumberAndMask",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func networkNumberAndMask(n *IPNet) (ip IP, m IPMask)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc networkNumberAndMask(n *IPNet) (ip IP, m IPMask)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPMask.Size",
                    "documentation": {
                      "identifier": "IPMask.Size",
                      "newPage": false,
                      "searchKey": "net.IPMask.Size",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m IPMask) Size() (ones, bits int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m IPMask) Size() (ones, bits int)\n```\n\nSize returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPMask.String",
                    "documentation": {
                      "identifier": "IPMask.String",
                      "newPage": false,
                      "searchKey": "net.IPMask.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m IPMask) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m IPMask) String() string\n```\n\nString returns the hexadecimal form of m, with no punctuation. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPNet",
              "documentation": {
                "identifier": "IPNet",
                "newPage": false,
                "searchKey": "net.IPNet",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type IPNet struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype IPNet struct {\n\tIP   IP     // network number\n\tMask IPMask // network mask\n}\n```\n\nAn IPNet represents an IP network. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#mustCIDR",
                    "documentation": {
                      "identifier": "mustCIDR",
                      "newPage": false,
                      "searchKey": "net.mustCIDR",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mustCIDR(s string) *IPNet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mustCIDR(s string) *IPNet\n```\n\nmustCIDR calls ParseCIDR and panics on any error, or if the network is not IPv6. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ParseCIDR",
                    "documentation": {
                      "identifier": "ParseCIDR",
                      "newPage": false,
                      "searchKey": "net.ParseCIDR",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseCIDR(s string) (IP, *IPNet, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseCIDR(s string) (IP, *IPNet, error)\n```\n\nParseCIDR parses s as a CIDR notation IP address and prefix length, like \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in RFC 4632 and RFC 4291. \n\nIt returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(\"192.0.2.1/24\") returns the IP address 192.0.2.1 and the network 192.0.2.0/24. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPNet.Contains",
                    "documentation": {
                      "identifier": "IPNet.Contains",
                      "newPage": false,
                      "searchKey": "net.IPNet.Contains",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n *IPNet) Contains(ip IP) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n *IPNet) Contains(ip IP) bool\n```\n\nContains reports whether the network includes ip. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPNet.Network",
                    "documentation": {
                      "identifier": "IPNet.Network",
                      "newPage": false,
                      "searchKey": "net.IPNet.Network",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n *IPNet) Network() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n *IPNet) Network() string\n```\n\nNetwork returns the address's network name, \"ip+net\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPNet.String",
                    "documentation": {
                      "identifier": "IPNet.String",
                      "newPage": false,
                      "searchKey": "net.IPNet.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n *IPNet) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n *IPNet) String() string\n```\n\nString returns the CIDR notation of n like \"192.0.2.0/24\" or \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like \"198.51.100.0/c000ff00\". \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPAddr",
              "documentation": {
                "identifier": "IPAddr",
                "newPage": false,
                "searchKey": "net.IPAddr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type IPAddr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype IPAddr struct {\n\tIP   IP\n\tZone string // IPv6 scoped addressing zone\n}\n```\n\nIPAddr represents the address of an IP end point. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ResolveIPAddr",
                    "documentation": {
                      "identifier": "ResolveIPAddr",
                      "newPage": false,
                      "searchKey": "net.ResolveIPAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ResolveIPAddr(network, address string) (*IPAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ResolveIPAddr(network, address string) (*IPAddr, error)\n```\n\nResolveIPAddr returns an address of IP end point. \n\nThe network must be an IP network name. \n\nIf the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses. \n\nSee func Dial for a description of the network and address parameters. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPAddr.Network",
                    "documentation": {
                      "identifier": "IPAddr.Network",
                      "newPage": false,
                      "searchKey": "net.IPAddr.Network",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *IPAddr) Network() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *IPAddr) Network() string\n```\n\nNetwork returns the address's network name, \"ip\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPAddr.String",
                    "documentation": {
                      "identifier": "IPAddr.String",
                      "newPage": false,
                      "searchKey": "net.IPAddr.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *IPAddr) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *IPAddr) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPAddr.isWildcard",
                    "documentation": {
                      "identifier": "IPAddr.isWildcard",
                      "newPage": false,
                      "searchKey": "net.IPAddr.isWildcard",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *IPAddr) isWildcard() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *IPAddr) isWildcard() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPAddr.opAddr",
                    "documentation": {
                      "identifier": "IPAddr.opAddr",
                      "newPage": false,
                      "searchKey": "net.IPAddr.opAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *IPAddr) opAddr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *IPAddr) opAddr() Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPAddr.family",
                    "documentation": {
                      "identifier": "IPAddr.family",
                      "newPage": false,
                      "searchKey": "net.IPAddr.family",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *IPAddr) family() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *IPAddr) family() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPAddr.sockaddr",
                    "documentation": {
                      "identifier": "IPAddr.sockaddr",
                      "newPage": false,
                      "searchKey": "net.IPAddr.sockaddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *IPAddr) sockaddr(family int) (syscall.Sockaddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *IPAddr) sockaddr(family int) (syscall.Sockaddr, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPAddr.toLocal",
                    "documentation": {
                      "identifier": "IPAddr.toLocal",
                      "newPage": false,
                      "searchKey": "net.IPAddr.toLocal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *IPAddr) toLocal(net string) sockaddr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *IPAddr) toLocal(net string) sockaddr\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#IPConn",
              "documentation": {
                "identifier": "IPConn",
                "newPage": false,
                "searchKey": "net.IPConn",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type IPConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype IPConn struct {\n\tconn\n}\n```\n\nIPConn is the implementation of the Conn and PacketConn interfaces for IP network connections. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newIPConn",
                    "documentation": {
                      "identifier": "newIPConn",
                      "newPage": false,
                      "searchKey": "net.newIPConn",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newIPConn(fd *netFD) *IPConn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newIPConn(fd *netFD) *IPConn\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DialIP",
                    "documentation": {
                      "identifier": "DialIP",
                      "newPage": false,
                      "searchKey": "net.DialIP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)\n```\n\nDialIP acts like Dial for IP networks. \n\nThe network must be an IP network name; see func Dial for details. \n\nIf laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ListenIP",
                    "documentation": {
                      "identifier": "ListenIP",
                      "newPage": false,
                      "searchKey": "net.ListenIP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ListenIP(network string, laddr *IPAddr) (*IPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ListenIP(network string, laddr *IPAddr) (*IPConn, error)\n```\n\nListenIP acts like ListenPacket for IP networks. \n\nThe network must be an IP network name; see func Dial for details. \n\nIf the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.SyscallConn",
                    "documentation": {
                      "identifier": "IPConn.SyscallConn",
                      "newPage": false,
                      "searchKey": "net.IPConn.SyscallConn",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) SyscallConn() (syscall.RawConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) SyscallConn() (syscall.RawConn, error)\n```\n\nSyscallConn returns a raw network connection. This implements the syscall.Conn interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.ReadFromIP",
                    "documentation": {
                      "identifier": "IPConn.ReadFromIP",
                      "newPage": false,
                      "searchKey": "net.IPConn.ReadFromIP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)\n```\n\nReadFromIP acts like ReadFrom but returns an IPAddr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.ReadFrom",
                    "documentation": {
                      "identifier": "IPConn.ReadFrom",
                      "newPage": false,
                      "searchKey": "net.IPConn.ReadFrom",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) ReadFrom(b []byte) (int, Addr, error)\n```\n\nReadFrom implements the PacketConn ReadFrom method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.ReadMsgIP",
                    "documentation": {
                      "identifier": "IPConn.ReadMsgIP",
                      "newPage": false,
                      "searchKey": "net.IPConn.ReadMsgIP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)\n```\n\nReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message. \n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.WriteToIP",
                    "documentation": {
                      "identifier": "IPConn.WriteToIP",
                      "newPage": false,
                      "searchKey": "net.IPConn.WriteToIP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)\n```\n\nWriteToIP acts like WriteTo but takes an IPAddr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.WriteTo",
                    "documentation": {
                      "identifier": "IPConn.WriteTo",
                      "newPage": false,
                      "searchKey": "net.IPConn.WriteTo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)\n```\n\nWriteTo implements the PacketConn WriteTo method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.WriteMsgIP",
                    "documentation": {
                      "identifier": "IPConn.WriteMsgIP",
                      "newPage": false,
                      "searchKey": "net.IPConn.WriteMsgIP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)\n```\n\nWriteMsgIP writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. \n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.readFrom",
                    "documentation": {
                      "identifier": "IPConn.readFrom",
                      "newPage": false,
                      "searchKey": "net.IPConn.readFrom",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) readFrom(b []byte) (int, *IPAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) readFrom(b []byte) (int, *IPAddr, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.readMsg",
                    "documentation": {
                      "identifier": "IPConn.readMsg",
                      "newPage": false,
                      "searchKey": "net.IPConn.readMsg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) readMsg(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) readMsg(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.writeTo",
                    "documentation": {
                      "identifier": "IPConn.writeTo",
                      "newPage": false,
                      "searchKey": "net.IPConn.writeTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) writeTo(b []byte, addr *IPAddr) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) writeTo(b []byte, addr *IPAddr) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#IPConn.writeMsg",
                    "documentation": {
                      "identifier": "IPConn.writeMsg",
                      "newPage": false,
                      "searchKey": "net.IPConn.writeMsg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *IPConn) writeMsg(b, oob []byte, addr *IPAddr) (n, oobn int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *IPConn) writeMsg(b, oob []byte, addr *IPAddr) (n, oobn int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipStackCapabilities",
              "documentation": {
                "identifier": "ipStackCapabilities",
                "newPage": false,
                "searchKey": "net.ipStackCapabilities",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ipStackCapabilities struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ipStackCapabilities struct {\n\tsync.Once             // guards following\n\tipv4Enabled           bool\n\tipv6Enabled           bool\n\tipv4MappedIPv6Enabled bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ipStackCapabilities.probe",
                    "documentation": {
                      "identifier": "ipStackCapabilities.probe",
                      "newPage": false,
                      "searchKey": "net.ipStackCapabilities.probe",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ipStackCapabilities) probe()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ipStackCapabilities) probe()\n```\n\nprobe probes IPv4, IPv6 and IPv4-mapped IPv6 communication capabilities which are controlled by the IPV6_V6ONLY socket option and kernel configuration. \n\nShould we try to use the IPv4 socket interface if we're only dealing with IPv4 sockets? As long as the host system understands IPv4-mapped IPv6, it's okay to pass IPv4-mapped IPv6 addresses to the IPv6 interface. That simplifies our code and is most general. Unfortunately, we need to run on kernels built without IPv6 support too. So probe the kernel to figure it out. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#addrList",
              "documentation": {
                "identifier": "addrList",
                "newPage": false,
                "searchKey": "net.addrList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type addrList []net.Addr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype addrList []Addr\n```\n\nAn addrList represents a list of network endpoint addresses. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#filterAddrList",
                    "documentation": {
                      "identifier": "filterAddrList",
                      "newPage": false,
                      "searchKey": "net.filterAddrList",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func filterAddrList(filter func(IPAddr) bool, ips []IPAddr, inetaddr func(IPAddr) Addr, originalAddr string) (addrList, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc filterAddrList(filter func(IPAddr) bool, ips []IPAddr, inetaddr func(IPAddr) Addr, originalAddr string) (addrList, error)\n```\n\nfilterAddrList applies a filter to a list of IP addresses, yielding a list of Addr objects. Known filters are nil, ipv4only, and ipv6only. It returns every address when the filter is nil. The result contains at least one address when error is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#addrList.forResolve",
                    "documentation": {
                      "identifier": "addrList.forResolve",
                      "newPage": false,
                      "searchKey": "net.addrList.forResolve",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (addrs addrList) forResolve(network, addr string) Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (addrs addrList) forResolve(network, addr string) Addr\n```\n\nforResolve returns the most appropriate address in address for a call to ResolveTCPAddr, ResolveUDPAddr, or ResolveIPAddr. IPv4 is preferred, unless addr contains an IPv6 literal. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#addrList.first",
                    "documentation": {
                      "identifier": "addrList.first",
                      "newPage": false,
                      "searchKey": "net.addrList.first",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (addrs addrList) first(strategy func(Addr) bool) Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (addrs addrList) first(strategy func(Addr) bool) Addr\n```\n\nfirst returns the first address which satisfies strategy, or if none do, then the first address of any kind. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#addrList.partition",
                    "documentation": {
                      "identifier": "addrList.partition",
                      "newPage": false,
                      "searchKey": "net.addrList.partition",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (addrs addrList) partition(strategy func(Addr) bool) (primaries, fallbacks addrList)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (addrs addrList) partition(strategy func(Addr) bool) (primaries, fallbacks addrList)\n```\n\npartition divides an address list into two categories, using a strategy function to assign a boolean label to each address. The first address, and any with a matching label, are returned as primaries, while addresses with the opposite label are returned as fallbacks. For non-empty inputs, primaries is guaranteed to be non-empty. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#Resolver",
              "documentation": {
                "identifier": "Resolver",
                "newPage": false,
                "searchKey": "net.Resolver",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Resolver struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Resolver struct {\n\t// PreferGo controls whether Go's built-in DNS resolver is preferred\n\t// on platforms where it's available. It is equivalent to setting\n\t// GODEBUG=netdns=go, but scoped to just this resolver.\n\tPreferGo bool\n\n\t// StrictErrors controls the behavior of temporary errors\n\t// (including timeout, socket errors, and SERVFAIL) when using\n\t// Go's built-in resolver. For a query composed of multiple\n\t// sub-queries (such as an A+AAAA address lookup, or walking the\n\t// DNS search list), this option causes such errors to abort the\n\t// whole query instead of returning a partial result. This is\n\t// not enabled by default because it may affect compatibility\n\t// with resolvers that process AAAA queries incorrectly.\n\tStrictErrors bool\n\n\t// Dial optionally specifies an alternate dialer for use by\n\t// Go's built-in DNS resolver to make TCP and UDP connections\n\t// to DNS services. The host in the address parameter will\n\t// always be a literal IP address and not a host name, and the\n\t// port in the address parameter will be a literal port number\n\t// and not a service name.\n\t// If the Conn returned is also a PacketConn, sent and received DNS\n\t// messages must adhere to RFC 1035 section 4.2.1, \"UDP usage\".\n\t// Otherwise, DNS messages transmitted over Conn must adhere\n\t// to RFC 7766 section 5, \"Transport Protocol Selection\".\n\t// If nil, the default dialer is used.\n\tDial func(ctx context.Context, network, address string) (Conn, error)\n\n\t// lookupGroup merges LookupIPAddr calls together for lookups for the same\n\t// host. The lookupGroup key is the LookupIPAddr.host argument.\n\t// The return values are ([]IPAddr, error).\n\tlookupGroup singleflight.Group\n}\n```\n\nA Resolver looks up names and numbers. \n\nA nil *Resolver is equivalent to a zero Resolver. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#Resolver.resolveAddrList",
                    "documentation": {
                      "identifier": "Resolver.resolveAddrList",
                      "newPage": false,
                      "searchKey": "net.Resolver.resolveAddrList",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) resolveAddrList(ctx context.Context, op, network, addr string, hint Addr) (addrList, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) resolveAddrList(ctx context.Context, op, network, addr string, hint Addr) (addrList, error)\n```\n\nresolveAddrList resolves addr using hint and returns a list of addresses. The result contains at least one address when error is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.exchange",
                    "documentation": {
                      "identifier": "Resolver.exchange",
                      "newPage": false,
                      "searchKey": "net.Resolver.exchange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) exchange(ctx context.Context, server string, q dnsmessage.Question, timeout time.Duration, useTCP bool) (dnsmessage.Parser, dnsmessage.Header, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) exchange(ctx context.Context, server string, q dnsmessage.Question, timeout time.Duration, useTCP bool) (dnsmessage.Parser, dnsmessage.Header, error)\n```\n\nexchange sends a query on the connection and hopes for a response. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.tryOneName",
                    "documentation": {
                      "identifier": "Resolver.tryOneName",
                      "newPage": false,
                      "searchKey": "net.Resolver.tryOneName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) tryOneName(ctx context.Context, cfg *dnsConfig, name string, qtype dnsmessage.Type) (dnsmessage.Parser, string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) tryOneName(ctx context.Context, cfg *dnsConfig, name string, qtype dnsmessage.Type) (dnsmessage.Parser, string, error)\n```\n\nDo a lookup for a single name, which must be rooted (otherwise answer will not find the answers). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookup",
                    "documentation": {
                      "identifier": "Resolver.lookup",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookup(ctx context.Context, name string, qtype dnsmessage.Type) (dnsmessage.Parser, string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookup(ctx context.Context, name string, qtype dnsmessage.Type) (dnsmessage.Parser, string, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.goLookupHost",
                    "documentation": {
                      "identifier": "Resolver.goLookupHost",
                      "newPage": false,
                      "searchKey": "net.Resolver.goLookupHost",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) goLookupHost(ctx context.Context, name string) (addrs []string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) goLookupHost(ctx context.Context, name string) (addrs []string, err error)\n```\n\ngoLookupHost is the native Go implementation of LookupHost. Used only if cgoLookupHost refuses to handle the request (that is, only if cgoLookupHost is the stub in cgo_stub.go). Normally we let cgo use the C library resolver instead of depending on our lookup code, so that Go and C get the same answers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.goLookupHostOrder",
                    "documentation": {
                      "identifier": "Resolver.goLookupHostOrder",
                      "newPage": false,
                      "searchKey": "net.Resolver.goLookupHostOrder",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) goLookupHostOrder(ctx context.Context, name string, order hostLookupOrder) (addrs []string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) goLookupHostOrder(ctx context.Context, name string, order hostLookupOrder) (addrs []string, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.goLookupIP",
                    "documentation": {
                      "identifier": "Resolver.goLookupIP",
                      "newPage": false,
                      "searchKey": "net.Resolver.goLookupIP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) goLookupIP(ctx context.Context, network, host string) (addrs []IPAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) goLookupIP(ctx context.Context, network, host string) (addrs []IPAddr, err error)\n```\n\ngoLookupIP is the native Go implementation of LookupIP. The libc versions are in cgo_*.go. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.goLookupIPCNAMEOrder",
                    "documentation": {
                      "identifier": "Resolver.goLookupIPCNAMEOrder",
                      "newPage": false,
                      "searchKey": "net.Resolver.goLookupIPCNAMEOrder",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) goLookupIPCNAMEOrder(ctx context.Context, network, name string, order hostLookupOrder) (addrs []IPAddr, cname dnsmessage.Name, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) goLookupIPCNAMEOrder(ctx context.Context, network, name string, order hostLookupOrder) (addrs []IPAddr, cname dnsmessage.Name, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.goLookupCNAME",
                    "documentation": {
                      "identifier": "Resolver.goLookupCNAME",
                      "newPage": false,
                      "searchKey": "net.Resolver.goLookupCNAME",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) goLookupCNAME(ctx context.Context, host string) (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) goLookupCNAME(ctx context.Context, host string) (string, error)\n```\n\ngoLookupCNAME is the native Go (non-cgo) implementation of LookupCNAME. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.goLookupPTR",
                    "documentation": {
                      "identifier": "Resolver.goLookupPTR",
                      "newPage": false,
                      "searchKey": "net.Resolver.goLookupPTR",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) goLookupPTR(ctx context.Context, addr string) ([]string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) goLookupPTR(ctx context.Context, addr string) ([]string, error)\n```\n\ngoLookupPTR is the native Go implementation of LookupAddr. Used only if cgoLookupPTR refuses to handle the request (that is, only if cgoLookupPTR is the stub in cgo_stub.go). Normally we let cgo use the C library resolver instead of depending on our lookup code, so that Go and C get the same answers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.internetAddrList",
                    "documentation": {
                      "identifier": "Resolver.internetAddrList",
                      "newPage": false,
                      "searchKey": "net.Resolver.internetAddrList",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) internetAddrList(ctx context.Context, net, addr string) (addrList, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) internetAddrList(ctx context.Context, net, addr string) (addrList, error)\n```\n\ninternetAddrList resolves addr, which may be a literal IP address or a DNS name, and returns a list of internet protocol family addresses. The result contains at least one address when error is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.preferGo",
                    "documentation": {
                      "identifier": "Resolver.preferGo",
                      "newPage": false,
                      "searchKey": "net.Resolver.preferGo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) preferGo() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) preferGo() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.strictErrors",
                    "documentation": {
                      "identifier": "Resolver.strictErrors",
                      "newPage": false,
                      "searchKey": "net.Resolver.strictErrors",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) strictErrors() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) strictErrors() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.getLookupGroup",
                    "documentation": {
                      "identifier": "Resolver.getLookupGroup",
                      "newPage": false,
                      "searchKey": "net.Resolver.getLookupGroup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) getLookupGroup() *singleflight.Group"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) getLookupGroup() *singleflight.Group\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupHost",
                    "documentation": {
                      "identifier": "Resolver.LookupHost",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupHost",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)\n```\n\nLookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupIPAddr",
                    "documentation": {
                      "identifier": "Resolver.LookupIPAddr",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupIPAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)\n```\n\nLookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupIP",
                    "documentation": {
                      "identifier": "Resolver.LookupIP",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupIP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupIP(ctx context.Context, network, host string) ([]IP, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupIP(ctx context.Context, network, host string) ([]IP, error)\n```\n\nLookupIP looks up host for the given network using the local resolver. It returns a slice of that host's IP addresses of the type specified by network. network must be one of \"ip\", \"ip4\" or \"ip6\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupIPAddr",
                    "documentation": {
                      "identifier": "Resolver.lookupIPAddr",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupIPAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupIPAddr(ctx context.Context, network, host string) ([]IPAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupIPAddr(ctx context.Context, network, host string) ([]IPAddr, error)\n```\n\nlookupIPAddr looks up host using the local resolver and particular network. It returns a slice of that host's IPv4 and IPv6 addresses. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupPort",
                    "documentation": {
                      "identifier": "Resolver.LookupPort",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupPort",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)\n```\n\nLookupPort looks up the port for the given network and service. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupCNAME",
                    "documentation": {
                      "identifier": "Resolver.LookupCNAME",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupCNAME",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error)\n```\n\nLookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup. \n\nA canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS \"CNAME\" records, as long as host resolves to address records. \n\nThe returned canonical name is validated to be a properly formatted presentation-format domain name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupSRV",
                    "documentation": {
                      "identifier": "Resolver.LookupSRV",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupSRV",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error)\n```\n\nLookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority. \n\nLookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. \n\nThe returned service names are validated to be properly formatted presentation-format domain names. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupMX",
                    "documentation": {
                      "identifier": "Resolver.LookupMX",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupMX",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)\n```\n\nLookupMX returns the DNS MX records for the given domain name sorted by preference. \n\nThe returned mail server names are validated to be properly formatted presentation-format domain names. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupNS",
                    "documentation": {
                      "identifier": "Resolver.LookupNS",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupNS",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)\n```\n\nLookupNS returns the DNS NS records for the given domain name. \n\nThe returned name server names are validated to be properly formatted presentation-format domain names. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupTXT",
                    "documentation": {
                      "identifier": "Resolver.LookupTXT",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupTXT",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)\n```\n\nLookupTXT returns the DNS TXT records for the given domain name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.LookupAddr",
                    "documentation": {
                      "identifier": "Resolver.LookupAddr",
                      "newPage": false,
                      "searchKey": "net.Resolver.LookupAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error)\n```\n\nLookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. \n\nThe returned names are validated to be properly formatted presentation-format domain names. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.dial",
                    "documentation": {
                      "identifier": "Resolver.dial",
                      "newPage": false,
                      "searchKey": "net.Resolver.dial",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) dial(ctx context.Context, network, server string) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) dial(ctx context.Context, network, server string) (Conn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupHost",
                    "documentation": {
                      "identifier": "Resolver.lookupHost",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupHost",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupHost(ctx context.Context, host string) (addrs []string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupHost(ctx context.Context, host string) (addrs []string, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupIP",
                    "documentation": {
                      "identifier": "Resolver.lookupIP",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupIP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupIP(ctx context.Context, network, host string) (addrs []IPAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupIP(ctx context.Context, network, host string) (addrs []IPAddr, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupPort",
                    "documentation": {
                      "identifier": "Resolver.lookupPort",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupPort",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupPort(ctx context.Context, network, service string) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupPort(ctx context.Context, network, service string) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupCNAME",
                    "documentation": {
                      "identifier": "Resolver.lookupCNAME",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupCNAME",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupCNAME(ctx context.Context, name string) (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupCNAME(ctx context.Context, name string) (string, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupSRV",
                    "documentation": {
                      "identifier": "Resolver.lookupSRV",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupSRV",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupMX",
                    "documentation": {
                      "identifier": "Resolver.lookupMX",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupMX",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupMX(ctx context.Context, name string) ([]*MX, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupMX(ctx context.Context, name string) ([]*MX, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupNS",
                    "documentation": {
                      "identifier": "Resolver.lookupNS",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupNS",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupNS(ctx context.Context, name string) ([]*NS, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupNS(ctx context.Context, name string) ([]*NS, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupTXT",
                    "documentation": {
                      "identifier": "Resolver.lookupTXT",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupTXT",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupTXT(ctx context.Context, name string) ([]string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupTXT(ctx context.Context, name string) ([]string, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Resolver.lookupAddr",
                    "documentation": {
                      "identifier": "Resolver.lookupAddr",
                      "newPage": false,
                      "searchKey": "net.Resolver.lookupAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Resolver) lookupAddr(ctx context.Context, addr string) ([]string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Resolver) lookupAddr(ctx context.Context, addr string) ([]string, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#onlyValuesCtx",
              "documentation": {
                "identifier": "onlyValuesCtx",
                "newPage": false,
                "searchKey": "net.onlyValuesCtx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type onlyValuesCtx struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype onlyValuesCtx struct {\n\tcontext.Context\n\tlookupValues context.Context\n}\n```\n\nonlyValuesCtx is a context that uses an underlying context for value lookup if the underlying context hasn't yet expired. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#onlyValuesCtx.Value",
                    "documentation": {
                      "identifier": "onlyValuesCtx.Value",
                      "newPage": false,
                      "searchKey": "net.onlyValuesCtx.Value",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ovc *onlyValuesCtx) Value(key interface{}) interface{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ovc *onlyValuesCtx) Value(key interface{}) interface{}\n```\n\nValue performs a lookup if the original context hasn't expired. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#HardwareAddr",
              "documentation": {
                "identifier": "HardwareAddr",
                "newPage": false,
                "searchKey": "net.HardwareAddr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type HardwareAddr []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype HardwareAddr []byte\n```\n\nA HardwareAddr represents a physical hardware address. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ParseMAC",
                    "documentation": {
                      "identifier": "ParseMAC",
                      "newPage": false,
                      "searchKey": "net.ParseMAC",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseMAC(s string) (hw HardwareAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseMAC(s string) (hw HardwareAddr, err error)\n```\n\nParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats: \n\n```\n00:00:5e:00:53:01\n02:00:5e:10:00:00:00:01\n00:00:00:00:fe:80:00:00:00:00:00:00:02:00:5e:10:00:00:00:01\n00-00-5e-00-53-01\n02-00-5e-10-00-00-00-01\n00-00-00-00-fe-80-00-00-00-00-00-00-02-00-5e-10-00-00-00-01\n0000.5e00.5301\n0200.5e10.0000.0001\n0000.0000.fe80.0000.0000.0000.0200.5e10.0000.0001\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#HardwareAddr.String",
                    "documentation": {
                      "identifier": "HardwareAddr.String",
                      "newPage": false,
                      "searchKey": "net.HardwareAddr.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a HardwareAddr) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a HardwareAddr) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#Addr",
              "documentation": {
                "identifier": "Addr",
                "newPage": false,
                "searchKey": "net.Addr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Addr interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Addr interface {\n\tNetwork() string // name of the network (for example, \"tcp\", \"udp\")\n\tString() string  // string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\")\n}\n```\n\nAddr represents a network end point address. \n\nThe two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#sockaddrToIP",
                    "documentation": {
                      "identifier": "sockaddrToIP",
                      "newPage": false,
                      "searchKey": "net.sockaddrToIP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func sockaddrToIP(sa syscall.Sockaddr) Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc sockaddrToIP(sa syscall.Sockaddr) Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sockaddrToTCP",
                    "documentation": {
                      "identifier": "sockaddrToTCP",
                      "newPage": false,
                      "searchKey": "net.sockaddrToTCP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func sockaddrToTCP(sa syscall.Sockaddr) Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc sockaddrToTCP(sa syscall.Sockaddr) Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sockaddrToUDP",
                    "documentation": {
                      "identifier": "sockaddrToUDP",
                      "newPage": false,
                      "searchKey": "net.sockaddrToUDP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func sockaddrToUDP(sa syscall.Sockaddr) Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc sockaddrToUDP(sa syscall.Sockaddr) Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sockaddrToUnix",
                    "documentation": {
                      "identifier": "sockaddrToUnix",
                      "newPage": false,
                      "searchKey": "net.sockaddrToUnix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func sockaddrToUnix(sa syscall.Sockaddr) Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc sockaddrToUnix(sa syscall.Sockaddr) Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sockaddrToUnixgram",
                    "documentation": {
                      "identifier": "sockaddrToUnixgram",
                      "newPage": false,
                      "searchKey": "net.sockaddrToUnixgram",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func sockaddrToUnixgram(sa syscall.Sockaddr) Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc sockaddrToUnixgram(sa syscall.Sockaddr) Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#sockaddrToUnixpacket",
                    "documentation": {
                      "identifier": "sockaddrToUnixpacket",
                      "newPage": false,
                      "searchKey": "net.sockaddrToUnixpacket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func sockaddrToUnixpacket(sa syscall.Sockaddr) Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc sockaddrToUnixpacket(sa syscall.Sockaddr) Addr\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#Conn",
              "documentation": {
                "identifier": "Conn",
                "newPage": false,
                "searchKey": "net.Conn",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Conn interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Conn interface {\n\t// Read reads data from the connection.\n\t// Read can be made to time out and return an error after a fixed\n\t// time limit; see SetDeadline and SetReadDeadline.\n\tRead(b []byte) (n int, err error)\n\n\t// Write writes data to the connection.\n\t// Write can be made to time out and return an error after a fixed\n\t// time limit; see SetDeadline and SetWriteDeadline.\n\tWrite(b []byte) (n int, err error)\n\n\t// Close closes the connection.\n\t// Any blocked Read or Write operations will be unblocked and return errors.\n\tClose() error\n\n\t// LocalAddr returns the local network address.\n\tLocalAddr() Addr\n\n\t// RemoteAddr returns the remote network address.\n\tRemoteAddr() Addr\n\n\t// SetDeadline sets the read and write deadlines associated\n\t// with the connection. It is equivalent to calling both\n\t// SetReadDeadline and SetWriteDeadline.\n\t//\n\t// A deadline is an absolute time after which I/O operations\n\t// fail instead of blocking. The deadline applies to all future\n\t// and pending I/O, not just the immediately following call to\n\t// Read or Write. After a deadline has been exceeded, the\n\t// connection can be refreshed by setting a deadline in the future.\n\t//\n\t// If the deadline is exceeded a call to Read or Write or to other\n\t// I/O methods will return an error that wraps os.ErrDeadlineExceeded.\n\t// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).\n\t// The error's Timeout method will return true, but note that there\n\t// are other possible errors for which the Timeout method will\n\t// return true even if the deadline has not been exceeded.\n\t//\n\t// An idle timeout can be implemented by repeatedly extending\n\t// the deadline after successful Read or Write calls.\n\t//\n\t// A zero value for t means I/O operations will not time out.\n\tSetDeadline(t time.Time) error\n\n\t// SetReadDeadline sets the deadline for future Read calls\n\t// and any currently-blocked Read call.\n\t// A zero value for t means Read will not time out.\n\tSetReadDeadline(t time.Time) error\n\n\t// SetWriteDeadline sets the deadline for future Write calls\n\t// and any currently-blocked Write call.\n\t// Even if write times out, it may return n > 0, indicating that\n\t// some of the data was successfully written.\n\t// A zero value for t means Write will not time out.\n\tSetWriteDeadline(t time.Time) error\n}\n```\n\nConn is a generic stream-oriented network connection. \n\nMultiple goroutines may invoke methods on a Conn simultaneously. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#Dial",
                    "documentation": {
                      "identifier": "Dial",
                      "newPage": false,
                      "searchKey": "net.Dial",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Dial(network, address string) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Dial(network, address string) (Conn, error)\n```\n\nDial connects to the address on the named network. \n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only), \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\" (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and \"unixpacket\". \n\nFor TCP and UDP networks, the address has the form \"host:port\". The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\". The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions JoinHostPort and SplitHostPort manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds. \n\nExamples: \n\n```\nDial(\"tcp\", \"golang.org:http\")\nDial(\"tcp\", \"192.0.2.1:http\")\nDial(\"tcp\", \"198.51.100.1:80\")\nDial(\"udp\", \"[2001:db8::1]:domain\")\nDial(\"udp\", \"[fe80::1%lo0]:53\")\nDial(\"tcp\", \":80\")\n\n```\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed by a colon and a literal protocol number or a protocol name, and the address has the form \"host\". The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as \"0\" or \"255\". \n\nExamples: \n\n```\nDial(\"ip4:1\", \"192.0.2.1\")\nDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\nDial(\"ip6:58\", \"fe80::1%lo0\")\n\n```\nFor TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for TCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is assumed. \n\nFor Unix networks, the address must be a file system path. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DialTimeout",
                    "documentation": {
                      "identifier": "DialTimeout",
                      "newPage": false,
                      "searchKey": "net.DialTimeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func DialTimeout(network, address string, timeout time.Duration) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc DialTimeout(network, address string, timeout time.Duration) (Conn, error)\n```\n\nDialTimeout acts like Dial but takes a timeout. \n\nThe timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. \n\nSee func Dial for a description of the network and address parameters. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#FileConn",
                    "documentation": {
                      "identifier": "FileConn",
                      "newPage": false,
                      "searchKey": "net.FileConn",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FileConn(f *os.File) (c Conn, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FileConn(f *os.File) (c Conn, err error)\n```\n\nFileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#fileConn",
                    "documentation": {
                      "identifier": "fileConn",
                      "newPage": false,
                      "searchKey": "net.fileConn",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func fileConn(f *os.File) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc fileConn(f *os.File) (Conn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Pipe",
                    "documentation": {
                      "identifier": "Pipe",
                      "newPage": false,
                      "searchKey": "net.Pipe",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Pipe() (Conn, Conn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Pipe() (Conn, Conn)\n```\n\nPipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#conn",
              "documentation": {
                "identifier": "conn",
                "newPage": false,
                "searchKey": "net.conn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type conn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype conn struct {\n\tfd *netFD\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#conn.ok",
                    "documentation": {
                      "identifier": "conn.ok",
                      "newPage": false,
                      "searchKey": "net.conn.ok",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) ok() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) ok() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.Read",
                    "documentation": {
                      "identifier": "conn.Read",
                      "newPage": false,
                      "searchKey": "net.conn.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) Read(b []byte) (int, error)\n```\n\nRead implements the Conn Read method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.Write",
                    "documentation": {
                      "identifier": "conn.Write",
                      "newPage": false,
                      "searchKey": "net.conn.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) Write(b []byte) (int, error)\n```\n\nWrite implements the Conn Write method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.Close",
                    "documentation": {
                      "identifier": "conn.Close",
                      "newPage": false,
                      "searchKey": "net.conn.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) Close() error\n```\n\nClose closes the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.LocalAddr",
                    "documentation": {
                      "identifier": "conn.LocalAddr",
                      "newPage": false,
                      "searchKey": "net.conn.LocalAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) LocalAddr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) LocalAddr() Addr\n```\n\nLocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.RemoteAddr",
                    "documentation": {
                      "identifier": "conn.RemoteAddr",
                      "newPage": false,
                      "searchKey": "net.conn.RemoteAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) RemoteAddr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) RemoteAddr() Addr\n```\n\nRemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.SetDeadline",
                    "documentation": {
                      "identifier": "conn.SetDeadline",
                      "newPage": false,
                      "searchKey": "net.conn.SetDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) SetDeadline(t time.Time) error\n```\n\nSetDeadline implements the Conn SetDeadline method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.SetReadDeadline",
                    "documentation": {
                      "identifier": "conn.SetReadDeadline",
                      "newPage": false,
                      "searchKey": "net.conn.SetReadDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) SetReadDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) SetReadDeadline(t time.Time) error\n```\n\nSetReadDeadline implements the Conn SetReadDeadline method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.SetWriteDeadline",
                    "documentation": {
                      "identifier": "conn.SetWriteDeadline",
                      "newPage": false,
                      "searchKey": "net.conn.SetWriteDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) SetWriteDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) SetWriteDeadline(t time.Time) error\n```\n\nSetWriteDeadline implements the Conn SetWriteDeadline method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.SetReadBuffer",
                    "documentation": {
                      "identifier": "conn.SetReadBuffer",
                      "newPage": false,
                      "searchKey": "net.conn.SetReadBuffer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) SetReadBuffer(bytes int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) SetReadBuffer(bytes int) error\n```\n\nSetReadBuffer sets the size of the operating system's receive buffer associated with the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.SetWriteBuffer",
                    "documentation": {
                      "identifier": "conn.SetWriteBuffer",
                      "newPage": false,
                      "searchKey": "net.conn.SetWriteBuffer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) SetWriteBuffer(bytes int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) SetWriteBuffer(bytes int) error\n```\n\nSetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.File",
                    "documentation": {
                      "identifier": "conn.File",
                      "newPage": false,
                      "searchKey": "net.conn.File",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) File() (f *os.File, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) File() (f *os.File, err error)\n```\n\nFile returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. \n\nThe returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#conn.writeBuffers",
                    "documentation": {
                      "identifier": "conn.writeBuffers",
                      "newPage": false,
                      "searchKey": "net.conn.writeBuffers",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) writeBuffers(v *Buffers) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) writeBuffers(v *Buffers) (int64, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#PacketConn",
              "documentation": {
                "identifier": "PacketConn",
                "newPage": false,
                "searchKey": "net.PacketConn",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type PacketConn interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PacketConn interface {\n\t// ReadFrom reads a packet from the connection,\n\t// copying the payload into p. It returns the number of\n\t// bytes copied into p and the return address that\n\t// was on the packet.\n\t// It returns the number of bytes read (0 <= n <= len(p))\n\t// and any error encountered. Callers should always process\n\t// the n > 0 bytes returned before considering the error err.\n\t// ReadFrom can be made to time out and return an error after a\n\t// fixed time limit; see SetDeadline and SetReadDeadline.\n\tReadFrom(p []byte) (n int, addr Addr, err error)\n\n\t// WriteTo writes a packet with payload p to addr.\n\t// WriteTo can be made to time out and return an Error after a\n\t// fixed time limit; see SetDeadline and SetWriteDeadline.\n\t// On packet-oriented connections, write timeouts are rare.\n\tWriteTo(p []byte, addr Addr) (n int, err error)\n\n\t// Close closes the connection.\n\t// Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.\n\tClose() error\n\n\t// LocalAddr returns the local network address.\n\tLocalAddr() Addr\n\n\t// SetDeadline sets the read and write deadlines associated\n\t// with the connection. It is equivalent to calling both\n\t// SetReadDeadline and SetWriteDeadline.\n\t//\n\t// A deadline is an absolute time after which I/O operations\n\t// fail instead of blocking. The deadline applies to all future\n\t// and pending I/O, not just the immediately following call to\n\t// Read or Write. After a deadline has been exceeded, the\n\t// connection can be refreshed by setting a deadline in the future.\n\t//\n\t// If the deadline is exceeded a call to Read or Write or to other\n\t// I/O methods will return an error that wraps os.ErrDeadlineExceeded.\n\t// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).\n\t// The error's Timeout method will return true, but note that there\n\t// are other possible errors for which the Timeout method will\n\t// return true even if the deadline has not been exceeded.\n\t//\n\t// An idle timeout can be implemented by repeatedly extending\n\t// the deadline after successful ReadFrom or WriteTo calls.\n\t//\n\t// A zero value for t means I/O operations will not time out.\n\tSetDeadline(t time.Time) error\n\n\t// SetReadDeadline sets the deadline for future ReadFrom calls\n\t// and any currently-blocked ReadFrom call.\n\t// A zero value for t means ReadFrom will not time out.\n\tSetReadDeadline(t time.Time) error\n\n\t// SetWriteDeadline sets the deadline for future WriteTo calls\n\t// and any currently-blocked WriteTo call.\n\t// Even if write times out, it may return n > 0, indicating that\n\t// some of the data was successfully written.\n\t// A zero value for t means WriteTo will not time out.\n\tSetWriteDeadline(t time.Time) error\n}\n```\n\nPacketConn is a generic packet-oriented network connection. \n\nMultiple goroutines may invoke methods on a PacketConn simultaneously. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ListenPacket",
                    "documentation": {
                      "identifier": "ListenPacket",
                      "newPage": false,
                      "searchKey": "net.ListenPacket",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ListenPacket(network, address string) (PacketConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ListenPacket(network, address string) (PacketConn, error)\n```\n\nListenPacket announces on the local network address. \n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP transport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by a colon and a literal protocol number or a protocol name, as in \"ip:1\" or \"ip:icmp\". \n\nFor UDP and IP networks, if the host in the address parameter is empty or a literal unspecified IP address, ListenPacket listens on all available IP addresses of the local system except multicast IP addresses. To only use IPv4, use network \"udp4\" or \"ip4:proto\". The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or \"0\", as in \"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen. The LocalAddr method of PacketConn can be used to discover the chosen port. \n\nSee func Dial for a description of the network and address parameters. \n\nListenPacket uses context.Background internally; to specify the context, use ListenConfig.ListenPacket. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#FilePacketConn",
                    "documentation": {
                      "identifier": "FilePacketConn",
                      "newPage": false,
                      "searchKey": "net.FilePacketConn",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FilePacketConn(f *os.File) (c PacketConn, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FilePacketConn(f *os.File) (c PacketConn, err error)\n```\n\nFilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#filePacketConn",
                    "documentation": {
                      "identifier": "filePacketConn",
                      "newPage": false,
                      "searchKey": "net.filePacketConn",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func filePacketConn(f *os.File) (PacketConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc filePacketConn(f *os.File) (PacketConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#newLocalPacketListener",
                    "documentation": {
                      "identifier": "newLocalPacketListener",
                      "newPage": false,
                      "searchKey": "net.newLocalPacketListener",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newLocalPacketListener(network string) (PacketConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newLocalPacketListener(network string) (PacketConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#Listener",
              "documentation": {
                "identifier": "Listener",
                "newPage": false,
                "searchKey": "net.Listener",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Listener interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Listener interface {\n\t// Accept waits for and returns the next connection to the listener.\n\tAccept() (Conn, error)\n\n\t// Close closes the listener.\n\t// Any blocked Accept operations will be unblocked and return errors.\n\tClose() error\n\n\t// Addr returns the listener's network address.\n\tAddr() Addr\n}\n```\n\nA Listener is a generic network listener for stream-oriented protocols. \n\nMultiple goroutines may invoke methods on a Listener simultaneously. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#Listen",
                    "documentation": {
                      "identifier": "Listen",
                      "newPage": false,
                      "searchKey": "net.Listen",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Listen(network, address string) (Listener, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Listen(network, address string) (Listener, error)\n```\n\nListen announces on the local network address. \n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\". \n\nFor TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network \"tcp4\". The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or \"0\", as in \"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen. The Addr method of Listener can be used to discover the chosen port. \n\nSee func Dial for a description of the network and address parameters. \n\nListen uses context.Background internally; to specify the context, use ListenConfig.Listen. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#FileListener",
                    "documentation": {
                      "identifier": "FileListener",
                      "newPage": false,
                      "searchKey": "net.FileListener",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FileListener(f *os.File) (ln Listener, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FileListener(f *os.File) (ln Listener, err error)\n```\n\nFileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#fileListener",
                    "documentation": {
                      "identifier": "fileListener",
                      "newPage": false,
                      "searchKey": "net.fileListener",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func fileListener(f *os.File) (Listener, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc fileListener(f *os.File) (Listener, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#newLocalListener",
                    "documentation": {
                      "identifier": "newLocalListener",
                      "newPage": false,
                      "searchKey": "net.newLocalListener",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newLocalListener(network string) (Listener, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newLocalListener(network string) (Listener, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#Error",
              "documentation": {
                "identifier": "Error",
                "newPage": false,
                "searchKey": "net.Error",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Error interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Error interface {\n\terror\n\tTimeout() bool   // Is the error a timeout?\n\tTemporary() bool // Is the error temporary?\n}\n```\n\nAn Error represents a network error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#OpError",
              "documentation": {
                "identifier": "OpError",
                "newPage": false,
                "searchKey": "net.OpError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type OpError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype OpError struct {\n\t// Op is the operation which caused the error, such as\n\t// \"read\" or \"write\".\n\tOp string\n\n\t// Net is the network type on which this error occurred,\n\t// such as \"tcp\" or \"udp6\".\n\tNet string\n\n\t// For operations involving a remote network connection, like\n\t// Dial, Read, or Write, Source is the corresponding local\n\t// network address.\n\tSource Addr\n\n\t// Addr is the network address for which this error occurred.\n\t// For local operations, like Listen or SetDeadline, Addr is\n\t// the address of the local endpoint being manipulated.\n\t// For operations involving a remote network connection, like\n\t// Dial, Read, or Write, Addr is the remote address of that\n\t// connection.\n\tAddr Addr\n\n\t// Err is the error that occurred during the operation.\n\t// The Error method panics if the error is nil.\n\tErr error\n}\n```\n\nOpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#OpError.Unwrap",
                    "documentation": {
                      "identifier": "OpError.Unwrap",
                      "newPage": false,
                      "searchKey": "net.OpError.Unwrap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *OpError) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *OpError) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#OpError.Error",
                    "documentation": {
                      "identifier": "OpError.Error",
                      "newPage": false,
                      "searchKey": "net.OpError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *OpError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *OpError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#OpError.Timeout",
                    "documentation": {
                      "identifier": "OpError.Timeout",
                      "newPage": false,
                      "searchKey": "net.OpError.Timeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *OpError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *OpError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#OpError.Temporary",
                    "documentation": {
                      "identifier": "OpError.Temporary",
                      "newPage": false,
                      "searchKey": "net.OpError.Temporary",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *OpError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *OpError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#OpError.isValid",
                    "documentation": {
                      "identifier": "OpError.isValid",
                      "newPage": false,
                      "searchKey": "net.OpError.isValid",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *OpError) isValid() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *OpError) isValid() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#timeout",
              "documentation": {
                "identifier": "timeout",
                "newPage": false,
                "searchKey": "net.timeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type timeout interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timeout interface {\n\tTimeout() bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#temporary",
              "documentation": {
                "identifier": "temporary",
                "newPage": false,
                "searchKey": "net.temporary",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type temporary interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype temporary interface {\n\tTemporary() bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ParseError",
              "documentation": {
                "identifier": "ParseError",
                "newPage": false,
                "searchKey": "net.ParseError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ParseError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ParseError struct {\n\t// Type is the type of string that was expected, such as\n\t// \"IP address\", \"CIDR address\".\n\tType string\n\n\t// Text is the malformed text string.\n\tText string\n}\n```\n\nA ParseError is the error type of literal network address parsers. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ParseError.Error",
                    "documentation": {
                      "identifier": "ParseError.Error",
                      "newPage": false,
                      "searchKey": "net.ParseError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ParseError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ParseError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ParseError.Timeout",
                    "documentation": {
                      "identifier": "ParseError.Timeout",
                      "newPage": false,
                      "searchKey": "net.ParseError.Timeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ParseError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ParseError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ParseError.Temporary",
                    "documentation": {
                      "identifier": "ParseError.Temporary",
                      "newPage": false,
                      "searchKey": "net.ParseError.Temporary",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ParseError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ParseError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#AddrError",
              "documentation": {
                "identifier": "AddrError",
                "newPage": false,
                "searchKey": "net.AddrError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type AddrError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype AddrError struct {\n\tErr  string\n\tAddr string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#AddrError.Error",
                    "documentation": {
                      "identifier": "AddrError.Error",
                      "newPage": false,
                      "searchKey": "net.AddrError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *AddrError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *AddrError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#AddrError.Timeout",
                    "documentation": {
                      "identifier": "AddrError.Timeout",
                      "newPage": false,
                      "searchKey": "net.AddrError.Timeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *AddrError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *AddrError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#AddrError.Temporary",
                    "documentation": {
                      "identifier": "AddrError.Temporary",
                      "newPage": false,
                      "searchKey": "net.AddrError.Temporary",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *AddrError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *AddrError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#UnknownNetworkError",
              "documentation": {
                "identifier": "UnknownNetworkError",
                "newPage": false,
                "searchKey": "net.UnknownNetworkError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type UnknownNetworkError string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype UnknownNetworkError string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#UnknownNetworkError.Error",
                    "documentation": {
                      "identifier": "UnknownNetworkError.Error",
                      "newPage": false,
                      "searchKey": "net.UnknownNetworkError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e UnknownNetworkError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e UnknownNetworkError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnknownNetworkError.Timeout",
                    "documentation": {
                      "identifier": "UnknownNetworkError.Timeout",
                      "newPage": false,
                      "searchKey": "net.UnknownNetworkError.Timeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e UnknownNetworkError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e UnknownNetworkError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnknownNetworkError.Temporary",
                    "documentation": {
                      "identifier": "UnknownNetworkError.Temporary",
                      "newPage": false,
                      "searchKey": "net.UnknownNetworkError.Temporary",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e UnknownNetworkError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e UnknownNetworkError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#InvalidAddrError",
              "documentation": {
                "identifier": "InvalidAddrError",
                "newPage": false,
                "searchKey": "net.InvalidAddrError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type InvalidAddrError string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype InvalidAddrError string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#InvalidAddrError.Error",
                    "documentation": {
                      "identifier": "InvalidAddrError.Error",
                      "newPage": false,
                      "searchKey": "net.InvalidAddrError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e InvalidAddrError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e InvalidAddrError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#InvalidAddrError.Timeout",
                    "documentation": {
                      "identifier": "InvalidAddrError.Timeout",
                      "newPage": false,
                      "searchKey": "net.InvalidAddrError.Timeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e InvalidAddrError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e InvalidAddrError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#InvalidAddrError.Temporary",
                    "documentation": {
                      "identifier": "InvalidAddrError.Temporary",
                      "newPage": false,
                      "searchKey": "net.InvalidAddrError.Temporary",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e InvalidAddrError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e InvalidAddrError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#timeoutError",
              "documentation": {
                "identifier": "timeoutError",
                "newPage": false,
                "searchKey": "net.timeoutError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type timeoutError struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timeoutError struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#timeoutError.Error",
                    "documentation": {
                      "identifier": "timeoutError.Error",
                      "newPage": false,
                      "searchKey": "net.timeoutError.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *timeoutError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *timeoutError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#timeoutError.Timeout",
                    "documentation": {
                      "identifier": "timeoutError.Timeout",
                      "newPage": false,
                      "searchKey": "net.timeoutError.Timeout",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *timeoutError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *timeoutError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#timeoutError.Temporary",
                    "documentation": {
                      "identifier": "timeoutError.Temporary",
                      "newPage": false,
                      "searchKey": "net.timeoutError.Temporary",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *timeoutError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *timeoutError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#DNSConfigError",
              "documentation": {
                "identifier": "DNSConfigError",
                "newPage": false,
                "searchKey": "net.DNSConfigError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type DNSConfigError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype DNSConfigError struct {\n\tErr error\n}\n```\n\nDNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#DNSConfigError.Unwrap",
                    "documentation": {
                      "identifier": "DNSConfigError.Unwrap",
                      "newPage": false,
                      "searchKey": "net.DNSConfigError.Unwrap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *DNSConfigError) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *DNSConfigError) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DNSConfigError.Error",
                    "documentation": {
                      "identifier": "DNSConfigError.Error",
                      "newPage": false,
                      "searchKey": "net.DNSConfigError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *DNSConfigError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *DNSConfigError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DNSConfigError.Timeout",
                    "documentation": {
                      "identifier": "DNSConfigError.Timeout",
                      "newPage": false,
                      "searchKey": "net.DNSConfigError.Timeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *DNSConfigError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *DNSConfigError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DNSConfigError.Temporary",
                    "documentation": {
                      "identifier": "DNSConfigError.Temporary",
                      "newPage": false,
                      "searchKey": "net.DNSConfigError.Temporary",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *DNSConfigError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *DNSConfigError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#DNSError",
              "documentation": {
                "identifier": "DNSError",
                "newPage": false,
                "searchKey": "net.DNSError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type DNSError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype DNSError struct {\n\tErr         string // description of the error\n\tName        string // name looked for\n\tServer      string // server used\n\tIsTimeout   bool   // if true, timed out; not all timeouts set this\n\tIsTemporary bool   // if true, error is temporary; not all errors set this\n\tIsNotFound  bool   // if true, host could not be found\n}\n```\n\nDNSError represents a DNS lookup error. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#DNSError.Error",
                    "documentation": {
                      "identifier": "DNSError.Error",
                      "newPage": false,
                      "searchKey": "net.DNSError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *DNSError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *DNSError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DNSError.Timeout",
                    "documentation": {
                      "identifier": "DNSError.Timeout",
                      "newPage": false,
                      "searchKey": "net.DNSError.Timeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *DNSError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *DNSError) Timeout() bool\n```\n\nTimeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DNSError.Temporary",
                    "documentation": {
                      "identifier": "DNSError.Temporary",
                      "newPage": false,
                      "searchKey": "net.DNSError.Temporary",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *DNSError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *DNSError) Temporary() bool\n```\n\nTemporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#writerOnly",
              "documentation": {
                "identifier": "writerOnly",
                "newPage": false,
                "searchKey": "net.writerOnly",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type writerOnly struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype writerOnly struct {\n\tio.Writer\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#buffersWriter",
              "documentation": {
                "identifier": "buffersWriter",
                "newPage": false,
                "searchKey": "net.buffersWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type buffersWriter interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype buffersWriter interface {\n\twriteBuffers(*Buffers) (int64, error)\n}\n```\n\nbuffersWriter is the interface implemented by Conns that support a \"writev\"-like batch write optimization. writeBuffers should fully consume and write all chunks from the provided Buffers, else it should report a non-nil error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#Buffers",
              "documentation": {
                "identifier": "Buffers",
                "newPage": false,
                "searchKey": "net.Buffers",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Buffers [][]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Buffers [][]byte\n```\n\nBuffers contains zero or more runs of bytes to write. \n\nOn certain machines, for certain types of connections, this is optimized into an OS-specific batch write operation (such as \"writev\"). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#Buffers.WriteTo",
                    "documentation": {
                      "identifier": "Buffers.WriteTo",
                      "newPage": false,
                      "searchKey": "net.Buffers.WriteTo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v *Buffers) WriteTo(w io.Writer) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v *Buffers) WriteTo(w io.Writer) (n int64, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Buffers.Read",
                    "documentation": {
                      "identifier": "Buffers.Read",
                      "newPage": false,
                      "searchKey": "net.Buffers.Read",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v *Buffers) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v *Buffers) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#Buffers.consume",
                    "documentation": {
                      "identifier": "Buffers.consume",
                      "newPage": false,
                      "searchKey": "net.Buffers.consume",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v *Buffers) consume(n int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v *Buffers) consume(n int64)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#nssConf",
              "documentation": {
                "identifier": "nssConf",
                "newPage": false,
                "searchKey": "net.nssConf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nssConf struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nssConf struct {\n\terr     error                  // any error encountered opening or parsing the file\n\tsources map[string][]nssSource // keyed by database (e.g. \"hosts\")\n}\n```\n\nnssConf represents the state of the machine's /etc/nsswitch.conf file. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#parseNSSConfFile",
                    "documentation": {
                      "identifier": "parseNSSConfFile",
                      "newPage": false,
                      "searchKey": "net.parseNSSConfFile",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseNSSConfFile(file string) *nssConf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseNSSConfFile(file string) *nssConf\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#parseNSSConf",
                    "documentation": {
                      "identifier": "parseNSSConf",
                      "newPage": false,
                      "searchKey": "net.parseNSSConf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseNSSConf(r io.Reader) *nssConf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseNSSConf(r io.Reader) *nssConf\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#nssStr",
                    "documentation": {
                      "identifier": "nssStr",
                      "newPage": false,
                      "searchKey": "net.nssStr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func nssStr(s string) *nssConf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc nssStr(s string) *nssConf\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#nssSource",
              "documentation": {
                "identifier": "nssSource",
                "newPage": false,
                "searchKey": "net.nssSource",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nssSource struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nssSource struct {\n\tsource   string // e.g. \"compat\", \"files\", \"mdns4_minimal\"\n\tcriteria []nssCriterion\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#nssSource.standardCriteria",
                    "documentation": {
                      "identifier": "nssSource.standardCriteria",
                      "newPage": false,
                      "searchKey": "net.nssSource.standardCriteria",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s nssSource) standardCriteria() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s nssSource) standardCriteria() bool\n```\n\nstandardCriteria reports all specified criteria have the default status actions. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#nssCriterion",
              "documentation": {
                "identifier": "nssCriterion",
                "newPage": false,
                "searchKey": "net.nssCriterion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nssCriterion struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nssCriterion struct {\n\tnegate bool   // if \"!\" was present\n\tstatus string // e.g. \"success\", \"unavail\" (lowercase)\n\taction string // e.g. \"return\", \"continue\" (lowercase)\n}\n```\n\nnssCriterion is the parsed structure of one of the criteria in brackets after an NSS source name. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#nssCriterion.standardStatusAction",
                    "documentation": {
                      "identifier": "nssCriterion.standardStatusAction",
                      "newPage": false,
                      "searchKey": "net.nssCriterion.standardStatusAction",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c nssCriterion) standardStatusAction(last bool) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c nssCriterion) standardStatusAction(last bool) bool\n```\n\nstandardStatusAction reports whether c is equivalent to not specifying the criterion at all. last is whether this criteria is the last in the list. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#file",
              "documentation": {
                "identifier": "file",
                "newPage": false,
                "searchKey": "net.file",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type file struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype file struct {\n\tfile  *os.File\n\tdata  []byte\n\tatEOF bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#open",
                    "documentation": {
                      "identifier": "open",
                      "newPage": false,
                      "searchKey": "net.open",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func open(name string) (*file, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc open(name string) (*file, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#file.close",
                    "documentation": {
                      "identifier": "file.close",
                      "newPage": false,
                      "searchKey": "net.file.close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *file) close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *file) close()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#file.getLineFromData",
                    "documentation": {
                      "identifier": "file.getLineFromData",
                      "newPage": false,
                      "searchKey": "net.file.getLineFromData",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *file) getLineFromData() (s string, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *file) getLineFromData() (s string, ok bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#file.readLine",
                    "documentation": {
                      "identifier": "file.readLine",
                      "newPage": false,
                      "searchKey": "net.file.readLine",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *file) readLine() (s string, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *file) readLine() (s string, ok bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#pipeDeadline",
              "documentation": {
                "identifier": "pipeDeadline",
                "newPage": false,
                "searchKey": "net.pipeDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pipeDeadline struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pipeDeadline struct {\n\tmu     sync.Mutex // Guards timer and cancel\n\ttimer  *time.Timer\n\tcancel chan struct{} // Must be non-nil\n}\n```\n\npipeDeadline is an abstraction for handling timeouts. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#makePipeDeadline",
                    "documentation": {
                      "identifier": "makePipeDeadline",
                      "newPage": false,
                      "searchKey": "net.makePipeDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makePipeDeadline() pipeDeadline"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makePipeDeadline() pipeDeadline\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipeDeadline.set",
                    "documentation": {
                      "identifier": "pipeDeadline.set",
                      "newPage": false,
                      "searchKey": "net.pipeDeadline.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *pipeDeadline) set(t time.Time)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *pipeDeadline) set(t time.Time)\n```\n\nset sets the point in time when the deadline will time out. A timeout event is signaled by closing the channel returned by waiter. Once a timeout has occurred, the deadline can be refreshed by specifying a t value in the future. \n\nA zero value for t prevents timeout. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipeDeadline.wait",
                    "documentation": {
                      "identifier": "pipeDeadline.wait",
                      "newPage": false,
                      "searchKey": "net.pipeDeadline.wait",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *pipeDeadline) wait() chan struct{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *pipeDeadline) wait() chan struct{}\n```\n\nwait returns a channel that is closed when the deadline is exceeded. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#pipeAddr",
              "documentation": {
                "identifier": "pipeAddr",
                "newPage": false,
                "searchKey": "net.pipeAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pipeAddr struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pipeAddr struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#pipeAddr.Network",
                    "documentation": {
                      "identifier": "pipeAddr.Network",
                      "newPage": false,
                      "searchKey": "net.pipeAddr.Network",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pipeAddr) Network() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pipeAddr) Network() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipeAddr.String",
                    "documentation": {
                      "identifier": "pipeAddr.String",
                      "newPage": false,
                      "searchKey": "net.pipeAddr.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pipeAddr) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pipeAddr) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#pipe",
              "documentation": {
                "identifier": "pipe",
                "newPage": false,
                "searchKey": "net.pipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pipe struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pipe struct {\n\twrMu sync.Mutex // Serialize Write operations\n\n\t// Used by local Read to interact with remote Write.\n\t// Successful receive on rdRx is always followed by send on rdTx.\n\trdRx <-chan []byte\n\trdTx chan<- int\n\n\t// Used by local Write to interact with remote Read.\n\t// Successful send on wrTx is always followed by receive on wrRx.\n\twrTx chan<- []byte\n\twrRx <-chan int\n\n\tonce       sync.Once // Protects closing localDone\n\tlocalDone  chan struct{}\n\tremoteDone <-chan struct{}\n\n\treadDeadline  pipeDeadline\n\twriteDeadline pipeDeadline\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#pipe.LocalAddr",
                    "documentation": {
                      "identifier": "pipe.LocalAddr",
                      "newPage": false,
                      "searchKey": "net.pipe.LocalAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*pipe) LocalAddr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*pipe) LocalAddr() Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipe.RemoteAddr",
                    "documentation": {
                      "identifier": "pipe.RemoteAddr",
                      "newPage": false,
                      "searchKey": "net.pipe.RemoteAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*pipe) RemoteAddr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*pipe) RemoteAddr() Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipe.Read",
                    "documentation": {
                      "identifier": "pipe.Read",
                      "newPage": false,
                      "searchKey": "net.pipe.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pipe) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pipe) Read(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipe.read",
                    "documentation": {
                      "identifier": "pipe.read",
                      "newPage": false,
                      "searchKey": "net.pipe.read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pipe) read(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pipe) read(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipe.Write",
                    "documentation": {
                      "identifier": "pipe.Write",
                      "newPage": false,
                      "searchKey": "net.pipe.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pipe) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pipe) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipe.write",
                    "documentation": {
                      "identifier": "pipe.write",
                      "newPage": false,
                      "searchKey": "net.pipe.write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pipe) write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pipe) write(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipe.SetDeadline",
                    "documentation": {
                      "identifier": "pipe.SetDeadline",
                      "newPage": false,
                      "searchKey": "net.pipe.SetDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pipe) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pipe) SetDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipe.SetReadDeadline",
                    "documentation": {
                      "identifier": "pipe.SetReadDeadline",
                      "newPage": false,
                      "searchKey": "net.pipe.SetReadDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pipe) SetReadDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pipe) SetReadDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipe.SetWriteDeadline",
                    "documentation": {
                      "identifier": "pipe.SetWriteDeadline",
                      "newPage": false,
                      "searchKey": "net.pipe.SetWriteDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pipe) SetWriteDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pipe) SetWriteDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#pipe.Close",
                    "documentation": {
                      "identifier": "pipe.Close",
                      "newPage": false,
                      "searchKey": "net.pipe.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pipe) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pipe) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#rawConn",
              "documentation": {
                "identifier": "rawConn",
                "newPage": false,
                "searchKey": "net.rawConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type rawConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype rawConn struct {\n\tfd *netFD\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newRawConn",
                    "documentation": {
                      "identifier": "newRawConn",
                      "newPage": false,
                      "searchKey": "net.newRawConn",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newRawConn(fd *netFD) (*rawConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newRawConn(fd *netFD) (*rawConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#rawConn.ok",
                    "documentation": {
                      "identifier": "rawConn.ok",
                      "newPage": false,
                      "searchKey": "net.rawConn.ok",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *rawConn) ok() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *rawConn) ok() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#rawConn.Control",
                    "documentation": {
                      "identifier": "rawConn.Control",
                      "newPage": false,
                      "searchKey": "net.rawConn.Control",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *rawConn) Control(f func(uintptr)) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *rawConn) Control(f func(uintptr)) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#rawConn.Read",
                    "documentation": {
                      "identifier": "rawConn.Read",
                      "newPage": false,
                      "searchKey": "net.rawConn.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *rawConn) Read(f func(uintptr) bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *rawConn) Read(f func(uintptr) bool) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#rawConn.Write",
                    "documentation": {
                      "identifier": "rawConn.Write",
                      "newPage": false,
                      "searchKey": "net.rawConn.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *rawConn) Write(f func(uintptr) bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *rawConn) Write(f func(uintptr) bool) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#rawListener",
              "documentation": {
                "identifier": "rawListener",
                "newPage": false,
                "searchKey": "net.rawListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type rawListener struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype rawListener struct {\n\trawConn\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newRawListener",
                    "documentation": {
                      "identifier": "newRawListener",
                      "newPage": false,
                      "searchKey": "net.newRawListener",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newRawListener(fd *netFD) (*rawListener, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newRawListener(fd *netFD) (*rawListener, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#rawListener.Read",
                    "documentation": {
                      "identifier": "rawListener.Read",
                      "newPage": false,
                      "searchKey": "net.rawListener.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *rawListener) Read(func(uintptr) bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *rawListener) Read(func(uintptr) bool) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#rawListener.Write",
                    "documentation": {
                      "identifier": "rawListener.Write",
                      "newPage": false,
                      "searchKey": "net.rawListener.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *rawListener) Write(func(uintptr) bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *rawListener) Write(func(uintptr) bool) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#sockaddr",
              "documentation": {
                "identifier": "sockaddr",
                "newPage": false,
                "searchKey": "net.sockaddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sockaddr interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sockaddr interface {\n\tAddr\n\n\t// family returns the platform-dependent address family\n\t// identifier.\n\tfamily() int\n\n\t// isWildcard reports whether the address is a wildcard\n\t// address.\n\tisWildcard() bool\n\n\t// sockaddr returns the address converted into a syscall\n\t// sockaddr type that implements syscall.Sockaddr\n\t// interface. It returns a nil interface when the address is\n\t// nil.\n\tsockaddr(family int) (syscall.Sockaddr, error)\n\n\t// toLocal maps the zero address to a local system address (127.0.0.1 or ::1)\n\ttoLocal(net string) sockaddr\n}\n```\n\nA sockaddr represents a TCP, UDP, IP or Unix network endpoint address that can be converted into a syscall.Sockaddr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TCPAddr",
              "documentation": {
                "identifier": "TCPAddr",
                "newPage": false,
                "searchKey": "net.TCPAddr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type TCPAddr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype TCPAddr struct {\n\tIP   IP\n\tPort int\n\tZone string // IPv6 scoped addressing zone\n}\n```\n\nTCPAddr represents the address of a TCP end point. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ResolveTCPAddr",
                    "documentation": {
                      "identifier": "ResolveTCPAddr",
                      "newPage": false,
                      "searchKey": "net.ResolveTCPAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ResolveTCPAddr(network, address string) (*TCPAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ResolveTCPAddr(network, address string) (*TCPAddr, error)\n```\n\nResolveTCPAddr returns an address of TCP end point. \n\nThe network must be a TCP network name. \n\nIf the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses. \n\nSee func Dial for a description of the network and address parameters. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPAddr.Network",
                    "documentation": {
                      "identifier": "TCPAddr.Network",
                      "newPage": false,
                      "searchKey": "net.TCPAddr.Network",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *TCPAddr) Network() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *TCPAddr) Network() string\n```\n\nNetwork returns the address's network name, \"tcp\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPAddr.String",
                    "documentation": {
                      "identifier": "TCPAddr.String",
                      "newPage": false,
                      "searchKey": "net.TCPAddr.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *TCPAddr) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *TCPAddr) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPAddr.isWildcard",
                    "documentation": {
                      "identifier": "TCPAddr.isWildcard",
                      "newPage": false,
                      "searchKey": "net.TCPAddr.isWildcard",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *TCPAddr) isWildcard() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *TCPAddr) isWildcard() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPAddr.opAddr",
                    "documentation": {
                      "identifier": "TCPAddr.opAddr",
                      "newPage": false,
                      "searchKey": "net.TCPAddr.opAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *TCPAddr) opAddr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *TCPAddr) opAddr() Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPAddr.family",
                    "documentation": {
                      "identifier": "TCPAddr.family",
                      "newPage": false,
                      "searchKey": "net.TCPAddr.family",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *TCPAddr) family() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *TCPAddr) family() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPAddr.sockaddr",
                    "documentation": {
                      "identifier": "TCPAddr.sockaddr",
                      "newPage": false,
                      "searchKey": "net.TCPAddr.sockaddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *TCPAddr) sockaddr(family int) (syscall.Sockaddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *TCPAddr) sockaddr(family int) (syscall.Sockaddr, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPAddr.toLocal",
                    "documentation": {
                      "identifier": "TCPAddr.toLocal",
                      "newPage": false,
                      "searchKey": "net.TCPAddr.toLocal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *TCPAddr) toLocal(net string) sockaddr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *TCPAddr) toLocal(net string) sockaddr\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#TCPConn",
              "documentation": {
                "identifier": "TCPConn",
                "newPage": false,
                "searchKey": "net.TCPConn",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type TCPConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype TCPConn struct {\n\tconn\n}\n```\n\nTCPConn is an implementation of the Conn interface for TCP network connections. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newTCPConn",
                    "documentation": {
                      "identifier": "newTCPConn",
                      "newPage": false,
                      "searchKey": "net.newTCPConn",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newTCPConn(fd *netFD) *TCPConn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newTCPConn(fd *netFD) *TCPConn\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DialTCP",
                    "documentation": {
                      "identifier": "DialTCP",
                      "newPage": false,
                      "searchKey": "net.DialTCP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)\n```\n\nDialTCP acts like Dial for TCP networks. \n\nThe network must be a TCP network name; see func Dial for details. \n\nIf laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#slowDialTCP",
                    "documentation": {
                      "identifier": "slowDialTCP",
                      "newPage": false,
                      "searchKey": "net.slowDialTCP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func slowDialTCP(ctx context.Context, network string, laddr, raddr *TCPAddr) (*TCPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc slowDialTCP(ctx context.Context, network string, laddr, raddr *TCPAddr) (*TCPConn, error)\n```\n\nIn some environments, the slow IPs may be explicitly unreachable, and fail more quickly than expected. This test hook prevents dialTCP from returning before the deadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPConn.SyscallConn",
                    "documentation": {
                      "identifier": "TCPConn.SyscallConn",
                      "newPage": false,
                      "searchKey": "net.TCPConn.SyscallConn",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *TCPConn) SyscallConn() (syscall.RawConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *TCPConn) SyscallConn() (syscall.RawConn, error)\n```\n\nSyscallConn returns a raw network connection. This implements the syscall.Conn interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPConn.ReadFrom",
                    "documentation": {
                      "identifier": "TCPConn.ReadFrom",
                      "newPage": false,
                      "searchKey": "net.TCPConn.ReadFrom",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *TCPConn) ReadFrom(r io.Reader) (int64, error)\n```\n\nReadFrom implements the io.ReaderFrom ReadFrom method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPConn.CloseRead",
                    "documentation": {
                      "identifier": "TCPConn.CloseRead",
                      "newPage": false,
                      "searchKey": "net.TCPConn.CloseRead",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *TCPConn) CloseRead() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *TCPConn) CloseRead() error\n```\n\nCloseRead shuts down the reading side of the TCP connection. Most callers should just use Close. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPConn.CloseWrite",
                    "documentation": {
                      "identifier": "TCPConn.CloseWrite",
                      "newPage": false,
                      "searchKey": "net.TCPConn.CloseWrite",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *TCPConn) CloseWrite() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *TCPConn) CloseWrite() error\n```\n\nCloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPConn.SetLinger",
                    "documentation": {
                      "identifier": "TCPConn.SetLinger",
                      "newPage": false,
                      "searchKey": "net.TCPConn.SetLinger",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *TCPConn) SetLinger(sec int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *TCPConn) SetLinger(sec int) error\n```\n\nSetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged. \n\nIf sec < 0 (the default), the operating system finishes sending the data in the background. \n\nIf sec == 0, the operating system discards any unsent or unacknowledged data. \n\nIf sec > 0, the data is sent in the background as with sec < 0. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPConn.SetKeepAlive",
                    "documentation": {
                      "identifier": "TCPConn.SetKeepAlive",
                      "newPage": false,
                      "searchKey": "net.TCPConn.SetKeepAlive",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *TCPConn) SetKeepAlive(keepalive bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *TCPConn) SetKeepAlive(keepalive bool) error\n```\n\nSetKeepAlive sets whether the operating system should send keep-alive messages on the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPConn.SetKeepAlivePeriod",
                    "documentation": {
                      "identifier": "TCPConn.SetKeepAlivePeriod",
                      "newPage": false,
                      "searchKey": "net.TCPConn.SetKeepAlivePeriod",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error\n```\n\nSetKeepAlivePeriod sets period between keep-alives. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPConn.SetNoDelay",
                    "documentation": {
                      "identifier": "TCPConn.SetNoDelay",
                      "newPage": false,
                      "searchKey": "net.TCPConn.SetNoDelay",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *TCPConn) SetNoDelay(noDelay bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *TCPConn) SetNoDelay(noDelay bool) error\n```\n\nSetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm).  The default is true (no delay), meaning that data is sent as soon as possible after a Write. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPConn.readFrom",
                    "documentation": {
                      "identifier": "TCPConn.readFrom",
                      "newPage": false,
                      "searchKey": "net.TCPConn.readFrom",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *TCPConn) readFrom(r io.Reader) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *TCPConn) readFrom(r io.Reader) (int64, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#TCPListener",
              "documentation": {
                "identifier": "TCPListener",
                "newPage": false,
                "searchKey": "net.TCPListener",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type TCPListener struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype TCPListener struct {\n\tfd *netFD\n\tlc ListenConfig\n}\n```\n\nTCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ListenTCP",
                    "documentation": {
                      "identifier": "ListenTCP",
                      "newPage": false,
                      "searchKey": "net.ListenTCP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)\n```\n\nListenTCP acts like Listen for TCP networks. \n\nThe network must be a TCP network name; see func Dial for details. \n\nIf the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.SyscallConn",
                    "documentation": {
                      "identifier": "TCPListener.SyscallConn",
                      "newPage": false,
                      "searchKey": "net.TCPListener.SyscallConn",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *TCPListener) SyscallConn() (syscall.RawConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *TCPListener) SyscallConn() (syscall.RawConn, error)\n```\n\nSyscallConn returns a raw network connection. This implements the syscall.Conn interface. \n\nThe returned RawConn only supports calling Control. Read and Write return an error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.AcceptTCP",
                    "documentation": {
                      "identifier": "TCPListener.AcceptTCP",
                      "newPage": false,
                      "searchKey": "net.TCPListener.AcceptTCP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *TCPListener) AcceptTCP() (*TCPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *TCPListener) AcceptTCP() (*TCPConn, error)\n```\n\nAcceptTCP accepts the next incoming call and returns the new connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.Accept",
                    "documentation": {
                      "identifier": "TCPListener.Accept",
                      "newPage": false,
                      "searchKey": "net.TCPListener.Accept",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *TCPListener) Accept() (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *TCPListener) Accept() (Conn, error)\n```\n\nAccept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.Close",
                    "documentation": {
                      "identifier": "TCPListener.Close",
                      "newPage": false,
                      "searchKey": "net.TCPListener.Close",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *TCPListener) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *TCPListener) Close() error\n```\n\nClose stops listening on the TCP address. Already Accepted connections are not closed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.Addr",
                    "documentation": {
                      "identifier": "TCPListener.Addr",
                      "newPage": false,
                      "searchKey": "net.TCPListener.Addr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *TCPListener) Addr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *TCPListener) Addr() Addr\n```\n\nAddr returns the listener's network address, a *TCPAddr. The Addr returned is shared by all invocations of Addr, so do not modify it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.SetDeadline",
                    "documentation": {
                      "identifier": "TCPListener.SetDeadline",
                      "newPage": false,
                      "searchKey": "net.TCPListener.SetDeadline",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *TCPListener) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *TCPListener) SetDeadline(t time.Time) error\n```\n\nSetDeadline sets the deadline associated with the listener. A zero time value disables the deadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.File",
                    "documentation": {
                      "identifier": "TCPListener.File",
                      "newPage": false,
                      "searchKey": "net.TCPListener.File",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *TCPListener) File() (f *os.File, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *TCPListener) File() (f *os.File, err error)\n```\n\nFile returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l. \n\nThe returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.ok",
                    "documentation": {
                      "identifier": "TCPListener.ok",
                      "newPage": false,
                      "searchKey": "net.TCPListener.ok",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ln *TCPListener) ok() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ln *TCPListener) ok() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.accept",
                    "documentation": {
                      "identifier": "TCPListener.accept",
                      "newPage": false,
                      "searchKey": "net.TCPListener.accept",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ln *TCPListener) accept() (*TCPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ln *TCPListener) accept() (*TCPConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.close",
                    "documentation": {
                      "identifier": "TCPListener.close",
                      "newPage": false,
                      "searchKey": "net.TCPListener.close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ln *TCPListener) close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ln *TCPListener) close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.file",
                    "documentation": {
                      "identifier": "TCPListener.file",
                      "newPage": false,
                      "searchKey": "net.TCPListener.file",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ln *TCPListener) file() (*os.File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ln *TCPListener) file() (*os.File, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#TCPListener.port",
                    "documentation": {
                      "identifier": "TCPListener.port",
                      "newPage": false,
                      "searchKey": "net.TCPListener.port",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ln *TCPListener) port() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ln *TCPListener) port() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#UDPAddr",
              "documentation": {
                "identifier": "UDPAddr",
                "newPage": false,
                "searchKey": "net.UDPAddr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type UDPAddr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype UDPAddr struct {\n\tIP   IP\n\tPort int\n\tZone string // IPv6 scoped addressing zone\n}\n```\n\nUDPAddr represents the address of a UDP end point. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ResolveUDPAddr",
                    "documentation": {
                      "identifier": "ResolveUDPAddr",
                      "newPage": false,
                      "searchKey": "net.ResolveUDPAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ResolveUDPAddr(network, address string) (*UDPAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ResolveUDPAddr(network, address string) (*UDPAddr, error)\n```\n\nResolveUDPAddr returns an address of UDP end point. \n\nThe network must be a UDP network name. \n\nIf the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses. \n\nSee func Dial for a description of the network and address parameters. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPAddr.Network",
                    "documentation": {
                      "identifier": "UDPAddr.Network",
                      "newPage": false,
                      "searchKey": "net.UDPAddr.Network",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UDPAddr) Network() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UDPAddr) Network() string\n```\n\nNetwork returns the address's network name, \"udp\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPAddr.String",
                    "documentation": {
                      "identifier": "UDPAddr.String",
                      "newPage": false,
                      "searchKey": "net.UDPAddr.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UDPAddr) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UDPAddr) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPAddr.isWildcard",
                    "documentation": {
                      "identifier": "UDPAddr.isWildcard",
                      "newPage": false,
                      "searchKey": "net.UDPAddr.isWildcard",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UDPAddr) isWildcard() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UDPAddr) isWildcard() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPAddr.opAddr",
                    "documentation": {
                      "identifier": "UDPAddr.opAddr",
                      "newPage": false,
                      "searchKey": "net.UDPAddr.opAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UDPAddr) opAddr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UDPAddr) opAddr() Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPAddr.family",
                    "documentation": {
                      "identifier": "UDPAddr.family",
                      "newPage": false,
                      "searchKey": "net.UDPAddr.family",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UDPAddr) family() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UDPAddr) family() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPAddr.sockaddr",
                    "documentation": {
                      "identifier": "UDPAddr.sockaddr",
                      "newPage": false,
                      "searchKey": "net.UDPAddr.sockaddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UDPAddr) sockaddr(family int) (syscall.Sockaddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UDPAddr) sockaddr(family int) (syscall.Sockaddr, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPAddr.toLocal",
                    "documentation": {
                      "identifier": "UDPAddr.toLocal",
                      "newPage": false,
                      "searchKey": "net.UDPAddr.toLocal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UDPAddr) toLocal(net string) sockaddr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UDPAddr) toLocal(net string) sockaddr\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#UDPConn",
              "documentation": {
                "identifier": "UDPConn",
                "newPage": false,
                "searchKey": "net.UDPConn",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type UDPConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype UDPConn struct {\n\tconn\n}\n```\n\nUDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newUDPConn",
                    "documentation": {
                      "identifier": "newUDPConn",
                      "newPage": false,
                      "searchKey": "net.newUDPConn",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newUDPConn(fd *netFD) *UDPConn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newUDPConn(fd *netFD) *UDPConn\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DialUDP",
                    "documentation": {
                      "identifier": "DialUDP",
                      "newPage": false,
                      "searchKey": "net.DialUDP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)\n```\n\nDialUDP acts like Dial for UDP networks. \n\nThe network must be a UDP network name; see func Dial for details. \n\nIf laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ListenUDP",
                    "documentation": {
                      "identifier": "ListenUDP",
                      "newPage": false,
                      "searchKey": "net.ListenUDP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)\n```\n\nListenUDP acts like ListenPacket for UDP networks. \n\nThe network must be a UDP network name; see func Dial for details. \n\nIf the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ListenMulticastUDP",
                    "documentation": {
                      "identifier": "ListenMulticastUDP",
                      "newPage": false,
                      "searchKey": "net.ListenMulticastUDP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)\n```\n\nListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface. \n\nThe network must be a UDP network name; see func Dial for details. \n\nListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen. \n\nListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses. \n\nNote that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option to 0 under IPPROTO_IP, to disable loopback of multicast packets. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.SyscallConn",
                    "documentation": {
                      "identifier": "UDPConn.SyscallConn",
                      "newPage": false,
                      "searchKey": "net.UDPConn.SyscallConn",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) SyscallConn() (syscall.RawConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) SyscallConn() (syscall.RawConn, error)\n```\n\nSyscallConn returns a raw network connection. This implements the syscall.Conn interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.ReadFromUDP",
                    "documentation": {
                      "identifier": "UDPConn.ReadFromUDP",
                      "newPage": false,
                      "searchKey": "net.UDPConn.ReadFromUDP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)\n```\n\nReadFromUDP acts like ReadFrom but returns a UDPAddr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.readFromUDP",
                    "documentation": {
                      "identifier": "UDPConn.readFromUDP",
                      "newPage": false,
                      "searchKey": "net.UDPConn.readFromUDP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) readFromUDP(b []byte, addr *UDPAddr) (int, *UDPAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) readFromUDP(b []byte, addr *UDPAddr) (int, *UDPAddr, error)\n```\n\nreadFromUDP implements ReadFromUDP. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.ReadFrom",
                    "documentation": {
                      "identifier": "UDPConn.ReadFrom",
                      "newPage": false,
                      "searchKey": "net.UDPConn.ReadFrom",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)\n```\n\nReadFrom implements the PacketConn ReadFrom method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.ReadMsgUDP",
                    "documentation": {
                      "identifier": "UDPConn.ReadMsgUDP",
                      "newPage": false,
                      "searchKey": "net.UDPConn.ReadMsgUDP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)\n```\n\nReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message. \n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.WriteToUDP",
                    "documentation": {
                      "identifier": "UDPConn.WriteToUDP",
                      "newPage": false,
                      "searchKey": "net.UDPConn.WriteToUDP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)\n```\n\nWriteToUDP acts like WriteTo but takes a UDPAddr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.WriteTo",
                    "documentation": {
                      "identifier": "UDPConn.WriteTo",
                      "newPage": false,
                      "searchKey": "net.UDPConn.WriteTo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)\n```\n\nWriteTo implements the PacketConn WriteTo method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.WriteMsgUDP",
                    "documentation": {
                      "identifier": "UDPConn.WriteMsgUDP",
                      "newPage": false,
                      "searchKey": "net.UDPConn.WriteMsgUDP",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)\n```\n\nWriteMsgUDP writes a message to addr via c if c isn't connected, or to c's remote address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written. \n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.readFrom",
                    "documentation": {
                      "identifier": "UDPConn.readFrom",
                      "newPage": false,
                      "searchKey": "net.UDPConn.readFrom",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) readFrom(b []byte, addr *UDPAddr) (int, *UDPAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) readFrom(b []byte, addr *UDPAddr) (int, *UDPAddr, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.readMsg",
                    "documentation": {
                      "identifier": "UDPConn.readMsg",
                      "newPage": false,
                      "searchKey": "net.UDPConn.readMsg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) readMsg(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) readMsg(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.writeTo",
                    "documentation": {
                      "identifier": "UDPConn.writeTo",
                      "newPage": false,
                      "searchKey": "net.UDPConn.writeTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) writeTo(b []byte, addr *UDPAddr) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) writeTo(b []byte, addr *UDPAddr) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.writeMsg",
                    "documentation": {
                      "identifier": "UDPConn.writeMsg",
                      "newPage": false,
                      "searchKey": "net.UDPConn.writeMsg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) writeMsg(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) writeMsg(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UDPConn.port",
                    "documentation": {
                      "identifier": "UDPConn.port",
                      "newPage": false,
                      "searchKey": "net.UDPConn.port",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UDPConn) port() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UDPConn) port() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#UnixAddr",
              "documentation": {
                "identifier": "UnixAddr",
                "newPage": false,
                "searchKey": "net.UnixAddr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type UnixAddr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype UnixAddr struct {\n\tName string\n\tNet  string\n}\n```\n\nUnixAddr represents the address of a Unix domain socket end point. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ResolveUnixAddr",
                    "documentation": {
                      "identifier": "ResolveUnixAddr",
                      "newPage": false,
                      "searchKey": "net.ResolveUnixAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ResolveUnixAddr(network, address string) (*UnixAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ResolveUnixAddr(network, address string) (*UnixAddr, error)\n```\n\nResolveUnixAddr returns an address of Unix domain socket end point. \n\nThe network must be a Unix network name. \n\nSee func Dial for a description of the network and address parameters. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixAddr.Network",
                    "documentation": {
                      "identifier": "UnixAddr.Network",
                      "newPage": false,
                      "searchKey": "net.UnixAddr.Network",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UnixAddr) Network() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UnixAddr) Network() string\n```\n\nNetwork returns the address's network name, \"unix\", \"unixgram\" or \"unixpacket\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixAddr.String",
                    "documentation": {
                      "identifier": "UnixAddr.String",
                      "newPage": false,
                      "searchKey": "net.UnixAddr.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UnixAddr) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UnixAddr) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixAddr.isWildcard",
                    "documentation": {
                      "identifier": "UnixAddr.isWildcard",
                      "newPage": false,
                      "searchKey": "net.UnixAddr.isWildcard",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UnixAddr) isWildcard() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UnixAddr) isWildcard() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixAddr.opAddr",
                    "documentation": {
                      "identifier": "UnixAddr.opAddr",
                      "newPage": false,
                      "searchKey": "net.UnixAddr.opAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UnixAddr) opAddr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UnixAddr) opAddr() Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixAddr.family",
                    "documentation": {
                      "identifier": "UnixAddr.family",
                      "newPage": false,
                      "searchKey": "net.UnixAddr.family",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UnixAddr) family() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UnixAddr) family() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixAddr.sockaddr",
                    "documentation": {
                      "identifier": "UnixAddr.sockaddr",
                      "newPage": false,
                      "searchKey": "net.UnixAddr.sockaddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UnixAddr) sockaddr(family int) (syscall.Sockaddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UnixAddr) sockaddr(family int) (syscall.Sockaddr, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixAddr.toLocal",
                    "documentation": {
                      "identifier": "UnixAddr.toLocal",
                      "newPage": false,
                      "searchKey": "net.UnixAddr.toLocal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *UnixAddr) toLocal(net string) sockaddr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *UnixAddr) toLocal(net string) sockaddr\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#UnixConn",
              "documentation": {
                "identifier": "UnixConn",
                "newPage": false,
                "searchKey": "net.UnixConn",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type UnixConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype UnixConn struct {\n\tconn\n}\n```\n\nUnixConn is an implementation of the Conn interface for connections to Unix domain sockets. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newUnixConn",
                    "documentation": {
                      "identifier": "newUnixConn",
                      "newPage": false,
                      "searchKey": "net.newUnixConn",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newUnixConn(fd *netFD) *UnixConn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newUnixConn(fd *netFD) *UnixConn\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#DialUnix",
                    "documentation": {
                      "identifier": "DialUnix",
                      "newPage": false,
                      "searchKey": "net.DialUnix",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)\n```\n\nDialUnix acts like Dial for Unix networks. \n\nThe network must be a Unix network name; see func Dial for details. \n\nIf laddr is non-nil, it is used as the local address for the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#ListenUnixgram",
                    "documentation": {
                      "identifier": "ListenUnixgram",
                      "newPage": false,
                      "searchKey": "net.ListenUnixgram",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)\n```\n\nListenUnixgram acts like ListenPacket for Unix networks. \n\nThe network must be \"unixgram\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.SyscallConn",
                    "documentation": {
                      "identifier": "UnixConn.SyscallConn",
                      "newPage": false,
                      "searchKey": "net.UnixConn.SyscallConn",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) SyscallConn() (syscall.RawConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) SyscallConn() (syscall.RawConn, error)\n```\n\nSyscallConn returns a raw network connection. This implements the syscall.Conn interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.CloseRead",
                    "documentation": {
                      "identifier": "UnixConn.CloseRead",
                      "newPage": false,
                      "searchKey": "net.UnixConn.CloseRead",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) CloseRead() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) CloseRead() error\n```\n\nCloseRead shuts down the reading side of the Unix domain connection. Most callers should just use Close. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.CloseWrite",
                    "documentation": {
                      "identifier": "UnixConn.CloseWrite",
                      "newPage": false,
                      "searchKey": "net.UnixConn.CloseWrite",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) CloseWrite() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) CloseWrite() error\n```\n\nCloseWrite shuts down the writing side of the Unix domain connection. Most callers should just use Close. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.ReadFromUnix",
                    "documentation": {
                      "identifier": "UnixConn.ReadFromUnix",
                      "newPage": false,
                      "searchKey": "net.UnixConn.ReadFromUnix",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)\n```\n\nReadFromUnix acts like ReadFrom but returns a UnixAddr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.ReadFrom",
                    "documentation": {
                      "identifier": "UnixConn.ReadFrom",
                      "newPage": false,
                      "searchKey": "net.UnixConn.ReadFrom",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)\n```\n\nReadFrom implements the PacketConn ReadFrom method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.ReadMsgUnix",
                    "documentation": {
                      "identifier": "UnixConn.ReadMsgUnix",
                      "newPage": false,
                      "searchKey": "net.UnixConn.ReadMsgUnix",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)\n```\n\nReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message. \n\nNote that if len(b) == 0 and len(oob) > 0, this function will still read (and discard) 1 byte from the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.WriteToUnix",
                    "documentation": {
                      "identifier": "UnixConn.WriteToUnix",
                      "newPage": false,
                      "searchKey": "net.UnixConn.WriteToUnix",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)\n```\n\nWriteToUnix acts like WriteTo but takes a UnixAddr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.WriteTo",
                    "documentation": {
                      "identifier": "UnixConn.WriteTo",
                      "newPage": false,
                      "searchKey": "net.UnixConn.WriteTo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)\n```\n\nWriteTo implements the PacketConn WriteTo method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.WriteMsgUnix",
                    "documentation": {
                      "identifier": "UnixConn.WriteMsgUnix",
                      "newPage": false,
                      "searchKey": "net.UnixConn.WriteMsgUnix",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)\n```\n\nWriteMsgUnix writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. \n\nNote that if len(b) == 0 and len(oob) > 0, this function will still write 1 byte to the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.readFrom",
                    "documentation": {
                      "identifier": "UnixConn.readFrom",
                      "newPage": false,
                      "searchKey": "net.UnixConn.readFrom",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) readFrom(b []byte) (int, *UnixAddr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) readFrom(b []byte) (int, *UnixAddr, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.readMsg",
                    "documentation": {
                      "identifier": "UnixConn.readMsg",
                      "newPage": false,
                      "searchKey": "net.UnixConn.readMsg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) readMsg(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) readMsg(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.writeTo",
                    "documentation": {
                      "identifier": "UnixConn.writeTo",
                      "newPage": false,
                      "searchKey": "net.UnixConn.writeTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) writeTo(b []byte, addr *UnixAddr) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) writeTo(b []byte, addr *UnixAddr) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixConn.writeMsg",
                    "documentation": {
                      "identifier": "UnixConn.writeMsg",
                      "newPage": false,
                      "searchKey": "net.UnixConn.writeMsg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *UnixConn) writeMsg(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *UnixConn) writeMsg(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#UnixListener",
              "documentation": {
                "identifier": "UnixListener",
                "newPage": false,
                "searchKey": "net.UnixListener",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type UnixListener struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype UnixListener struct {\n\tfd         *netFD\n\tpath       string\n\tunlink     bool\n\tunlinkOnce sync.Once\n}\n```\n\nUnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#ListenUnix",
                    "documentation": {
                      "identifier": "ListenUnix",
                      "newPage": false,
                      "searchKey": "net.ListenUnix",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)\n```\n\nListenUnix acts like Listen for Unix networks. \n\nThe network must be \"unix\" or \"unixpacket\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.ok",
                    "documentation": {
                      "identifier": "UnixListener.ok",
                      "newPage": false,
                      "searchKey": "net.UnixListener.ok",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ln *UnixListener) ok() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ln *UnixListener) ok() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.SyscallConn",
                    "documentation": {
                      "identifier": "UnixListener.SyscallConn",
                      "newPage": false,
                      "searchKey": "net.UnixListener.SyscallConn",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *UnixListener) SyscallConn() (syscall.RawConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *UnixListener) SyscallConn() (syscall.RawConn, error)\n```\n\nSyscallConn returns a raw network connection. This implements the syscall.Conn interface. \n\nThe returned RawConn only supports calling Control. Read and Write return an error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.AcceptUnix",
                    "documentation": {
                      "identifier": "UnixListener.AcceptUnix",
                      "newPage": false,
                      "searchKey": "net.UnixListener.AcceptUnix",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *UnixListener) AcceptUnix() (*UnixConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *UnixListener) AcceptUnix() (*UnixConn, error)\n```\n\nAcceptUnix accepts the next incoming call and returns the new connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.Accept",
                    "documentation": {
                      "identifier": "UnixListener.Accept",
                      "newPage": false,
                      "searchKey": "net.UnixListener.Accept",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *UnixListener) Accept() (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *UnixListener) Accept() (Conn, error)\n```\n\nAccept implements the Accept method in the Listener interface. Returned connections will be of type *UnixConn. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.Close",
                    "documentation": {
                      "identifier": "UnixListener.Close",
                      "newPage": false,
                      "searchKey": "net.UnixListener.Close",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *UnixListener) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *UnixListener) Close() error\n```\n\nClose stops listening on the Unix address. Already accepted connections are not closed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.Addr",
                    "documentation": {
                      "identifier": "UnixListener.Addr",
                      "newPage": false,
                      "searchKey": "net.UnixListener.Addr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *UnixListener) Addr() Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *UnixListener) Addr() Addr\n```\n\nAddr returns the listener's network address. The Addr returned is shared by all invocations of Addr, so do not modify it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.SetDeadline",
                    "documentation": {
                      "identifier": "UnixListener.SetDeadline",
                      "newPage": false,
                      "searchKey": "net.UnixListener.SetDeadline",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *UnixListener) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *UnixListener) SetDeadline(t time.Time) error\n```\n\nSetDeadline sets the deadline associated with the listener. A zero time value disables the deadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.File",
                    "documentation": {
                      "identifier": "UnixListener.File",
                      "newPage": false,
                      "searchKey": "net.UnixListener.File",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *UnixListener) File() (f *os.File, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *UnixListener) File() (f *os.File, err error)\n```\n\nFile returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l. \n\nThe returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.accept",
                    "documentation": {
                      "identifier": "UnixListener.accept",
                      "newPage": false,
                      "searchKey": "net.UnixListener.accept",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ln *UnixListener) accept() (*UnixConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ln *UnixListener) accept() (*UnixConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.close",
                    "documentation": {
                      "identifier": "UnixListener.close",
                      "newPage": false,
                      "searchKey": "net.UnixListener.close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ln *UnixListener) close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ln *UnixListener) close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.file",
                    "documentation": {
                      "identifier": "UnixListener.file",
                      "newPage": false,
                      "searchKey": "net.UnixListener.file",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ln *UnixListener) file() (*os.File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ln *UnixListener) file() (*os.File, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#UnixListener.SetUnlinkOnClose",
                    "documentation": {
                      "identifier": "UnixListener.SetUnlinkOnClose",
                      "newPage": false,
                      "searchKey": "net.UnixListener.SetUnlinkOnClose",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *UnixListener) SetUnlinkOnClose(unlink bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *UnixListener) SetUnlinkOnClose(unlink bool)\n```\n\nSetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed. \n\nThe default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#nssHostTest",
              "documentation": {
                "identifier": "nssHostTest",
                "newPage": false,
                "searchKey": "net.nssHostTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nssHostTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nssHostTest struct {\n\thost      string\n\tlocalhost string\n\twant      hostLookupOrder\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#contextWithNonZeroDeadline",
              "documentation": {
                "identifier": "contextWithNonZeroDeadline",
                "newPage": false,
                "searchKey": "net.contextWithNonZeroDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type contextWithNonZeroDeadline struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype contextWithNonZeroDeadline struct {\n\tcontext.Context\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#contextWithNonZeroDeadline.Deadline",
                    "documentation": {
                      "identifier": "contextWithNonZeroDeadline.Deadline",
                      "newPage": false,
                      "searchKey": "net.contextWithNonZeroDeadline.Deadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (contextWithNonZeroDeadline) Deadline() (time.Time, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (contextWithNonZeroDeadline) Deadline() (time.Time, bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#resolvConfTest",
              "documentation": {
                "identifier": "resolvConfTest",
                "newPage": false,
                "searchKey": "net.resolvConfTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type resolvConfTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype resolvConfTest struct {\n\tdir  string\n\tpath string\n\t*resolverConfig\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newResolvConfTest",
                    "documentation": {
                      "identifier": "newResolvConfTest",
                      "newPage": false,
                      "searchKey": "net.newResolvConfTest",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newResolvConfTest() (*resolvConfTest, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newResolvConfTest() (*resolvConfTest, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#resolvConfTest.writeAndUpdate",
                    "documentation": {
                      "identifier": "resolvConfTest.writeAndUpdate",
                      "newPage": false,
                      "searchKey": "net.resolvConfTest.writeAndUpdate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *resolvConfTest) writeAndUpdate(lines []string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *resolvConfTest) writeAndUpdate(lines []string) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#resolvConfTest.forceUpdate",
                    "documentation": {
                      "identifier": "resolvConfTest.forceUpdate",
                      "newPage": false,
                      "searchKey": "net.resolvConfTest.forceUpdate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *resolvConfTest) forceUpdate(name string, lastChecked time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *resolvConfTest) forceUpdate(name string, lastChecked time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#resolvConfTest.servers",
                    "documentation": {
                      "identifier": "resolvConfTest.servers",
                      "newPage": false,
                      "searchKey": "net.resolvConfTest.servers",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *resolvConfTest) servers() []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *resolvConfTest) servers() []string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#resolvConfTest.teardown",
                    "documentation": {
                      "identifier": "resolvConfTest.teardown",
                      "newPage": false,
                      "searchKey": "net.resolvConfTest.teardown",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *resolvConfTest) teardown() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *resolvConfTest) teardown() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#fakeDNSServer",
              "documentation": {
                "identifier": "fakeDNSServer",
                "newPage": false,
                "searchKey": "net.fakeDNSServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type fakeDNSServer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fakeDNSServer struct {\n\trh        func(n, s string, q dnsmessage.Message, t time.Time) (dnsmessage.Message, error)\n\talwaysTCP bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#fakeDNSServer.DialContext",
                    "documentation": {
                      "identifier": "fakeDNSServer.DialContext",
                      "newPage": false,
                      "searchKey": "net.fakeDNSServer.DialContext",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (server *fakeDNSServer) DialContext(_ context.Context, n, s string) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (server *fakeDNSServer) DialContext(_ context.Context, n, s string) (Conn, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#fakeDNSConn",
              "documentation": {
                "identifier": "fakeDNSConn",
                "newPage": false,
                "searchKey": "net.fakeDNSConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type fakeDNSConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fakeDNSConn struct {\n\tConn\n\ttcp    bool\n\tserver *fakeDNSServer\n\tn      string\n\ts      string\n\tq      dnsmessage.Message\n\tt      time.Time\n\tbuf    []byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#fakeDNSConn.Close",
                    "documentation": {
                      "identifier": "fakeDNSConn.Close",
                      "newPage": false,
                      "searchKey": "net.fakeDNSConn.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fakeDNSConn) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fakeDNSConn) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#fakeDNSConn.Read",
                    "documentation": {
                      "identifier": "fakeDNSConn.Read",
                      "newPage": false,
                      "searchKey": "net.fakeDNSConn.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fakeDNSConn) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fakeDNSConn) Read(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#fakeDNSConn.Write",
                    "documentation": {
                      "identifier": "fakeDNSConn.Write",
                      "newPage": false,
                      "searchKey": "net.fakeDNSConn.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fakeDNSConn) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fakeDNSConn) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#fakeDNSConn.SetDeadline",
                    "documentation": {
                      "identifier": "fakeDNSConn.SetDeadline",
                      "newPage": false,
                      "searchKey": "net.fakeDNSConn.SetDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fakeDNSConn) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fakeDNSConn) SetDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#fakeDNSPacketConn",
              "documentation": {
                "identifier": "fakeDNSPacketConn",
                "newPage": false,
                "searchKey": "net.fakeDNSPacketConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type fakeDNSPacketConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fakeDNSPacketConn struct {\n\tPacketConn\n\tfakeDNSConn\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#fakeDNSPacketConn.SetDeadline",
                    "documentation": {
                      "identifier": "fakeDNSPacketConn.SetDeadline",
                      "newPage": false,
                      "searchKey": "net.fakeDNSPacketConn.SetDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fakeDNSPacketConn) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fakeDNSPacketConn) SetDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#fakeDNSPacketConn.Close",
                    "documentation": {
                      "identifier": "fakeDNSPacketConn.Close",
                      "newPage": false,
                      "searchKey": "net.fakeDNSPacketConn.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fakeDNSPacketConn) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fakeDNSPacketConn) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsNameTest",
              "documentation": {
                "identifier": "dnsNameTest",
                "newPage": false,
                "searchKey": "net.dnsNameTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dnsNameTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dnsNameTest struct {\n\tname   string\n\tresult bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#staticHostEntry",
              "documentation": {
                "identifier": "staticHostEntry",
                "newPage": false,
                "searchKey": "net.staticHostEntry",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type staticHostEntry struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype staticHostEntry struct {\n\tin  string\n\tout []string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ifStats",
              "documentation": {
                "identifier": "ifStats",
                "newPage": false,
                "searchKey": "net.ifStats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ifStats struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ifStats struct {\n\tloop  int // # of active loopback interfaces\n\tother int // # of active other interfaces\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#interfaceStats",
                    "documentation": {
                      "identifier": "interfaceStats",
                      "newPage": false,
                      "searchKey": "net.interfaceStats",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func interfaceStats(ift []Interface) *ifStats"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc interfaceStats(ift []Interface) *ifStats\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#routeStats",
              "documentation": {
                "identifier": "routeStats",
                "newPage": false,
                "searchKey": "net.routeStats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type routeStats struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype routeStats struct {\n\tipv4, ipv6 int // # of active connected unicast, anycast or multicast routes\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#validateInterfaceUnicastAddrs",
                    "documentation": {
                      "identifier": "validateInterfaceUnicastAddrs",
                      "newPage": false,
                      "searchKey": "net.validateInterfaceUnicastAddrs",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func validateInterfaceUnicastAddrs(ifat []Addr) (*routeStats, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc validateInterfaceUnicastAddrs(ifat []Addr) (*routeStats, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#validateInterfaceMulticastAddrs",
                    "documentation": {
                      "identifier": "validateInterfaceMulticastAddrs",
                      "newPage": false,
                      "searchKey": "net.validateInterfaceMulticastAddrs",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func validateInterfaceMulticastAddrs(ifat []Addr) (*routeStats, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc validateInterfaceMulticastAddrs(ifat []Addr) (*routeStats, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#testInterface",
              "documentation": {
                "identifier": "testInterface",
                "newPage": false,
                "searchKey": "net.testInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type testInterface struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype testInterface struct {\n\tname         string\n\tlocal        string\n\tremote       string\n\tsetupCmds    []*exec.Cmd\n\tteardownCmds []*exec.Cmd\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#testInterface.setBroadcast",
                    "documentation": {
                      "identifier": "testInterface.setBroadcast",
                      "newPage": false,
                      "searchKey": "net.testInterface.setBroadcast",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ti *testInterface) setBroadcast(vid int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ti *testInterface) setBroadcast(vid int) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#testInterface.setPointToPoint",
                    "documentation": {
                      "identifier": "testInterface.setPointToPoint",
                      "newPage": false,
                      "searchKey": "net.testInterface.setPointToPoint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ti *testInterface) setPointToPoint(suffix int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ti *testInterface) setPointToPoint(suffix int) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#testInterface.setLinkLocal",
                    "documentation": {
                      "identifier": "testInterface.setLinkLocal",
                      "newPage": false,
                      "searchKey": "net.testInterface.setLinkLocal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ti *testInterface) setLinkLocal(suffix int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ti *testInterface) setLinkLocal(suffix int) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#testInterface.setup",
                    "documentation": {
                      "identifier": "testInterface.setup",
                      "newPage": false,
                      "searchKey": "net.testInterface.setup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ti *testInterface) setup() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ti *testInterface) setup() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#testInterface.teardown",
                    "documentation": {
                      "identifier": "testInterface.teardown",
                      "newPage": false,
                      "searchKey": "net.testInterface.teardown",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ti *testInterface) teardown() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ti *testInterface) teardown() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#resolveIPAddrTest",
              "documentation": {
                "identifier": "resolveIPAddrTest",
                "newPage": false,
                "searchKey": "net.resolveIPAddrTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type resolveIPAddrTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype resolveIPAddrTest struct {\n\tnetwork       string\n\tlitAddrOrName string\n\taddr          *IPAddr\n\terr           error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupCustomResolver",
              "documentation": {
                "identifier": "lookupCustomResolver",
                "newPage": false,
                "searchKey": "net.lookupCustomResolver",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type lookupCustomResolver struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype lookupCustomResolver struct {\n\t*Resolver\n\tmu     sync.RWMutex\n\tdialed bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#lookupCustomResolver.dial",
                    "documentation": {
                      "identifier": "lookupCustomResolver.dial",
                      "newPage": false,
                      "searchKey": "net.lookupCustomResolver.dial",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (lcr *lookupCustomResolver) dial() func(ctx context.Context, network, address string) (Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (lcr *lookupCustomResolver) dial() func(ctx context.Context, network, address string) (Conn, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipv6LinkLocalUnicastTest",
              "documentation": {
                "identifier": "ipv6LinkLocalUnicastTest",
                "newPage": false,
                "searchKey": "net.ipv6LinkLocalUnicastTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ipv6LinkLocalUnicastTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ipv6LinkLocalUnicastTest struct {\n\tnetwork, address string\n\tnameLookup       bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#localServer",
              "documentation": {
                "identifier": "localServer",
                "newPage": false,
                "searchKey": "net.localServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type localServer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype localServer struct {\n\tlnmu sync.RWMutex\n\tListener\n\tdone chan bool // signal that indicates server stopped\n\tcl   []Conn    // accepted connection list\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newLocalServer",
                    "documentation": {
                      "identifier": "newLocalServer",
                      "newPage": false,
                      "searchKey": "net.newLocalServer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newLocalServer(network string) (*localServer, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newLocalServer(network string) (*localServer, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#localServer.buildup",
                    "documentation": {
                      "identifier": "localServer.buildup",
                      "newPage": false,
                      "searchKey": "net.localServer.buildup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ls *localServer) buildup(handler func(*localServer, Listener)) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ls *localServer) buildup(handler func(*localServer, Listener)) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#localServer.teardown",
                    "documentation": {
                      "identifier": "localServer.teardown",
                      "newPage": false,
                      "searchKey": "net.localServer.teardown",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ls *localServer) teardown() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ls *localServer) teardown() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#localServer.transponder",
                    "documentation": {
                      "identifier": "localServer.transponder",
                      "newPage": false,
                      "searchKey": "net.localServer.transponder",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ls *localServer) transponder(ln Listener, ch chan<- error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ls *localServer) transponder(ln Listener, ch chan<- error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#streamListener",
              "documentation": {
                "identifier": "streamListener",
                "newPage": false,
                "searchKey": "net.streamListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type streamListener struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype streamListener struct {\n\tnetwork, address string\n\tListener\n\tdone chan bool // signal that indicates server stopped\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#streamListener.newLocalServer",
                    "documentation": {
                      "identifier": "streamListener.newLocalServer",
                      "newPage": false,
                      "searchKey": "net.streamListener.newLocalServer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sl *streamListener) newLocalServer() (*localServer, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sl *streamListener) newLocalServer() (*localServer, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#dualStackServer",
              "documentation": {
                "identifier": "dualStackServer",
                "newPage": false,
                "searchKey": "net.dualStackServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dualStackServer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dualStackServer struct {\n\tlnmu sync.RWMutex\n\tlns  []streamListener\n\tport string\n\n\tcmu sync.RWMutex\n\tcs  []Conn // established connections at the passive open side\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newDualStackServer",
                    "documentation": {
                      "identifier": "newDualStackServer",
                      "newPage": false,
                      "searchKey": "net.newDualStackServer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newDualStackServer() (*dualStackServer, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newDualStackServer() (*dualStackServer, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#dualStackServer.buildup",
                    "documentation": {
                      "identifier": "dualStackServer.buildup",
                      "newPage": false,
                      "searchKey": "net.dualStackServer.buildup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dss *dualStackServer) buildup(handler func(*dualStackServer, Listener)) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dss *dualStackServer) buildup(handler func(*dualStackServer, Listener)) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#dualStackServer.teardownNetwork",
                    "documentation": {
                      "identifier": "dualStackServer.teardownNetwork",
                      "newPage": false,
                      "searchKey": "net.dualStackServer.teardownNetwork",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dss *dualStackServer) teardownNetwork(network string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dss *dualStackServer) teardownNetwork(network string) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#dualStackServer.teardown",
                    "documentation": {
                      "identifier": "dualStackServer.teardown",
                      "newPage": false,
                      "searchKey": "net.dualStackServer.teardown",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dss *dualStackServer) teardown() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dss *dualStackServer) teardown() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#localPacketServer",
              "documentation": {
                "identifier": "localPacketServer",
                "newPage": false,
                "searchKey": "net.localPacketServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type localPacketServer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype localPacketServer struct {\n\tpcmu sync.RWMutex\n\tPacketConn\n\tdone chan bool // signal that indicates server stopped\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#newLocalPacketServer",
                    "documentation": {
                      "identifier": "newLocalPacketServer",
                      "newPage": false,
                      "searchKey": "net.newLocalPacketServer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newLocalPacketServer(network string) (*localPacketServer, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newLocalPacketServer(network string) (*localPacketServer, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#localPacketServer.buildup",
                    "documentation": {
                      "identifier": "localPacketServer.buildup",
                      "newPage": false,
                      "searchKey": "net.localPacketServer.buildup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ls *localPacketServer) buildup(handler func(*localPacketServer, PacketConn)) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ls *localPacketServer) buildup(handler func(*localPacketServer, PacketConn)) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#localPacketServer.teardown",
                    "documentation": {
                      "identifier": "localPacketServer.teardown",
                      "newPage": false,
                      "searchKey": "net.localPacketServer.teardown",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ls *localPacketServer) teardown() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ls *localPacketServer) teardown() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#packetListener",
              "documentation": {
                "identifier": "packetListener",
                "newPage": false,
                "searchKey": "net.packetListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type packetListener struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype packetListener struct {\n\tPacketConn\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#packetListener.newLocalServer",
                    "documentation": {
                      "identifier": "packetListener.newLocalServer",
                      "newPage": false,
                      "searchKey": "net.packetListener.newLocalServer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pl *packetListener) newLocalServer() (*localPacketServer, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pl *packetListener) newLocalServer() (*localPacketServer, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#resolveTCPAddrTest",
              "documentation": {
                "identifier": "resolveTCPAddrTest",
                "newPage": false,
                "searchKey": "net.resolveTCPAddrTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type resolveTCPAddrTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype resolveTCPAddrTest struct {\n\tnetwork       string\n\tlitAddrOrName string\n\taddr          *TCPAddr\n\terr           error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#neverEnding",
              "documentation": {
                "identifier": "neverEnding",
                "newPage": false,
                "searchKey": "net.neverEnding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type neverEnding byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype neverEnding byte\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#neverEnding.Read",
                    "documentation": {
                      "identifier": "neverEnding.Read",
                      "newPage": false,
                      "searchKey": "net.neverEnding.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b neverEnding) Read(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b neverEnding) Read(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#resolveUDPAddrTest",
              "documentation": {
                "identifier": "resolveUDPAddrTest",
                "newPage": false,
                "searchKey": "net.resolveUDPAddrTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type resolveUDPAddrTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype resolveUDPAddrTest struct {\n\tnetwork       string\n\tlitAddrOrName string\n\taddr          *UDPAddr\n\terr           error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#addrinfoErrno",
              "documentation": {
                "identifier": "addrinfoErrno",
                "newPage": false,
                "searchKey": "net.addrinfoErrno",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type addrinfoErrno int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype addrinfoErrno int\n```\n\nAn addrinfoErrno represents a getaddrinfo, getnameinfo-specific error number. It's a signed number and a zero value is a non-error by convention. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/net#addrinfoErrno.Error",
                    "documentation": {
                      "identifier": "addrinfoErrno.Error",
                      "newPage": false,
                      "searchKey": "net.addrinfoErrno.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (eai addrinfoErrno) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (eai addrinfoErrno) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#addrinfoErrno.Temporary",
                    "documentation": {
                      "identifier": "addrinfoErrno.Temporary",
                      "newPage": false,
                      "searchKey": "net.addrinfoErrno.Temporary",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (eai addrinfoErrno) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (eai addrinfoErrno) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/net#addrinfoErrno.Timeout",
                    "documentation": {
                      "identifier": "addrinfoErrno.Timeout",
                      "newPage": false,
                      "searchKey": "net.addrinfoErrno.Timeout",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (eai addrinfoErrno) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (eai addrinfoErrno) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/net#portLookupResult",
              "documentation": {
                "identifier": "portLookupResult",
                "newPage": false,
                "searchKey": "net.portLookupResult",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type portLookupResult struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype portLookupResult struct {\n\tport int\n\terr  error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipLookupResult",
              "documentation": {
                "identifier": "ipLookupResult",
                "newPage": false,
                "searchKey": "net.ipLookupResult",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ipLookupResult struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ipLookupResult struct {\n\taddrs []IPAddr\n\tcname string\n\terr   error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#reverseLookupResult",
              "documentation": {
                "identifier": "reverseLookupResult",
                "newPage": false,
                "searchKey": "net.reverseLookupResult",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type reverseLookupResult struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype reverseLookupResult struct {\n\tnames []string\n\terr   error\n}\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/net#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/net#sortByRFC6724",
              "documentation": {
                "identifier": "sortByRFC6724",
                "newPage": false,
                "searchKey": "net.sortByRFC6724",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sortByRFC6724(addrs []IPAddr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sortByRFC6724(addrs []IPAddr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#sortByRFC6724withSrcs",
              "documentation": {
                "identifier": "sortByRFC6724withSrcs",
                "newPage": false,
                "searchKey": "net.sortByRFC6724withSrcs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sortByRFC6724withSrcs(addrs []IPAddr, srcs []IP)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sortByRFC6724withSrcs(addrs []IPAddr, srcs []IP)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#srcAddrs",
              "documentation": {
                "identifier": "srcAddrs",
                "newPage": false,
                "searchKey": "net.srcAddrs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func srcAddrs(addrs []IPAddr) []IP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc srcAddrs(addrs []IPAddr) []IP\n```\n\nsrcsAddrs tries to UDP-connect to each address to see if it has a route. (This doesn't send any packets). The destination port number is irrelevant. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "net.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#commonPrefixLen",
              "documentation": {
                "identifier": "commonPrefixLen",
                "newPage": false,
                "searchKey": "net.commonPrefixLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func commonPrefixLen(a, b IP) (cpl int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc commonPrefixLen(a, b IP) (cpl int)\n```\n\ncommonPrefixLen reports the length of the longest prefix (looking at the most significant, or leftmost, bits) that the two addresses have in common, up to the length of a's prefix (i.e., the portion of the address not including the interface ID). \n\nIf a or b is an IPv4 address as an IPv6 address, the IPv4 addresses are compared (with max common prefix length of 32). If a and b are different IP versions, 0 is returned. \n\nSee [https://tools.ietf.org/html/rfc6724#section-2.2](https://tools.ietf.org/html/rfc6724#section-2.2) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#initConfVal",
              "documentation": {
                "identifier": "initConfVal",
                "newPage": false,
                "searchKey": "net.initConfVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func initConfVal()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc initConfVal()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#goDebugNetDNS",
              "documentation": {
                "identifier": "goDebugNetDNS",
                "newPage": false,
                "searchKey": "net.goDebugNetDNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goDebugNetDNS() (dnsMode string, debugLevel int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goDebugNetDNS() (dnsMode string, debugLevel int)\n```\n\ngoDebugNetDNS parses the value of the GODEBUG \"netdns\" value. The netdns value can be of the form: \n\n```\n1       // debug level 1\n2       // debug level 2\ncgo     // use cgo for DNS lookups\ngo      // use go for DNS lookups\ncgo+1   // use cgo for DNS lookups + debug level 1\n1+cgo   // same\ncgo+2   // same, but debug level 2\n\n```\netc. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isLocalhost",
              "documentation": {
                "identifier": "isLocalhost",
                "newPage": false,
                "searchKey": "net.isLocalhost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isLocalhost(h string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isLocalhost(h string) bool\n```\n\nisLocalhost reports whether h should be considered a \"localhost\" name for the myhostname NSS module. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isGateway",
              "documentation": {
                "identifier": "isGateway",
                "newPage": false,
                "searchKey": "net.isGateway",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isGateway(h string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isGateway(h string) bool\n```\n\nisGateway reports whether h should be considered a \"gateway\" name for the myhostname NSS module. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#minNonzeroTime",
              "documentation": {
                "identifier": "minNonzeroTime",
                "newPage": false,
                "searchKey": "net.minNonzeroTime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func minNonzeroTime(a, b time.Time) time.Time"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc minNonzeroTime(a, b time.Time) time.Time\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#partialDeadline",
              "documentation": {
                "identifier": "partialDeadline",
                "newPage": false,
                "searchKey": "net.partialDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func partialDeadline(now, deadline time.Time, addrsRemaining int) (time.Time, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc partialDeadline(now, deadline time.Time, addrsRemaining int) (time.Time, error)\n```\n\npartialDeadline returns the deadline to use for a single address, when multiple addresses are pending. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseNetwork",
              "documentation": {
                "identifier": "parseNetwork",
                "newPage": false,
                "searchKey": "net.parseNetwork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseNetwork(ctx context.Context, network string, needsProto bool) (afnet string, proto int, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseNetwork(ctx context.Context, network string, needsProto bool) (afnet string, proto int, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#fastrand",
              "documentation": {
                "identifier": "fastrand",
                "newPage": false,
                "searchKey": "net.fastrand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fastrand() uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fastrand() uint32\n```\n\nprovided by runtime \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#randInt",
              "documentation": {
                "identifier": "randInt",
                "newPage": false,
                "searchKey": "net.randInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func randInt() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc randInt() int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#randIntn",
              "documentation": {
                "identifier": "randIntn",
                "newPage": false,
                "searchKey": "net.randIntn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func randIntn(n int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc randIntn(n int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#reverseaddr",
              "documentation": {
                "identifier": "reverseaddr",
                "newPage": false,
                "searchKey": "net.reverseaddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reverseaddr(addr string) (arpa string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reverseaddr(addr string) (arpa string, err error)\n```\n\nreverseaddr returns the in-addr.arpa. or ip6.arpa. hostname of the IP address addr suitable for rDNS (PTR) record lookup or an error if it fails to parse the IP address. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#equalASCIIName",
              "documentation": {
                "identifier": "equalASCIIName",
                "newPage": false,
                "searchKey": "net.equalASCIIName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func equalASCIIName(x, y dnsmessage.Name) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc equalASCIIName(x, y dnsmessage.Name) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isDomainName",
              "documentation": {
                "identifier": "isDomainName",
                "newPage": false,
                "searchKey": "net.isDomainName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isDomainName(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isDomainName(s string) bool\n```\n\nisDomainName checks if a string is a presentation-format domain name (currently restricted to hostname-compatible \"preferred name\" LDH labels and SRV-like \"underscore labels\"; see golang.org/issue/12421). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#absDomainName",
              "documentation": {
                "identifier": "absDomainName",
                "newPage": false,
                "searchKey": "net.absDomainName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func absDomainName(b []byte) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc absDomainName(b []byte) string\n```\n\nabsDomainName returns an absolute domain name which ends with a trailing dot to match pure Go reverse resolver and all other lookup routines. See golang.org/issue/12189. But we don't want to add dots for local names from /etc/hosts. It's hard to tell so we settle on the heuristic that names without dots (like \"localhost\" or \"myhost\") do not get trailing dots, but any other names do. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#newRequest",
              "documentation": {
                "identifier": "newRequest",
                "newPage": false,
                "searchKey": "net.newRequest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newRequest(q dnsmessage.Question) (id uint16, udpReq, tcpReq []byte, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newRequest(q dnsmessage.Question) (id uint16, udpReq, tcpReq []byte, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkResponse",
              "documentation": {
                "identifier": "checkResponse",
                "newPage": false,
                "searchKey": "net.checkResponse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkResponse(reqID uint16, reqQues dnsmessage.Question, respHdr dnsmessage.Header, respQues dnsmessage.Question) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkResponse(reqID uint16, reqQues dnsmessage.Question, respHdr dnsmessage.Header, respQues dnsmessage.Question) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsPacketRoundTrip",
              "documentation": {
                "identifier": "dnsPacketRoundTrip",
                "newPage": false,
                "searchKey": "net.dnsPacketRoundTrip",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dnsPacketRoundTrip(c Conn, id uint16, query dnsmessage.Question, b []byte) (dnsmessage.Parser, dnsmessage.Header, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dnsPacketRoundTrip(c Conn, id uint16, query dnsmessage.Question, b []byte) (dnsmessage.Parser, dnsmessage.Header, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsStreamRoundTrip",
              "documentation": {
                "identifier": "dnsStreamRoundTrip",
                "newPage": false,
                "searchKey": "net.dnsStreamRoundTrip",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dnsStreamRoundTrip(c Conn, id uint16, query dnsmessage.Question, b []byte) (dnsmessage.Parser, dnsmessage.Header, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dnsStreamRoundTrip(c Conn, id uint16, query dnsmessage.Question, b []byte) (dnsmessage.Parser, dnsmessage.Header, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkHeader",
              "documentation": {
                "identifier": "checkHeader",
                "newPage": false,
                "searchKey": "net.checkHeader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkHeader(p *dnsmessage.Parser, h dnsmessage.Header) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkHeader(p *dnsmessage.Parser, h dnsmessage.Header) error\n```\n\ncheckHeader performs basic sanity checks on the header. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#skipToAnswer",
              "documentation": {
                "identifier": "skipToAnswer",
                "newPage": false,
                "searchKey": "net.skipToAnswer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func skipToAnswer(p *dnsmessage.Parser, qtype dnsmessage.Type) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc skipToAnswer(p *dnsmessage.Parser, qtype dnsmessage.Type) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#avoidDNS",
              "documentation": {
                "identifier": "avoidDNS",
                "newPage": false,
                "searchKey": "net.avoidDNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func avoidDNS(name string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc avoidDNS(name string) bool\n```\n\navoidDNS reports whether this is a hostname for which we should not use DNS. Currently this includes only .onion, per RFC 7686. See golang.org/issue/13705. Does not cover .local names (RFC 6762), see golang.org/issue/16739. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#goLookupIPFiles",
              "documentation": {
                "identifier": "goLookupIPFiles",
                "newPage": false,
                "searchKey": "net.goLookupIPFiles",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goLookupIPFiles(name string) (addrs []IPAddr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goLookupIPFiles(name string) (addrs []IPAddr)\n```\n\nlookup entries from /etc/hosts \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dnsDefaultSearch",
              "documentation": {
                "identifier": "dnsDefaultSearch",
                "newPage": false,
                "searchKey": "net.dnsDefaultSearch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dnsDefaultSearch() []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dnsDefaultSearch() []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hasPrefix",
              "documentation": {
                "identifier": "hasPrefix",
                "newPage": false,
                "searchKey": "net.hasPrefix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasPrefix(s, prefix string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasPrefix(s, prefix string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ensureRooted",
              "documentation": {
                "identifier": "ensureRooted",
                "newPage": false,
                "searchKey": "net.ensureRooted",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ensureRooted(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ensureRooted(s string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#wrapSyscallError",
              "documentation": {
                "identifier": "wrapSyscallError",
                "newPage": false,
                "searchKey": "net.wrapSyscallError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func wrapSyscallError(name string, err error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wrapSyscallError(name string, err error) error\n```\n\nwrapSyscallError takes an error and a syscall name. If the error is a syscall.Errno, it wraps it in a os.SyscallError using the syscall name. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isConnError",
              "documentation": {
                "identifier": "isConnError",
                "newPage": false,
                "searchKey": "net.isConnError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isConnError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isConnError(err error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dupSocket",
              "documentation": {
                "identifier": "dupSocket",
                "newPage": false,
                "searchKey": "net.dupSocket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dupSocket(f *os.File) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dupSocket(f *os.File) (int, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseLiteralIP",
              "documentation": {
                "identifier": "parseLiteralIP",
                "newPage": false,
                "searchKey": "net.parseLiteralIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseLiteralIP(addr string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseLiteralIP(addr string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readHosts",
              "documentation": {
                "identifier": "readHosts",
                "newPage": false,
                "searchKey": "net.readHosts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readHosts()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readHosts()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupStaticHost",
              "documentation": {
                "identifier": "lookupStaticHost",
                "newPage": false,
                "searchKey": "net.lookupStaticHost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookupStaticHost(host string) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookupStaticHost(host string) []string\n```\n\nlookupStaticHost looks up the addresses for the given host from /etc/hosts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupStaticAddr",
              "documentation": {
                "identifier": "lookupStaticAddr",
                "newPage": false,
                "searchKey": "net.lookupStaticAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookupStaticAddr(addr string) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookupStaticAddr(addr string) []string\n```\n\nlookupStaticAddr looks up the hosts for the given address from /etc/hosts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#Interfaces",
              "documentation": {
                "identifier": "Interfaces",
                "newPage": false,
                "searchKey": "net.Interfaces",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Interfaces() ([]Interface, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Interfaces() ([]Interface, error)\n```\n\nInterfaces returns a list of the system's network interfaces. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#InterfaceAddrs",
              "documentation": {
                "identifier": "InterfaceAddrs",
                "newPage": false,
                "searchKey": "net.InterfaceAddrs",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func InterfaceAddrs() ([]Addr, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc InterfaceAddrs() ([]Addr, error)\n```\n\nInterfaceAddrs returns a list of the system's unicast interface addresses. \n\nThe returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#interfaceTable",
              "documentation": {
                "identifier": "interfaceTable",
                "newPage": false,
                "searchKey": "net.interfaceTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func interfaceTable(ifindex int) ([]Interface, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc interfaceTable(ifindex int) ([]Interface, error)\n```\n\nIf the ifindex is zero, interfaceTable returns mappings of all network interfaces. Otherwise it returns a mapping of a specific interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#interfaceAddrTable",
              "documentation": {
                "identifier": "interfaceAddrTable",
                "newPage": false,
                "searchKey": "net.interfaceAddrTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func interfaceAddrTable(ifi *Interface) ([]Addr, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc interfaceAddrTable(ifi *Interface) ([]Addr, error)\n```\n\nIf the ifi is nil, interfaceAddrTable returns addresses for all network interfaces. Otherwise it returns addresses for a specific interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#interfaceMessages",
              "documentation": {
                "identifier": "interfaceMessages",
                "newPage": false,
                "searchKey": "net.interfaceMessages",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func interfaceMessages(ifindex int) ([]route.Message, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc interfaceMessages(ifindex int) ([]route.Message, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#interfaceMulticastAddrTable",
              "documentation": {
                "identifier": "interfaceMulticastAddrTable",
                "newPage": false,
                "searchKey": "net.interfaceMulticastAddrTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)\n```\n\ninterfaceMulticastAddrTable returns addresses for a specific interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isZeros",
              "documentation": {
                "identifier": "isZeros",
                "newPage": false,
                "searchKey": "net.isZeros",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isZeros(p IP) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isZeros(p IP) bool\n```\n\nIs p all zeros? \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#allFF",
              "documentation": {
                "identifier": "allFF",
                "newPage": false,
                "searchKey": "net.allFF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func allFF(b []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc allFF(b []byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ubtoa",
              "documentation": {
                "identifier": "ubtoa",
                "newPage": false,
                "searchKey": "net.ubtoa",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ubtoa(dst []byte, start int, v byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ubtoa(dst []byte, start int, v byte) int\n```\n\nubtoa encodes the string form of the integer v to dst[start:] and returns the number of bytes written to dst. The caller must ensure that dst has sufficient length. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hexString",
              "documentation": {
                "identifier": "hexString",
                "newPage": false,
                "searchKey": "net.hexString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hexString(b []byte) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hexString(b []byte) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipEmptyString",
              "documentation": {
                "identifier": "ipEmptyString",
                "newPage": false,
                "searchKey": "net.ipEmptyString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ipEmptyString(ip IP) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ipEmptyString(ip IP) string\n```\n\nipEmptyString is like ip.String except that it returns an empty string when ip is unset. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#simpleMaskLength",
              "documentation": {
                "identifier": "simpleMaskLength",
                "newPage": false,
                "searchKey": "net.simpleMaskLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func simpleMaskLength(mask IPMask) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc simpleMaskLength(mask IPMask) int\n```\n\nIf mask is a sequence of 1 bits followed by 0 bits, return the number of 1 bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#stripIPv4Header",
              "documentation": {
                "identifier": "stripIPv4Header",
                "newPage": false,
                "searchKey": "net.stripIPv4Header",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stripIPv4Header(n int, b []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stripIPv4Header(n int, b []byte) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#supportsIPv4",
              "documentation": {
                "identifier": "supportsIPv4",
                "newPage": false,
                "searchKey": "net.supportsIPv4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func supportsIPv4() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc supportsIPv4() bool\n```\n\nsupportsIPv4 reports whether the platform supports IPv4 networking functionality. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#supportsIPv6",
              "documentation": {
                "identifier": "supportsIPv6",
                "newPage": false,
                "searchKey": "net.supportsIPv6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func supportsIPv6() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc supportsIPv6() bool\n```\n\nsupportsIPv6 reports whether the platform supports IPv6 networking functionality. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#supportsIPv4map",
              "documentation": {
                "identifier": "supportsIPv4map",
                "newPage": false,
                "searchKey": "net.supportsIPv4map",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func supportsIPv4map() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc supportsIPv4map() bool\n```\n\nsupportsIPv4map reports whether the platform supports mapping an IPv4 address inside an IPv6 address at transport layer protocols. See RFC 4291, RFC 4038 and RFC 3493. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isIPv4",
              "documentation": {
                "identifier": "isIPv4",
                "newPage": false,
                "searchKey": "net.isIPv4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isIPv4(addr Addr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isIPv4(addr Addr) bool\n```\n\nisIPv4 reports whether addr contains an IPv4 address. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isNotIPv4",
              "documentation": {
                "identifier": "isNotIPv4",
                "newPage": false,
                "searchKey": "net.isNotIPv4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isNotIPv4(addr Addr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isNotIPv4(addr Addr) bool\n```\n\nisNotIPv4 reports whether addr does not contain an IPv4 address. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipv4only",
              "documentation": {
                "identifier": "ipv4only",
                "newPage": false,
                "searchKey": "net.ipv4only",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ipv4only(addr IPAddr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ipv4only(addr IPAddr) bool\n```\n\nipv4only reports whether addr is an IPv4 address. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipv6only",
              "documentation": {
                "identifier": "ipv6only",
                "newPage": false,
                "searchKey": "net.ipv6only",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ipv6only(addr IPAddr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ipv6only(addr IPAddr) bool\n```\n\nipv6only reports whether addr is an IPv6 address except IPv4-mapped IPv6 address. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#SplitHostPort",
              "documentation": {
                "identifier": "SplitHostPort",
                "newPage": false,
                "searchKey": "net.SplitHostPort",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SplitHostPort(hostport string) (host, port string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SplitHostPort(hostport string) (host, port string, err error)\n```\n\nSplitHostPort splits a network address of the form \"host:port\", \"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or host%zone and port. \n\nA literal IPv6 address in hostport must be enclosed in square brackets, as in \"[::1]:80\", \"[::1%lo0]:80\". \n\nSee func Dial for a description of the hostport parameter, and host and port results. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#splitHostZone",
              "documentation": {
                "identifier": "splitHostZone",
                "newPage": false,
                "searchKey": "net.splitHostZone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func splitHostZone(s string) (host, zone string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc splitHostZone(s string) (host, zone string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#JoinHostPort",
              "documentation": {
                "identifier": "JoinHostPort",
                "newPage": false,
                "searchKey": "net.JoinHostPort",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func JoinHostPort(host, port string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc JoinHostPort(host, port string) string\n```\n\nJoinHostPort combines host and port into a network address of the form \"host:port\". If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns \"[host]:port\". \n\nSee func Dial for a description of the host and port parameters. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#favoriteAddrFamily",
              "documentation": {
                "identifier": "favoriteAddrFamily",
                "newPage": false,
                "searchKey": "net.favoriteAddrFamily",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func favoriteAddrFamily(network string, laddr, raddr sockaddr, mode string) (family int, ipv6only bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc favoriteAddrFamily(network string, laddr, raddr sockaddr, mode string) (family int, ipv6only bool)\n```\n\nfavoriteAddrFamily returns the appropriate address family for the given network, laddr, raddr and mode. \n\nIf mode indicates \"listen\" and laddr is a wildcard, we assume that the user wants to make a passive-open connection with a wildcard address family, both AF_INET and AF_INET6, and a wildcard address like the following: \n\n```\n- A listen for a wildcard communication domain, \"tcp\" or\n  \"udp\", with a wildcard address: If the platform supports\n  both IPv6 and IPv4-mapped IPv6 communication capabilities,\n  or does not support IPv4, we use a dual stack, AF_INET6 and\n  IPV6_V6ONLY=0, wildcard address listen. The dual stack\n  wildcard address listen may fall back to an IPv6-only,\n  AF_INET6 and IPV6_V6ONLY=1, wildcard address listen.\n  Otherwise we prefer an IPv4-only, AF_INET, wildcard address\n  listen.\n\n- A listen for a wildcard communication domain, \"tcp\" or\n  \"udp\", with an IPv4 wildcard address: same as above.\n\n- A listen for a wildcard communication domain, \"tcp\" or\n  \"udp\", with an IPv6 wildcard address: same as above.\n\n- A listen for an IPv4 communication domain, \"tcp4\" or \"udp4\",\n  with an IPv4 wildcard address: We use an IPv4-only, AF_INET,\n  wildcard address listen.\n\n- A listen for an IPv6 communication domain, \"tcp6\" or \"udp6\",\n  with an IPv6 wildcard address: We use an IPv6-only, AF_INET6\n  and IPV6_V6ONLY=1, wildcard address listen.\n\n```\nOtherwise guess: If the addresses are IPv4 then returns AF_INET, or else returns AF_INET6. It also returns a boolean value what designates IPV6_V6ONLY option. \n\nNote that the latest DragonFly BSD and OpenBSD kernels allow neither \"net.inet6.ip6.v6only=1\" change nor IPPROTO_IPV6 level IPV6_V6ONLY socket option setting. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipToSockaddr",
              "documentation": {
                "identifier": "ipToSockaddr",
                "newPage": false,
                "searchKey": "net.ipToSockaddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ipToSockaddr(family int, ip IP, port int, zone string) (syscall.Sockaddr, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ipToSockaddr(family int, ip IP, port int, zone string) (syscall.Sockaddr, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupProtocolMap",
              "documentation": {
                "identifier": "lookupProtocolMap",
                "newPage": false,
                "searchKey": "net.lookupProtocolMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookupProtocolMap(name string) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookupProtocolMap(name string) (int, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupPortMap",
              "documentation": {
                "identifier": "lookupPortMap",
                "newPage": false,
                "searchKey": "net.lookupPortMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookupPortMap(network, service string) (port int, error error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookupPortMap(network, service string) (port int, error error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipVersion",
              "documentation": {
                "identifier": "ipVersion",
                "newPage": false,
                "searchKey": "net.ipVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ipVersion(network string) byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ipVersion(network string) byte\n```\n\nipVersion returns the provided network's IP version: '4', '6' or 0 if network does not end in a '4' or '6' byte. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#LookupHost",
              "documentation": {
                "identifier": "LookupHost",
                "newPage": false,
                "searchKey": "net.LookupHost",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupHost(host string) (addrs []string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupHost(host string) (addrs []string, err error)\n```\n\nLookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses. \n\nLookupHost uses context.Background internally; to specify the context, use Resolver.LookupHost. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#LookupIP",
              "documentation": {
                "identifier": "LookupIP",
                "newPage": false,
                "searchKey": "net.LookupIP",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupIP(host string) ([]IP, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupIP(host string) ([]IP, error)\n```\n\nLookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#withUnexpiredValuesPreserved",
              "documentation": {
                "identifier": "withUnexpiredValuesPreserved",
                "newPage": false,
                "searchKey": "net.withUnexpiredValuesPreserved",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func withUnexpiredValuesPreserved(lookupCtx context.Context) context.Context"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc withUnexpiredValuesPreserved(lookupCtx context.Context) context.Context\n```\n\nwithUnexpiredValuesPreserved returns a context.Context that only uses lookupCtx for its values, otherwise it is never canceled and has no deadline. If the lookup context expires, any looked up values will return nil. See Issue 28600. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupIPReturn",
              "documentation": {
                "identifier": "lookupIPReturn",
                "newPage": false,
                "searchKey": "net.lookupIPReturn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookupIPReturn(addrsi interface{}, err error, shared bool) ([]IPAddr, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookupIPReturn(addrsi interface{}, err error, shared bool) ([]IPAddr, error)\n```\n\nlookupIPReturn turns the return values from singleflight.Do into the return values from LookupIP. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipAddrsEface",
              "documentation": {
                "identifier": "ipAddrsEface",
                "newPage": false,
                "searchKey": "net.ipAddrsEface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ipAddrsEface(addrs []IPAddr) []interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ipAddrsEface(addrs []IPAddr) []interface{}\n```\n\nipAddrsEface returns an empty interface slice of addrs. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#LookupPort",
              "documentation": {
                "identifier": "LookupPort",
                "newPage": false,
                "searchKey": "net.LookupPort",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupPort(network, service string) (port int, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupPort(network, service string) (port int, err error)\n```\n\nLookupPort looks up the port for the given network and service. \n\nLookupPort uses context.Background internally; to specify the context, use Resolver.LookupPort. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#LookupCNAME",
              "documentation": {
                "identifier": "LookupCNAME",
                "newPage": false,
                "searchKey": "net.LookupCNAME",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupCNAME(host string) (cname string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupCNAME(host string) (cname string, err error)\n```\n\nLookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup. \n\nA canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS \"CNAME\" records, as long as host resolves to address records. \n\nThe returned canonical name is validated to be a properly formatted presentation-format domain name. \n\nLookupCNAME uses context.Background internally; to specify the context, use Resolver.LookupCNAME. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#LookupSRV",
              "documentation": {
                "identifier": "LookupSRV",
                "newPage": false,
                "searchKey": "net.LookupSRV",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)\n```\n\nLookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority. \n\nLookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. \n\nThe returned service names are validated to be properly formatted presentation-format domain names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#LookupMX",
              "documentation": {
                "identifier": "LookupMX",
                "newPage": false,
                "searchKey": "net.LookupMX",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupMX(name string) ([]*MX, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupMX(name string) ([]*MX, error)\n```\n\nLookupMX returns the DNS MX records for the given domain name sorted by preference. \n\nThe returned mail server names are validated to be properly formatted presentation-format domain names. \n\nLookupMX uses context.Background internally; to specify the context, use Resolver.LookupMX. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#LookupNS",
              "documentation": {
                "identifier": "LookupNS",
                "newPage": false,
                "searchKey": "net.LookupNS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupNS(name string) ([]*NS, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupNS(name string) ([]*NS, error)\n```\n\nLookupNS returns the DNS NS records for the given domain name. \n\nThe returned name server names are validated to be properly formatted presentation-format domain names. \n\nLookupNS uses context.Background internally; to specify the context, use Resolver.LookupNS. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#LookupTXT",
              "documentation": {
                "identifier": "LookupTXT",
                "newPage": false,
                "searchKey": "net.LookupTXT",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupTXT(name string) ([]string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupTXT(name string) ([]string, error)\n```\n\nLookupTXT returns the DNS TXT records for the given domain name. \n\nLookupTXT uses context.Background internally; to specify the context, use Resolver.LookupTXT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#LookupAddr",
              "documentation": {
                "identifier": "LookupAddr",
                "newPage": false,
                "searchKey": "net.LookupAddr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupAddr(addr string) (names []string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupAddr(addr string) (names []string, err error)\n```\n\nLookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. \n\nThe returned names are validated to be properly formatted presentation-format domain names. \n\nWhen using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom Resolver. \n\nLookupAddr uses context.Background internally; to specify the context, use Resolver.LookupAddr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readProtocols",
              "documentation": {
                "identifier": "readProtocols",
                "newPage": false,
                "searchKey": "net.readProtocols",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readProtocols()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readProtocols()\n```\n\nreadProtocols loads contents of /etc/protocols into protocols map for quick access. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupProtocol",
              "documentation": {
                "identifier": "lookupProtocol",
                "newPage": false,
                "searchKey": "net.lookupProtocol",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookupProtocol(_ context.Context, name string) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookupProtocol(_ context.Context, name string) (int, error)\n```\n\nlookupProtocol looks up IP protocol name in /etc/protocols and returns correspondent protocol number. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#concurrentThreadsLimit",
              "documentation": {
                "identifier": "concurrentThreadsLimit",
                "newPage": false,
                "searchKey": "net.concurrentThreadsLimit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func concurrentThreadsLimit() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc concurrentThreadsLimit() int\n```\n\nconcurrentThreadsLimit returns the number of threads we permit to run concurrently doing DNS lookups via cgo. A DNS lookup may use a file descriptor so we limit this to less than the number of permitted open files. On some systems, notably Darwin, if getaddrinfo is unable to open a file descriptor it simply returns EAI_NONAME rather than a useful error. Limiting the number of concurrent getaddrinfo calls to less than the permitted number of file descriptors makes that error less likely. We don't bother to apply the same limit to DNS lookups run directly from Go, because there we will return a meaningful \"too many open files\" error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#listenerBacklog",
              "documentation": {
                "identifier": "listenerBacklog",
                "newPage": false,
                "searchKey": "net.listenerBacklog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func listenerBacklog() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc listenerBacklog() int\n```\n\nlistenerBacklog is a caching wrapper around maxListenerBacklog. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#mapErr",
              "documentation": {
                "identifier": "mapErr",
                "newPage": false,
                "searchKey": "net.mapErr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapErr(err error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapErr(err error) error\n```\n\nmapErr maps from the context errors to the historical internal net error values. \n\nTODO(bradfitz): get rid of this after adjusting tests and making context.DeadlineExceeded implement net.Error? \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#genericReadFrom",
              "documentation": {
                "identifier": "genericReadFrom",
                "newPage": false,
                "searchKey": "net.genericReadFrom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func genericReadFrom(w io.Writer, r io.Reader) (n int64, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc genericReadFrom(w io.Writer, r io.Reader) (n int64, err error)\n```\n\nFallback implementation of io.ReaderFrom's ReadFrom, when sendfile isn't applicable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#acquireThread",
              "documentation": {
                "identifier": "acquireThread",
                "newPage": false,
                "searchKey": "net.acquireThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func acquireThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc acquireThread()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#releaseThread",
              "documentation": {
                "identifier": "releaseThread",
                "newPage": false,
                "searchKey": "net.releaseThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func releaseThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc releaseThread()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseCriteria",
              "documentation": {
                "identifier": "parseCriteria",
                "newPage": false,
                "searchKey": "net.parseCriteria",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseCriteria(x []byte) (c []nssCriterion, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseCriteria(x []byte) (c []nssCriterion, err error)\n```\n\nparses \"foo=bar !foo=bar\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#stat",
              "documentation": {
                "identifier": "stat",
                "newPage": false,
                "searchKey": "net.stat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stat(name string) (mtime time.Time, size int64, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stat(name string) (mtime time.Time, size int64, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#countAnyByte",
              "documentation": {
                "identifier": "countAnyByte",
                "newPage": false,
                "searchKey": "net.countAnyByte",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func countAnyByte(s string, t string) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc countAnyByte(s string, t string) int\n```\n\nCount occurrences in s of any bytes in t. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#splitAtBytes",
              "documentation": {
                "identifier": "splitAtBytes",
                "newPage": false,
                "searchKey": "net.splitAtBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func splitAtBytes(s string, t string) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc splitAtBytes(s string, t string) []string\n```\n\nSplit s at any bytes in t. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#getFields",
              "documentation": {
                "identifier": "getFields",
                "newPage": false,
                "searchKey": "net.getFields",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getFields(s string) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getFields(s string) []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dtoi",
              "documentation": {
                "identifier": "dtoi",
                "newPage": false,
                "searchKey": "net.dtoi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dtoi(s string) (n int, i int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dtoi(s string) (n int, i int, ok bool)\n```\n\nDecimal to integer. Returns number, characters consumed, success. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#xtoi",
              "documentation": {
                "identifier": "xtoi",
                "newPage": false,
                "searchKey": "net.xtoi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func xtoi(s string) (n int, i int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc xtoi(s string) (n int, i int, ok bool)\n```\n\nHexadecimal to integer. Returns number, characters consumed, success. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#xtoi2",
              "documentation": {
                "identifier": "xtoi2",
                "newPage": false,
                "searchKey": "net.xtoi2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func xtoi2(s string, e byte) (byte, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc xtoi2(s string, e byte) (byte, bool)\n```\n\nxtoi2 converts the next two hex digits of s into a byte. If s is longer than 2 bytes then the third byte must be e. If the first two bytes of s are not hex digits or the third byte does not match e, false is returned. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#appendHex",
              "documentation": {
                "identifier": "appendHex",
                "newPage": false,
                "searchKey": "net.appendHex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendHex(dst []byte, i uint32) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendHex(dst []byte, i uint32) []byte\n```\n\nConvert i to a hexadecimal string. Leading zeros are not printed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#count",
              "documentation": {
                "identifier": "count",
                "newPage": false,
                "searchKey": "net.count",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func count(s string, b byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc count(s string, b byte) int\n```\n\nNumber of occurrences of b in s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#last",
              "documentation": {
                "identifier": "last",
                "newPage": false,
                "searchKey": "net.last",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func last(s string, b byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc last(s string, b byte) int\n```\n\nIndex of rightmost occurrence of b in s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lowerASCIIBytes",
              "documentation": {
                "identifier": "lowerASCIIBytes",
                "newPage": false,
                "searchKey": "net.lowerASCIIBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lowerASCIIBytes(x []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lowerASCIIBytes(x []byte)\n```\n\nlowerASCIIBytes makes x ASCII lowercase in-place. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lowerASCII",
              "documentation": {
                "identifier": "lowerASCII",
                "newPage": false,
                "searchKey": "net.lowerASCII",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lowerASCII(b byte) byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lowerASCII(b byte) byte\n```\n\nlowerASCII returns the ASCII lowercase version of b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#trimSpace",
              "documentation": {
                "identifier": "trimSpace",
                "newPage": false,
                "searchKey": "net.trimSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func trimSpace(x []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc trimSpace(x []byte) []byte\n```\n\ntrimSpace returns x without any leading or trailing ASCII whitespace. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isSpace",
              "documentation": {
                "identifier": "isSpace",
                "newPage": false,
                "searchKey": "net.isSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSpace(b byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSpace(b byte) bool\n```\n\nisSpace reports whether b is an ASCII space character. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#removeComment",
              "documentation": {
                "identifier": "removeComment",
                "newPage": false,
                "searchKey": "net.removeComment",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func removeComment(line []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc removeComment(line []byte) []byte\n```\n\nremoveComment returns line, removing any '#' byte and any following bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#foreachLine",
              "documentation": {
                "identifier": "foreachLine",
                "newPage": false,
                "searchKey": "net.foreachLine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func foreachLine(x []byte, fn func(line []byte) error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc foreachLine(x []byte, fn func(line []byte) error) error\n```\n\nforeachLine runs fn on each line of x. Each line (except for possibly the last) ends in '\\n'. It returns the first non-nil error returned by fn. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#foreachField",
              "documentation": {
                "identifier": "foreachField",
                "newPage": false,
                "searchKey": "net.foreachField",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func foreachField(x []byte, fn func(field []byte) error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc foreachField(x []byte, fn func(field []byte) error) error\n```\n\nforeachField runs fn on each non-empty run of non-space bytes in x. It returns the first non-nil error returned by fn. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#stringsHasSuffix",
              "documentation": {
                "identifier": "stringsHasSuffix",
                "newPage": false,
                "searchKey": "net.stringsHasSuffix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringsHasSuffix(s, suffix string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringsHasSuffix(s, suffix string) bool\n```\n\nstringsHasSuffix is strings.HasSuffix. It reports whether s ends in suffix. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#stringsHasSuffixFold",
              "documentation": {
                "identifier": "stringsHasSuffixFold",
                "newPage": false,
                "searchKey": "net.stringsHasSuffixFold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringsHasSuffixFold(s, suffix string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringsHasSuffixFold(s, suffix string) bool\n```\n\nstringsHasSuffixFold reports whether s ends in suffix, ASCII-case-insensitively. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#stringsHasPrefix",
              "documentation": {
                "identifier": "stringsHasPrefix",
                "newPage": false,
                "searchKey": "net.stringsHasPrefix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringsHasPrefix(s, prefix string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringsHasPrefix(s, prefix string) bool\n```\n\nstringsHasPrefix is strings.HasPrefix. It reports whether s begins with prefix. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#stringsEqualFold",
              "documentation": {
                "identifier": "stringsEqualFold",
                "newPage": false,
                "searchKey": "net.stringsEqualFold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringsEqualFold(s, t string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringsEqualFold(s, t string) bool\n```\n\nstringsEqualFold is strings.EqualFold, ASCII only. It reports whether s and t are equal, ASCII-case-insensitively. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readFull",
              "documentation": {
                "identifier": "readFull",
                "newPage": false,
                "searchKey": "net.readFull",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readFull(r io.Reader) (all []byte, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readFull(r io.Reader) (all []byte, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#goDebugString",
              "documentation": {
                "identifier": "goDebugString",
                "newPage": false,
                "searchKey": "net.goDebugString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goDebugString(key string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goDebugString(key string) string\n```\n\ngoDebugString returns the value of the named GODEBUG key. GODEBUG is of the form \"key=val,key2=val2\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isClosedChan",
              "documentation": {
                "identifier": "isClosedChan",
                "newPage": false,
                "searchKey": "net.isClosedChan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isClosedChan(c <-chan struct{}) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isClosedChan(c <-chan struct{}) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parsePort",
              "documentation": {
                "identifier": "parsePort",
                "newPage": false,
                "searchKey": "net.parsePort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parsePort(service string) (port int, needsLookup bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parsePort(service string) (port int, needsLookup bool)\n```\n\nparsePort parses service as a decimal integer and returns the corresponding value as port. It is the caller's responsibility to parse service as a non-decimal integer when needsLookup is true. \n\nSome system resolvers will return a valid port number when given a number over 65536 (see [https://golang.org/issues/11715](https://golang.org/issues/11715)). Alas, the parser can't bail early on numbers > 65536. Therefore reasonably large/small numbers are parsed in full and rejected if invalid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readServices",
              "documentation": {
                "identifier": "readServices",
                "newPage": false,
                "searchKey": "net.readServices",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readServices()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readServices()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#goLookupPort",
              "documentation": {
                "identifier": "goLookupPort",
                "newPage": false,
                "searchKey": "net.goLookupPort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goLookupPort(network, service string) (port int, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goLookupPort(network, service string) (port int, err error)\n```\n\ngoLookupPort is the native Go implementation of LookupPort. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#sendFile",
              "documentation": {
                "identifier": "sendFile",
                "newPage": false,
                "searchKey": "net.sendFile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sendFile(c *netFD, r io.Reader) (n int64, err error, handled bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sendFile(c *netFD, r io.Reader) (n int64, err error, handled bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#maxListenerBacklog",
              "documentation": {
                "identifier": "maxListenerBacklog",
                "newPage": false,
                "searchKey": "net.maxListenerBacklog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func maxListenerBacklog() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc maxListenerBacklog() int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setDefaultSockopts",
              "documentation": {
                "identifier": "setDefaultSockopts",
                "newPage": false,
                "searchKey": "net.setDefaultSockopts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setDefaultSockopts(s, family, sotype int, ipv6only bool) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setDefaultSockopts(s, family, sotype int, ipv6only bool) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setDefaultListenerSockopts",
              "documentation": {
                "identifier": "setDefaultListenerSockopts",
                "newPage": false,
                "searchKey": "net.setDefaultListenerSockopts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setDefaultListenerSockopts(s int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setDefaultListenerSockopts(s int) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setDefaultMulticastSockopts",
              "documentation": {
                "identifier": "setDefaultMulticastSockopts",
                "newPage": false,
                "searchKey": "net.setDefaultMulticastSockopts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setDefaultMulticastSockopts(s int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setDefaultMulticastSockopts(s int) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#boolint",
              "documentation": {
                "identifier": "boolint",
                "newPage": false,
                "searchKey": "net.boolint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func boolint(b bool) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc boolint(b bool) int\n```\n\nBoolean to int. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setIPv4MreqToInterface",
              "documentation": {
                "identifier": "setIPv4MreqToInterface",
                "newPage": false,
                "searchKey": "net.setIPv4MreqToInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setIPv4MreqToInterface(mreq *syscall.IPMreq, ifi *Interface) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setIPv4MreqToInterface(mreq *syscall.IPMreq, ifi *Interface) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setReadBuffer",
              "documentation": {
                "identifier": "setReadBuffer",
                "newPage": false,
                "searchKey": "net.setReadBuffer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setReadBuffer(fd *netFD, bytes int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setReadBuffer(fd *netFD, bytes int) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setWriteBuffer",
              "documentation": {
                "identifier": "setWriteBuffer",
                "newPage": false,
                "searchKey": "net.setWriteBuffer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setWriteBuffer(fd *netFD, bytes int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setWriteBuffer(fd *netFD, bytes int) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setKeepAlive",
              "documentation": {
                "identifier": "setKeepAlive",
                "newPage": false,
                "searchKey": "net.setKeepAlive",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setKeepAlive(fd *netFD, keepalive bool) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setKeepAlive(fd *netFD, keepalive bool) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setLinger",
              "documentation": {
                "identifier": "setLinger",
                "newPage": false,
                "searchKey": "net.setLinger",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setLinger(fd *netFD, sec int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setLinger(fd *netFD, sec int) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setIPv4MulticastInterface",
              "documentation": {
                "identifier": "setIPv4MulticastInterface",
                "newPage": false,
                "searchKey": "net.setIPv4MulticastInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setIPv4MulticastInterface(fd *netFD, ifi *Interface) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setIPv4MulticastLoopback",
              "documentation": {
                "identifier": "setIPv4MulticastLoopback",
                "newPage": false,
                "searchKey": "net.setIPv4MulticastLoopback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setIPv4MulticastLoopback(fd *netFD, v bool) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setIPv4MulticastLoopback(fd *netFD, v bool) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#joinIPv4Group",
              "documentation": {
                "identifier": "joinIPv4Group",
                "newPage": false,
                "searchKey": "net.joinIPv4Group",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func joinIPv4Group(fd *netFD, ifi *Interface, ip IP) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc joinIPv4Group(fd *netFD, ifi *Interface, ip IP) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setIPv6MulticastInterface",
              "documentation": {
                "identifier": "setIPv6MulticastInterface",
                "newPage": false,
                "searchKey": "net.setIPv6MulticastInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setIPv6MulticastInterface(fd *netFD, ifi *Interface) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setIPv6MulticastInterface(fd *netFD, ifi *Interface) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setIPv6MulticastLoopback",
              "documentation": {
                "identifier": "setIPv6MulticastLoopback",
                "newPage": false,
                "searchKey": "net.setIPv6MulticastLoopback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setIPv6MulticastLoopback(fd *netFD, v bool) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setIPv6MulticastLoopback(fd *netFD, v bool) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#joinIPv6Group",
              "documentation": {
                "identifier": "joinIPv6Group",
                "newPage": false,
                "searchKey": "net.joinIPv6Group",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func joinIPv6Group(fd *netFD, ifi *Interface, ip IP) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc joinIPv6Group(fd *netFD, ifi *Interface, ip IP) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#splice",
              "documentation": {
                "identifier": "splice",
                "newPage": false,
                "searchKey": "net.splice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func splice(c *netFD, r io.Reader) (int64, error, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc splice(c *netFD, r io.Reader) (int64, error, bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#sysSocket",
              "documentation": {
                "identifier": "sysSocket",
                "newPage": false,
                "searchKey": "net.sysSocket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysSocket(family, sotype, proto int) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysSocket(family, sotype, proto int) (int, error)\n```\n\nWrapper around the socket system call that marks the returned file descriptor as nonblocking and close-on-exec. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#roundDurationUp",
              "documentation": {
                "identifier": "roundDurationUp",
                "newPage": false,
                "searchKey": "net.roundDurationUp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func roundDurationUp(d time.Duration, to time.Duration) time.Duration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc roundDurationUp(d time.Duration, to time.Duration) time.Duration\n```\n\nroundDurationUp rounds d to the next multiple of to. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#selfConnect",
              "documentation": {
                "identifier": "selfConnect",
                "newPage": false,
                "searchKey": "net.selfConnect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func selfConnect(fd *netFD, err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc selfConnect(fd *netFD, err error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#spuriousENOTAVAIL",
              "documentation": {
                "identifier": "spuriousENOTAVAIL",
                "newPage": false,
                "searchKey": "net.spuriousENOTAVAIL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func spuriousENOTAVAIL(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc spuriousENOTAVAIL(err error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setKeepAlivePeriod",
              "documentation": {
                "identifier": "setKeepAlivePeriod",
                "newPage": false,
                "searchKey": "net.setKeepAlivePeriod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setKeepAlivePeriod(fd *netFD, d time.Duration) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setKeepAlivePeriod(fd *netFD, d time.Duration) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setNoDelay",
              "documentation": {
                "identifier": "setNoDelay",
                "newPage": false,
                "searchKey": "net.setNoDelay",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setNoDelay(fd *netFD, noDelay bool) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setNoDelay(fd *netFD, noDelay bool) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#listenIPv4MulticastUDP",
              "documentation": {
                "identifier": "listenIPv4MulticastUDP",
                "newPage": false,
                "searchKey": "net.listenIPv4MulticastUDP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func listenIPv4MulticastUDP(c *UDPConn, ifi *Interface, ip IP) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc listenIPv4MulticastUDP(c *UDPConn, ifi *Interface, ip IP) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#listenIPv6MulticastUDP",
              "documentation": {
                "identifier": "listenIPv6MulticastUDP",
                "newPage": false,
                "searchKey": "net.listenIPv6MulticastUDP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func listenIPv6MulticastUDP(c *UDPConn, ifi *Interface, ip IP) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc listenIPv6MulticastUDP(c *UDPConn, ifi *Interface, ip IP) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#sotypeToNet",
              "documentation": {
                "identifier": "sotypeToNet",
                "newPage": false,
                "searchKey": "net.sotypeToNet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sotypeToNet(sotype int) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sotypeToNet(sotype int) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setReadMsgCloseOnExec",
              "documentation": {
                "identifier": "setReadMsgCloseOnExec",
                "newPage": false,
                "searchKey": "net.setReadMsgCloseOnExec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setReadMsgCloseOnExec(oob []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setReadMsgCloseOnExec(oob []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSortByRFC6724",
              "documentation": {
                "identifier": "TestSortByRFC6724",
                "newPage": false,
                "searchKey": "net.TestSortByRFC6724",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSortByRFC6724(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSortByRFC6724(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestRFC6724PolicyTableClassify",
              "documentation": {
                "identifier": "TestRFC6724PolicyTableClassify",
                "newPage": false,
                "searchKey": "net.TestRFC6724PolicyTableClassify",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRFC6724PolicyTableClassify(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRFC6724PolicyTableClassify(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestRFC6724ClassifyScope",
              "documentation": {
                "identifier": "TestRFC6724ClassifyScope",
                "newPage": false,
                "searchKey": "net.TestRFC6724ClassifyScope",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRFC6724ClassifyScope(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRFC6724ClassifyScope(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestRFC6724CommonPrefixLength",
              "documentation": {
                "identifier": "TestRFC6724CommonPrefixLength",
                "newPage": false,
                "searchKey": "net.TestRFC6724CommonPrefixLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRFC6724CommonPrefixLength(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRFC6724CommonPrefixLength(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCgoLookupIP",
              "documentation": {
                "identifier": "TestCgoLookupIP",
                "newPage": false,
                "searchKey": "net.TestCgoLookupIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCgoLookupIP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCgoLookupIP(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCgoLookupIPWithCancel",
              "documentation": {
                "identifier": "TestCgoLookupIPWithCancel",
                "newPage": false,
                "searchKey": "net.TestCgoLookupIPWithCancel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCgoLookupIPWithCancel(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCgoLookupIPWithCancel(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCgoLookupPort",
              "documentation": {
                "identifier": "TestCgoLookupPort",
                "newPage": false,
                "searchKey": "net.TestCgoLookupPort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCgoLookupPort(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCgoLookupPort(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCgoLookupPortWithCancel",
              "documentation": {
                "identifier": "TestCgoLookupPortWithCancel",
                "newPage": false,
                "searchKey": "net.TestCgoLookupPortWithCancel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCgoLookupPortWithCancel(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCgoLookupPortWithCancel(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCgoLookupPTR",
              "documentation": {
                "identifier": "TestCgoLookupPTR",
                "newPage": false,
                "searchKey": "net.TestCgoLookupPTR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCgoLookupPTR(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCgoLookupPTR(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCgoLookupPTRWithCancel",
              "documentation": {
                "identifier": "TestCgoLookupPTRWithCancel",
                "newPage": false,
                "searchKey": "net.TestCgoLookupPTRWithCancel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCgoLookupPTRWithCancel(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCgoLookupPTRWithCancel(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestConfHostLookupOrder",
              "documentation": {
                "identifier": "TestConfHostLookupOrder",
                "newPage": false,
                "searchKey": "net.TestConfHostLookupOrder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConfHostLookupOrder(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConfHostLookupOrder(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSystemConf",
              "documentation": {
                "identifier": "TestSystemConf",
                "newPage": false,
                "searchKey": "net.TestSystemConf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSystemConf(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSystemConf(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestConnAndListener",
              "documentation": {
                "identifier": "TestConnAndListener",
                "newPage": false,
                "searchKey": "net.TestConnAndListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConnAndListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConnAndListener(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestProhibitionaryDialArg",
              "documentation": {
                "identifier": "TestProhibitionaryDialArg",
                "newPage": false,
                "searchKey": "net.TestProhibitionaryDialArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestProhibitionaryDialArg(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestProhibitionaryDialArg(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialLocal",
              "documentation": {
                "identifier": "TestDialLocal",
                "newPage": false,
                "searchKey": "net.TestDialLocal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialLocal(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialLocal(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialerDualStackFDLeak",
              "documentation": {
                "identifier": "TestDialerDualStackFDLeak",
                "newPage": false,
                "searchKey": "net.TestDialerDualStackFDLeak",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialerDualStackFDLeak(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialerDualStackFDLeak(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#dialClosedPort",
              "documentation": {
                "identifier": "dialClosedPort",
                "newPage": false,
                "searchKey": "net.dialClosedPort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dialClosedPort(t *testing.T) (actual, expected time.Duration)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dialClosedPort(t *testing.T) (actual, expected time.Duration)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialParallel",
              "documentation": {
                "identifier": "TestDialParallel",
                "newPage": false,
                "searchKey": "net.TestDialParallel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialParallel(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialParallel(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupSlowFast",
              "documentation": {
                "identifier": "lookupSlowFast",
                "newPage": false,
                "searchKey": "net.lookupSlowFast",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookupSlowFast(ctx context.Context, fn func(context.Context, string, string) ([]IPAddr, error), network, host string) ([]IPAddr, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookupSlowFast(ctx context.Context, fn func(context.Context, string, string) ([]IPAddr, error), network, host string) ([]IPAddr, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialerFallbackDelay",
              "documentation": {
                "identifier": "TestDialerFallbackDelay",
                "newPage": false,
                "searchKey": "net.TestDialerFallbackDelay",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialerFallbackDelay(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialerFallbackDelay(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialParallelSpuriousConnection",
              "documentation": {
                "identifier": "TestDialParallelSpuriousConnection",
                "newPage": false,
                "searchKey": "net.TestDialParallelSpuriousConnection",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialParallelSpuriousConnection(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialParallelSpuriousConnection(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialerPartialDeadline",
              "documentation": {
                "identifier": "TestDialerPartialDeadline",
                "newPage": false,
                "searchKey": "net.TestDialerPartialDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialerPartialDeadline(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialerPartialDeadline(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialerLocalAddr",
              "documentation": {
                "identifier": "TestDialerLocalAddr",
                "newPage": false,
                "searchKey": "net.TestDialerLocalAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialerLocalAddr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialerLocalAddr(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialerDualStack",
              "documentation": {
                "identifier": "TestDialerDualStack",
                "newPage": false,
                "searchKey": "net.TestDialerDualStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialerDualStack(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialerDualStack(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialerKeepAlive",
              "documentation": {
                "identifier": "TestDialerKeepAlive",
                "newPage": false,
                "searchKey": "net.TestDialerKeepAlive",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialerKeepAlive(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialerKeepAlive(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialCancel",
              "documentation": {
                "identifier": "TestDialCancel",
                "newPage": false,
                "searchKey": "net.TestDialCancel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialCancel(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialCancel(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCancelAfterDial",
              "documentation": {
                "identifier": "TestCancelAfterDial",
                "newPage": false,
                "searchKey": "net.TestCancelAfterDial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCancelAfterDial(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCancelAfterDial(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialListenerAddr",
              "documentation": {
                "identifier": "TestDialListenerAddr",
                "newPage": false,
                "searchKey": "net.TestDialListenerAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialListenerAddr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialListenerAddr(t *testing.T)\n```\n\nIssue 18806: it should always be possible to net.Dial a net.Listener().Addr().String when the listen address was \":n\", even if the machine has halfway configured IPv6 such that it can bind on \"::\" not connect back to that same address. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialerControl",
              "documentation": {
                "identifier": "TestDialerControl",
                "newPage": false,
                "searchKey": "net.TestDialerControl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialerControl(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialerControl(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#mustHaveExternalNetwork",
              "documentation": {
                "identifier": "mustHaveExternalNetwork",
                "newPage": false,
                "searchKey": "net.mustHaveExternalNetwork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mustHaveExternalNetwork(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mustHaveExternalNetwork(t *testing.T)\n```\n\nmustHaveExternalNetwork is like testenv.MustHaveExternalNetwork except that it won't skip testing on non-mobile builders. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialWithNonZeroDeadline",
              "documentation": {
                "identifier": "TestDialWithNonZeroDeadline",
                "newPage": false,
                "searchKey": "net.TestDialWithNonZeroDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialWithNonZeroDeadline(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialWithNonZeroDeadline(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialContextCancelRace",
              "documentation": {
                "identifier": "TestDialContextCancelRace",
                "newPage": false,
                "searchKey": "net.TestDialContextCancelRace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialContextCancelRace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialContextCancelRace(t *testing.T)\n```\n\nIssue 16523 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkDistribution",
              "documentation": {
                "identifier": "checkDistribution",
                "newPage": false,
                "searchKey": "net.checkDistribution",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkDistribution(t *testing.T, data []*SRV, margin float64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkDistribution(t *testing.T, data []*SRV, margin float64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testUniformity",
              "documentation": {
                "identifier": "testUniformity",
                "newPage": false,
                "searchKey": "net.testUniformity",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testUniformity(t *testing.T, size int, margin float64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testUniformity(t *testing.T, size int, margin float64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSSRVUniformity",
              "documentation": {
                "identifier": "TestDNSSRVUniformity",
                "newPage": false,
                "searchKey": "net.TestDNSSRVUniformity",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSSRVUniformity(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSSRVUniformity(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testWeighting",
              "documentation": {
                "identifier": "testWeighting",
                "newPage": false,
                "searchKey": "net.testWeighting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testWeighting(t *testing.T, margin float64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testWeighting(t *testing.T, margin float64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestWeighting",
              "documentation": {
                "identifier": "TestWeighting",
                "newPage": false,
                "searchKey": "net.TestWeighting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWeighting(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWeighting(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#mustNewName",
              "documentation": {
                "identifier": "mustNewName",
                "newPage": false,
                "searchKey": "net.mustNewName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mustNewName(name string) dnsmessage.Name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mustNewName(name string) dnsmessage.Name\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#mustQuestion",
              "documentation": {
                "identifier": "mustQuestion",
                "newPage": false,
                "searchKey": "net.mustQuestion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mustQuestion(name string, qtype dnsmessage.Type, class dnsmessage.Class) dnsmessage.Question"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mustQuestion(name string, qtype dnsmessage.Type, class dnsmessage.Class) dnsmessage.Question\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSTransportFallback",
              "documentation": {
                "identifier": "TestDNSTransportFallback",
                "newPage": false,
                "searchKey": "net.TestDNSTransportFallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSTransportFallback(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSTransportFallback(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSpecialDomainName",
              "documentation": {
                "identifier": "TestSpecialDomainName",
                "newPage": false,
                "searchKey": "net.TestSpecialDomainName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSpecialDomainName(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSpecialDomainName(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAvoidDNSName",
              "documentation": {
                "identifier": "TestAvoidDNSName",
                "newPage": false,
                "searchKey": "net.TestAvoidDNSName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAvoidDNSName(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAvoidDNSName(t *testing.T)\n```\n\nIssue 13705: don't try to resolve onion addresses, etc \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupTorOnion",
              "documentation": {
                "identifier": "TestLookupTorOnion",
                "newPage": false,
                "searchKey": "net.TestLookupTorOnion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupTorOnion(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupTorOnion(t *testing.T)\n```\n\nIssue 13705: don't try to resolve onion addresses, etc \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUpdateResolvConf",
              "documentation": {
                "identifier": "TestUpdateResolvConf",
                "newPage": false,
                "searchKey": "net.TestUpdateResolvConf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUpdateResolvConf(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUpdateResolvConf(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestGoLookupIPWithResolverConfig",
              "documentation": {
                "identifier": "TestGoLookupIPWithResolverConfig",
                "newPage": false,
                "searchKey": "net.TestGoLookupIPWithResolverConfig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGoLookupIPWithResolverConfig(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGoLookupIPWithResolverConfig(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestGoLookupIPOrderFallbackToFile",
              "documentation": {
                "identifier": "TestGoLookupIPOrderFallbackToFile",
                "newPage": false,
                "searchKey": "net.TestGoLookupIPOrderFallbackToFile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGoLookupIPOrderFallbackToFile(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGoLookupIPOrderFallbackToFile(t *testing.T)\n```\n\nTest that goLookupIPOrder falls back to the host file when no DNS servers are available. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestErrorForOriginalNameWhenSearching",
              "documentation": {
                "identifier": "TestErrorForOriginalNameWhenSearching",
                "newPage": false,
                "searchKey": "net.TestErrorForOriginalNameWhenSearching",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestErrorForOriginalNameWhenSearching(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestErrorForOriginalNameWhenSearching(t *testing.T)\n```\n\nIssue 12712. When using search domains, return the error encountered querying the original name instead of an error encountered querying a generated name. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIgnoreLameReferrals",
              "documentation": {
                "identifier": "TestIgnoreLameReferrals",
                "newPage": false,
                "searchKey": "net.TestIgnoreLameReferrals",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIgnoreLameReferrals(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIgnoreLameReferrals(t *testing.T)\n```\n\nIssue 15434. If a name server gives a lame referral, continue to the next. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkGoLookupIP",
              "documentation": {
                "identifier": "BenchmarkGoLookupIP",
                "newPage": false,
                "searchKey": "net.BenchmarkGoLookupIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGoLookupIP(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGoLookupIP(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkGoLookupIPNoSuchHost",
              "documentation": {
                "identifier": "BenchmarkGoLookupIPNoSuchHost",
                "newPage": false,
                "searchKey": "net.BenchmarkGoLookupIPNoSuchHost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGoLookupIPNoSuchHost(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGoLookupIPNoSuchHost(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkGoLookupIPWithBrokenNameServer",
              "documentation": {
                "identifier": "BenchmarkGoLookupIPWithBrokenNameServer",
                "newPage": false,
                "searchKey": "net.BenchmarkGoLookupIPWithBrokenNameServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGoLookupIPWithBrokenNameServer(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGoLookupIPWithBrokenNameServer(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIgnoreDNSForgeries",
              "documentation": {
                "identifier": "TestIgnoreDNSForgeries",
                "newPage": false,
                "searchKey": "net.TestIgnoreDNSForgeries",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIgnoreDNSForgeries(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIgnoreDNSForgeries(t *testing.T)\n```\n\nUDP round-tripper algorithm should ignore invalid DNS responses (issue 13281). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestRetryTimeout",
              "documentation": {
                "identifier": "TestRetryTimeout",
                "newPage": false,
                "searchKey": "net.TestRetryTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRetryTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRetryTimeout(t *testing.T)\n```\n\nIssue 16865. If a name server times out, continue to the next. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestRotate",
              "documentation": {
                "identifier": "TestRotate",
                "newPage": false,
                "searchKey": "net.TestRotate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRotate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRotate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testRotate",
              "documentation": {
                "identifier": "testRotate",
                "newPage": false,
                "searchKey": "net.testRotate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testRotate(t *testing.T, rotate bool, nameservers, wantServers []string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testRotate(t *testing.T, rotate bool, nameservers, wantServers []string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#mockTXTResponse",
              "documentation": {
                "identifier": "mockTXTResponse",
                "newPage": false,
                "searchKey": "net.mockTXTResponse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mockTXTResponse(q dnsmessage.Message) dnsmessage.Message"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mockTXTResponse(q dnsmessage.Message) dnsmessage.Message\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestStrictErrorsLookupIP",
              "documentation": {
                "identifier": "TestStrictErrorsLookupIP",
                "newPage": false,
                "searchKey": "net.TestStrictErrorsLookupIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestStrictErrorsLookupIP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestStrictErrorsLookupIP(t *testing.T)\n```\n\nIssue 17448. With StrictErrors enabled, temporary errors should make LookupIP fail rather than return a partial result. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestStrictErrorsLookupTXT",
              "documentation": {
                "identifier": "TestStrictErrorsLookupTXT",
                "newPage": false,
                "searchKey": "net.TestStrictErrorsLookupTXT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestStrictErrorsLookupTXT(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestStrictErrorsLookupTXT(t *testing.T)\n```\n\nIssue 17448. With StrictErrors enabled, temporary errors should make LookupTXT stop walking the search list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSGoroutineRace",
              "documentation": {
                "identifier": "TestDNSGoroutineRace",
                "newPage": false,
                "searchKey": "net.TestDNSGoroutineRace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSGoroutineRace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSGoroutineRace(t *testing.T)\n```\n\nTest for a race between uninstalling the test hooks and closing a socket connection. This used to fail when testing with -race. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupWithFake",
              "documentation": {
                "identifier": "lookupWithFake",
                "newPage": false,
                "searchKey": "net.lookupWithFake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookupWithFake(fake fakeDNSServer, name string, typ dnsmessage.Type) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookupWithFake(fake fakeDNSServer, name string, typ dnsmessage.Type) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIssue8434",
              "documentation": {
                "identifier": "TestIssue8434",
                "newPage": false,
                "searchKey": "net.TestIssue8434",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue8434(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue8434(t *testing.T)\n```\n\nIssue 8434: verify that Temporary returns true on an error when rcode is SERVFAIL \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIssueNoSuchHostExists",
              "documentation": {
                "identifier": "TestIssueNoSuchHostExists",
                "newPage": false,
                "searchKey": "net.TestIssueNoSuchHostExists",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssueNoSuchHostExists(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssueNoSuchHostExists(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestNoSuchHost",
              "documentation": {
                "identifier": "TestNoSuchHost",
                "newPage": false,
                "searchKey": "net.TestNoSuchHost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNoSuchHost(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNoSuchHost(t *testing.T)\n```\n\nTestNoSuchHost verifies that tryOneName works correctly when the domain does not exist. \n\nIssue 12778: verify that NXDOMAIN without RA bit errors as \"no such host\" and not \"server misbehaving\" \n\nIssue 25336: verify that NXDOMAIN errors fail fast. \n\nIssue 27525: verify that empty answers fail fast. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSDialTCP",
              "documentation": {
                "identifier": "TestDNSDialTCP",
                "newPage": false,
                "searchKey": "net.TestDNSDialTCP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSDialTCP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSDialTCP(t *testing.T)\n```\n\nIssue 26573: verify that Conns that don't implement PacketConn are treated as streams even when udp was requested. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTXTRecordTwoStrings",
              "documentation": {
                "identifier": "TestTXTRecordTwoStrings",
                "newPage": false,
                "searchKey": "net.TestTXTRecordTwoStrings",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTXTRecordTwoStrings(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTXTRecordTwoStrings(t *testing.T)\n```\n\nIssue 27763: verify that two strings in one TXT record are concatenated. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSingleRequestLookup",
              "documentation": {
                "identifier": "TestSingleRequestLookup",
                "newPage": false,
                "searchKey": "net.TestSingleRequestLookup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSingleRequestLookup(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSingleRequestLookup(t *testing.T)\n```\n\nIssue 29644: support single-request resolv.conf option in pure Go resolver. The A and AAAA queries will be sent sequentially, not in parallel. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSUseTCP",
              "documentation": {
                "identifier": "TestDNSUseTCP",
                "newPage": false,
                "searchKey": "net.TestDNSUseTCP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSUseTCP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSUseTCP(t *testing.T)\n```\n\nIssue 29358. Add configuration knob to force TCP-only DNS requests in the pure Go resolver. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestPTRandNonPTR",
              "documentation": {
                "identifier": "TestPTRandNonPTR",
                "newPage": false,
                "searchKey": "net.TestPTRandNonPTR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPTRandNonPTR(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPTRandNonPTR(t *testing.T)\n```\n\nIssue 34660: PTR response with non-PTR answers should ignore non-PTR \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCVE202133195",
              "documentation": {
                "identifier": "TestCVE202133195",
                "newPage": false,
                "searchKey": "net.TestCVE202133195",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCVE202133195(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCVE202133195(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSReadConfig",
              "documentation": {
                "identifier": "TestDNSReadConfig",
                "newPage": false,
                "searchKey": "net.TestDNSReadConfig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSReadConfig(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSReadConfig(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSReadMissingFile",
              "documentation": {
                "identifier": "TestDNSReadMissingFile",
                "newPage": false,
                "searchKey": "net.TestDNSReadMissingFile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSReadMissingFile(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSReadMissingFile(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSDefaultSearch",
              "documentation": {
                "identifier": "TestDNSDefaultSearch",
                "newPage": false,
                "searchKey": "net.TestDNSDefaultSearch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSDefaultSearch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSDefaultSearch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSNameLength",
              "documentation": {
                "identifier": "TestDNSNameLength",
                "newPage": false,
                "searchKey": "net.TestDNSNameLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSNameLength(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSNameLength(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#emitDNSNameTest",
              "documentation": {
                "identifier": "emitDNSNameTest",
                "newPage": false,
                "searchKey": "net.emitDNSNameTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func emitDNSNameTest(ch chan<- dnsNameTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc emitDNSNameTest(ch chan<- dnsNameTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSName",
              "documentation": {
                "identifier": "TestDNSName",
                "newPage": false,
                "searchKey": "net.TestDNSName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSName(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSName(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkDNSName",
              "documentation": {
                "identifier": "BenchmarkDNSName",
                "newPage": false,
                "searchKey": "net.BenchmarkDNSName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkDNSName(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkDNSName(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSpuriousENOTAVAIL",
              "documentation": {
                "identifier": "TestSpuriousENOTAVAIL",
                "newPage": false,
                "searchKey": "net.TestSpuriousENOTAVAIL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSpuriousENOTAVAIL(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSpuriousENOTAVAIL(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseDialError",
              "documentation": {
                "identifier": "parseDialError",
                "newPage": false,
                "searchKey": "net.parseDialError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseDialError(nestedErr error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseDialError(nestedErr error) error\n```\n\nparseDialError parses nestedErr and reports whether it is a valid error value from Dial, Listen functions. It returns nil when nestedErr is valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialError",
              "documentation": {
                "identifier": "TestDialError",
                "newPage": false,
                "searchKey": "net.TestDialError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestProtocolDialError",
              "documentation": {
                "identifier": "TestProtocolDialError",
                "newPage": false,
                "searchKey": "net.TestProtocolDialError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestProtocolDialError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestProtocolDialError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialAddrError",
              "documentation": {
                "identifier": "TestDialAddrError",
                "newPage": false,
                "searchKey": "net.TestDialAddrError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialAddrError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialAddrError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestListenError",
              "documentation": {
                "identifier": "TestListenError",
                "newPage": false,
                "searchKey": "net.TestListenError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestListenError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestListenError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestListenPacketError",
              "documentation": {
                "identifier": "TestListenPacketError",
                "newPage": false,
                "searchKey": "net.TestListenPacketError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestListenPacketError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestListenPacketError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestProtocolListenError",
              "documentation": {
                "identifier": "TestProtocolListenError",
                "newPage": false,
                "searchKey": "net.TestProtocolListenError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestProtocolListenError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestProtocolListenError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseReadError",
              "documentation": {
                "identifier": "parseReadError",
                "newPage": false,
                "searchKey": "net.parseReadError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseReadError(nestedErr error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseReadError(nestedErr error) error\n```\n\nparseReadError parses nestedErr and reports whether it is a valid error value from Read functions. It returns nil when nestedErr is valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseWriteError",
              "documentation": {
                "identifier": "parseWriteError",
                "newPage": false,
                "searchKey": "net.parseWriteError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseWriteError(nestedErr error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseWriteError(nestedErr error) error\n```\n\nparseWriteError parses nestedErr and reports whether it is a valid error value from Write functions. It returns nil when nestedErr is valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseCloseError",
              "documentation": {
                "identifier": "parseCloseError",
                "newPage": false,
                "searchKey": "net.parseCloseError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseCloseError(nestedErr error, isShutdown bool) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseCloseError(nestedErr error, isShutdown bool) error\n```\n\nparseCloseError parses nestedErr and reports whether it is a valid error value from Close functions. It returns nil when nestedErr is valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCloseError",
              "documentation": {
                "identifier": "TestCloseError",
                "newPage": false,
                "searchKey": "net.TestCloseError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloseError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloseError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseAcceptError",
              "documentation": {
                "identifier": "parseAcceptError",
                "newPage": false,
                "searchKey": "net.parseAcceptError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseAcceptError(nestedErr error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseAcceptError(nestedErr error) error\n```\n\nparseAcceptError parses nestedErr and reports whether it is a valid error value from Accept functions. It returns nil when nestedErr is valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAcceptError",
              "documentation": {
                "identifier": "TestAcceptError",
                "newPage": false,
                "searchKey": "net.TestAcceptError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAcceptError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAcceptError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseCommonError",
              "documentation": {
                "identifier": "parseCommonError",
                "newPage": false,
                "searchKey": "net.parseCommonError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseCommonError(nestedErr error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseCommonError(nestedErr error) error\n```\n\nparseCommonError parses nestedErr and reports whether it is a valid error value from miscellaneous functions. It returns nil when nestedErr is valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestFileError",
              "documentation": {
                "identifier": "TestFileError",
                "newPage": false,
                "searchKey": "net.TestFileError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#parseLookupPortError",
              "documentation": {
                "identifier": "parseLookupPortError",
                "newPage": false,
                "searchKey": "net.parseLookupPortError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseLookupPortError(nestedErr error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseLookupPortError(nestedErr error) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isPlatformError",
              "documentation": {
                "identifier": "isPlatformError",
                "newPage": false,
                "searchKey": "net.isPlatformError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isPlatformError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isPlatformError(err error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#samePlatformError",
              "documentation": {
                "identifier": "samePlatformError",
                "newPage": false,
                "searchKey": "net.samePlatformError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func samePlatformError(err, want error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc samePlatformError(err, want error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestResolveGoogle",
              "documentation": {
                "identifier": "TestResolveGoogle",
                "newPage": false,
                "searchKey": "net.TestResolveGoogle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResolveGoogle(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResolveGoogle(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialGoogle",
              "documentation": {
                "identifier": "TestDialGoogle",
                "newPage": false,
                "searchKey": "net.TestDialGoogle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialGoogle(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialGoogle(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#googleLiteralAddrs",
              "documentation": {
                "identifier": "googleLiteralAddrs",
                "newPage": false,
                "searchKey": "net.googleLiteralAddrs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func googleLiteralAddrs() (lits4, lits6 []string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc googleLiteralAddrs() (lits4, lits6 []string, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#fetchGoogle",
              "documentation": {
                "identifier": "fetchGoogle",
                "newPage": false,
                "searchKey": "net.fetchGoogle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fetchGoogle(dial func(string, string) (Conn, error), network, address string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fetchGoogle(dial func(string, string) (Conn, error), network, address string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#fcntl",
              "documentation": {
                "identifier": "fcntl",
                "newPage": false,
                "searchKey": "net.fcntl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fcntl(fd int, cmd int, arg int) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fcntl(fd int, cmd int, arg int) (int, error)\n```\n\nImplemented in the syscall package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestFileConn",
              "documentation": {
                "identifier": "TestFileConn",
                "newPage": false,
                "searchKey": "net.TestFileConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileConn(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileConn(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestFileListener",
              "documentation": {
                "identifier": "TestFileListener",
                "newPage": false,
                "searchKey": "net.TestFileListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileListener(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestFilePacketConn",
              "documentation": {
                "identifier": "TestFilePacketConn",
                "newPage": false,
                "searchKey": "net.TestFilePacketConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFilePacketConn(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFilePacketConn(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestFileCloseRace",
              "documentation": {
                "identifier": "TestFileCloseRace",
                "newPage": false,
                "searchKey": "net.TestFileCloseRace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileCloseRace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileCloseRace(t *testing.T)\n```\n\nIssue 24483. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupStaticHost",
              "documentation": {
                "identifier": "TestLookupStaticHost",
                "newPage": false,
                "searchKey": "net.TestLookupStaticHost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupStaticHost(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupStaticHost(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testStaticHost",
              "documentation": {
                "identifier": "testStaticHost",
                "newPage": false,
                "searchKey": "net.testStaticHost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testStaticHost(t *testing.T, hostsPath string, ent staticHostEntry)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testStaticHost(t *testing.T, hostsPath string, ent staticHostEntry)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupStaticAddr",
              "documentation": {
                "identifier": "TestLookupStaticAddr",
                "newPage": false,
                "searchKey": "net.TestLookupStaticAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupStaticAddr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupStaticAddr(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testStaticAddr",
              "documentation": {
                "identifier": "testStaticAddr",
                "newPage": false,
                "searchKey": "net.testStaticAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testStaticAddr(t *testing.T, hostsPath string, ent staticHostEntry)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testStaticAddr(t *testing.T, hostsPath string, ent staticHostEntry)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestHostCacheModification",
              "documentation": {
                "identifier": "TestHostCacheModification",
                "newPage": false,
                "searchKey": "net.TestHostCacheModification",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHostCacheModification(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHostCacheModification(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#ipv6LinkLocalUnicastAddr",
              "documentation": {
                "identifier": "ipv6LinkLocalUnicastAddr",
                "newPage": false,
                "searchKey": "net.ipv6LinkLocalUnicastAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ipv6LinkLocalUnicastAddr(ifi *Interface) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ipv6LinkLocalUnicastAddr(ifi *Interface) string\n```\n\nipv6LinkLocalUnicastAddr returns an IPv6 link-local unicast address on the given network interface for tests. It returns \"\" if no suitable address is found. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestInterfaces",
              "documentation": {
                "identifier": "TestInterfaces",
                "newPage": false,
                "searchKey": "net.TestInterfaces",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInterfaces(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInterfaces(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestInterfaceAddrs",
              "documentation": {
                "identifier": "TestInterfaceAddrs",
                "newPage": false,
                "searchKey": "net.TestInterfaceAddrs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInterfaceAddrs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInterfaceAddrs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestInterfaceUnicastAddrs",
              "documentation": {
                "identifier": "TestInterfaceUnicastAddrs",
                "newPage": false,
                "searchKey": "net.TestInterfaceUnicastAddrs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInterfaceUnicastAddrs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInterfaceUnicastAddrs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestInterfaceMulticastAddrs",
              "documentation": {
                "identifier": "TestInterfaceMulticastAddrs",
                "newPage": false,
                "searchKey": "net.TestInterfaceMulticastAddrs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInterfaceMulticastAddrs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInterfaceMulticastAddrs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkUnicastStats",
              "documentation": {
                "identifier": "checkUnicastStats",
                "newPage": false,
                "searchKey": "net.checkUnicastStats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkUnicastStats(ifStats *ifStats, uniStats *routeStats) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkUnicastStats(ifStats *ifStats, uniStats *routeStats) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkMulticastStats",
              "documentation": {
                "identifier": "checkMulticastStats",
                "newPage": false,
                "searchKey": "net.checkMulticastStats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkMulticastStats(ifStats *ifStats, uniStats, multiStats *routeStats) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkMulticastStats(ifStats *ifStats, uniStats, multiStats *routeStats) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkInterfaces",
              "documentation": {
                "identifier": "BenchmarkInterfaces",
                "newPage": false,
                "searchKey": "net.BenchmarkInterfaces",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkInterfaces(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkInterfaces(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkInterfaceByIndex",
              "documentation": {
                "identifier": "BenchmarkInterfaceByIndex",
                "newPage": false,
                "searchKey": "net.BenchmarkInterfaceByIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkInterfaceByIndex(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkInterfaceByIndex(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkInterfaceByName",
              "documentation": {
                "identifier": "BenchmarkInterfaceByName",
                "newPage": false,
                "searchKey": "net.BenchmarkInterfaceByName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkInterfaceByName(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkInterfaceByName(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkInterfaceAddrs",
              "documentation": {
                "identifier": "BenchmarkInterfaceAddrs",
                "newPage": false,
                "searchKey": "net.BenchmarkInterfaceAddrs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkInterfaceAddrs(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkInterfaceAddrs(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkInterfacesAndAddrs",
              "documentation": {
                "identifier": "BenchmarkInterfacesAndAddrs",
                "newPage": false,
                "searchKey": "net.BenchmarkInterfacesAndAddrs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkInterfacesAndAddrs(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkInterfacesAndAddrs(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkInterfacesAndMulticastAddrs",
              "documentation": {
                "identifier": "BenchmarkInterfacesAndMulticastAddrs",
                "newPage": false,
                "searchKey": "net.BenchmarkInterfacesAndMulticastAddrs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkInterfacesAndMulticastAddrs(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkInterfacesAndMulticastAddrs(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestPointToPointInterface",
              "documentation": {
                "identifier": "TestPointToPointInterface",
                "newPage": false,
                "searchKey": "net.TestPointToPointInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPointToPointInterface(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPointToPointInterface(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestInterfaceArrivalAndDeparture",
              "documentation": {
                "identifier": "TestInterfaceArrivalAndDeparture",
                "newPage": false,
                "searchKey": "net.TestInterfaceArrivalAndDeparture",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInterfaceArrivalAndDeparture(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInterfaceArrivalAndDeparture(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestInterfaceArrivalAndDepartureZoneCache",
              "documentation": {
                "identifier": "TestInterfaceArrivalAndDepartureZoneCache",
                "newPage": false,
                "searchKey": "net.TestInterfaceArrivalAndDepartureZoneCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInterfaceArrivalAndDepartureZoneCache(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInterfaceArrivalAndDepartureZoneCache(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestParseIP",
              "documentation": {
                "identifier": "TestParseIP",
                "newPage": false,
                "searchKey": "net.TestParseIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseIP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseIP(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupWithIP",
              "documentation": {
                "identifier": "TestLookupWithIP",
                "newPage": false,
                "searchKey": "net.TestLookupWithIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupWithIP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupWithIP(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkParseIP",
              "documentation": {
                "identifier": "BenchmarkParseIP",
                "newPage": false,
                "searchKey": "net.BenchmarkParseIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkParseIP(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkParseIP(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestMarshalEmptyIP",
              "documentation": {
                "identifier": "TestMarshalEmptyIP",
                "newPage": false,
                "searchKey": "net.TestMarshalEmptyIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMarshalEmptyIP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMarshalEmptyIP(t *testing.T)\n```\n\nIssue 6339 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPString",
              "documentation": {
                "identifier": "TestIPString",
                "newPage": false,
                "searchKey": "net.TestIPString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkIPString",
              "documentation": {
                "identifier": "BenchmarkIPString",
                "newPage": false,
                "searchKey": "net.BenchmarkIPString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkIPString(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkIPString(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#benchmarkIPString",
              "documentation": {
                "identifier": "benchmarkIPString",
                "newPage": false,
                "searchKey": "net.benchmarkIPString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkIPString(b *testing.B, size int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkIPString(b *testing.B, size int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPMask",
              "documentation": {
                "identifier": "TestIPMask",
                "newPage": false,
                "searchKey": "net.TestIPMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPMask(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPMask(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPMaskString",
              "documentation": {
                "identifier": "TestIPMaskString",
                "newPage": false,
                "searchKey": "net.TestIPMaskString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPMaskString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPMaskString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkIPMaskString",
              "documentation": {
                "identifier": "BenchmarkIPMaskString",
                "newPage": false,
                "searchKey": "net.BenchmarkIPMaskString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkIPMaskString(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkIPMaskString(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestParseCIDR",
              "documentation": {
                "identifier": "TestParseCIDR",
                "newPage": false,
                "searchKey": "net.TestParseCIDR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseCIDR(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseCIDR(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPNetContains",
              "documentation": {
                "identifier": "TestIPNetContains",
                "newPage": false,
                "searchKey": "net.TestIPNetContains",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPNetContains(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPNetContains(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPNetString",
              "documentation": {
                "identifier": "TestIPNetString",
                "newPage": false,
                "searchKey": "net.TestIPNetString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPNetString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPNetString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCIDRMask",
              "documentation": {
                "identifier": "TestCIDRMask",
                "newPage": false,
                "searchKey": "net.TestCIDRMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCIDRMask(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCIDRMask(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestNetworkNumberAndMask",
              "documentation": {
                "identifier": "TestNetworkNumberAndMask",
                "newPage": false,
                "searchKey": "net.TestNetworkNumberAndMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNetworkNumberAndMask(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNetworkNumberAndMask(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSplitHostPort",
              "documentation": {
                "identifier": "TestSplitHostPort",
                "newPage": false,
                "searchKey": "net.TestSplitHostPort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSplitHostPort(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSplitHostPort(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestJoinHostPort",
              "documentation": {
                "identifier": "TestJoinHostPort",
                "newPage": false,
                "searchKey": "net.TestJoinHostPort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestJoinHostPort(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestJoinHostPort(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPAddrFamily",
              "documentation": {
                "identifier": "TestIPAddrFamily",
                "newPage": false,
                "searchKey": "net.TestIPAddrFamily",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPAddrFamily(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPAddrFamily(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#name",
              "documentation": {
                "identifier": "name",
                "newPage": false,
                "searchKey": "net.name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func name(f interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc name(f interface{}) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPAddrScope",
              "documentation": {
                "identifier": "TestIPAddrScope",
                "newPage": false,
                "searchKey": "net.TestIPAddrScope",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPAddrScope(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPAddrScope(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkIPEqual",
              "documentation": {
                "identifier": "BenchmarkIPEqual",
                "newPage": false,
                "searchKey": "net.BenchmarkIPEqual",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkIPEqual(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkIPEqual(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#benchmarkIPEqual",
              "documentation": {
                "identifier": "benchmarkIPEqual",
                "newPage": false,
                "searchKey": "net.benchmarkIPEqual",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkIPEqual(b *testing.B, size int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkIPEqual(b *testing.B, size int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestResolveIPAddr",
              "documentation": {
                "identifier": "TestResolveIPAddr",
                "newPage": false,
                "searchKey": "net.TestResolveIPAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResolveIPAddr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResolveIPAddr(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPConnLocalName",
              "documentation": {
                "identifier": "TestIPConnLocalName",
                "newPage": false,
                "searchKey": "net.TestIPConnLocalName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPConnLocalName(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPConnLocalName(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPConnRemoteName",
              "documentation": {
                "identifier": "TestIPConnRemoteName",
                "newPage": false,
                "searchKey": "net.TestIPConnRemoteName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPConnRemoteName(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPConnRemoteName(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialListenIPArgs",
              "documentation": {
                "identifier": "TestDialListenIPArgs",
                "newPage": false,
                "searchKey": "net.TestDialListenIPArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialListenIPArgs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialListenIPArgs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAddrList",
              "documentation": {
                "identifier": "TestAddrList",
                "newPage": false,
                "searchKey": "net.TestAddrList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAddrList(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAddrList(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAddrListPartition",
              "documentation": {
                "identifier": "TestAddrListPartition",
                "newPage": false,
                "searchKey": "net.TestAddrListPartition",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAddrListPartition(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAddrListPartition(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPListener",
              "documentation": {
                "identifier": "TestTCPListener",
                "newPage": false,
                "searchKey": "net.TestTCPListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPListener(t *testing.T)\n```\n\nTestTCPListener tests both single and double listen to a test listener with same address family, same listening address and same port. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUDPListener",
              "documentation": {
                "identifier": "TestUDPListener",
                "newPage": false,
                "searchKey": "net.TestUDPListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUDPListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUDPListener(t *testing.T)\n```\n\nTestUDPListener tests both single and double listen to a test listener with same address family, same listening address and same port. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDualStackTCPListener",
              "documentation": {
                "identifier": "TestDualStackTCPListener",
                "newPage": false,
                "searchKey": "net.TestDualStackTCPListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDualStackTCPListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDualStackTCPListener(t *testing.T)\n```\n\nTestDualStackTCPListener tests both single and double listen to a test listener with various address families, different listening address and same port. \n\nOn DragonFly BSD, we expect the kernel version of node under test to be greater than or equal to 4.4. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDualStackUDPListener",
              "documentation": {
                "identifier": "TestDualStackUDPListener",
                "newPage": false,
                "searchKey": "net.TestDualStackUDPListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDualStackUDPListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDualStackUDPListener(t *testing.T)\n```\n\nTestDualStackUDPListener tests both single and double listen to a test listener with various address families, different listening address and same port. \n\nOn DragonFly BSD, we expect the kernel version of node under test to be greater than or equal to 4.4. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#differentWildcardAddr",
              "documentation": {
                "identifier": "differentWildcardAddr",
                "newPage": false,
                "searchKey": "net.differentWildcardAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func differentWildcardAddr(i, j string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc differentWildcardAddr(i, j string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkFirstListener",
              "documentation": {
                "identifier": "checkFirstListener",
                "newPage": false,
                "searchKey": "net.checkFirstListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkFirstListener(network string, ln interface{}) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkFirstListener(network string, ln interface{}) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkSecondListener",
              "documentation": {
                "identifier": "checkSecondListener",
                "newPage": false,
                "searchKey": "net.checkSecondListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkSecondListener(network, address string, err error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkSecondListener(network, address string, err error) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkDualStackSecondListener",
              "documentation": {
                "identifier": "checkDualStackSecondListener",
                "newPage": false,
                "searchKey": "net.checkDualStackSecondListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkDualStackSecondListener(network, address string, err, xerr error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkDualStackSecondListener(network, address string, err, xerr error) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkDualStackAddrFamily",
              "documentation": {
                "identifier": "checkDualStackAddrFamily",
                "newPage": false,
                "searchKey": "net.checkDualStackAddrFamily",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkDualStackAddrFamily(fd *netFD) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkDualStackAddrFamily(fd *netFD) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestWildWildcardListener",
              "documentation": {
                "identifier": "TestWildWildcardListener",
                "newPage": false,
                "searchKey": "net.TestWildWildcardListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWildWildcardListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWildWildcardListener(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPv4MulticastListener",
              "documentation": {
                "identifier": "TestIPv4MulticastListener",
                "newPage": false,
                "searchKey": "net.TestIPv4MulticastListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPv4MulticastListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPv4MulticastListener(t *testing.T)\n```\n\nTestIPv4MulticastListener tests both single and double listen to a test listener with same address family, same group address and same port. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPv6MulticastListener",
              "documentation": {
                "identifier": "TestIPv6MulticastListener",
                "newPage": false,
                "searchKey": "net.TestIPv6MulticastListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPv6MulticastListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPv6MulticastListener(t *testing.T)\n```\n\nTestIPv6MulticastListener tests both single and double listen to a test listener with same address family, same group address and same port. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#checkMulticastListener",
              "documentation": {
                "identifier": "checkMulticastListener",
                "newPage": false,
                "searchKey": "net.checkMulticastListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkMulticastListener(c *UDPConn, ip IP) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkMulticastListener(c *UDPConn, ip IP) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#multicastRIBContains",
              "documentation": {
                "identifier": "multicastRIBContains",
                "newPage": false,
                "searchKey": "net.multicastRIBContains",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func multicastRIBContains(ip IP) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc multicastRIBContains(ip IP) (bool, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestClosingListener",
              "documentation": {
                "identifier": "TestClosingListener",
                "newPage": false,
                "searchKey": "net.TestClosingListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestClosingListener(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestClosingListener(t *testing.T)\n```\n\nIssue 21856. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestListenConfigControl",
              "documentation": {
                "identifier": "TestListenConfigControl",
                "newPage": false,
                "searchKey": "net.TestListenConfigControl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestListenConfigControl(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestListenConfigControl(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#hasSuffixFold",
              "documentation": {
                "identifier": "hasSuffixFold",
                "newPage": false,
                "searchKey": "net.hasSuffixFold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasSuffixFold(s, suffix string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasSuffixFold(s, suffix string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#lookupLocalhost",
              "documentation": {
                "identifier": "lookupLocalhost",
                "newPage": false,
                "searchKey": "net.lookupLocalhost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookupLocalhost(ctx context.Context, fn func(context.Context, string, string) ([]IPAddr, error), network, host string) ([]IPAddr, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookupLocalhost(ctx context.Context, fn func(context.Context, string, string) ([]IPAddr, error), network, host string) ([]IPAddr, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupGoogleSRV",
              "documentation": {
                "identifier": "TestLookupGoogleSRV",
                "newPage": false,
                "searchKey": "net.TestLookupGoogleSRV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupGoogleSRV(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupGoogleSRV(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupGmailMX",
              "documentation": {
                "identifier": "TestLookupGmailMX",
                "newPage": false,
                "searchKey": "net.TestLookupGmailMX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupGmailMX(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupGmailMX(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupGmailNS",
              "documentation": {
                "identifier": "TestLookupGmailNS",
                "newPage": false,
                "searchKey": "net.TestLookupGmailNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupGmailNS(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupGmailNS(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupGmailTXT",
              "documentation": {
                "identifier": "TestLookupGmailTXT",
                "newPage": false,
                "searchKey": "net.TestLookupGmailTXT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupGmailTXT(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupGmailTXT(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupGooglePublicDNSAddr",
              "documentation": {
                "identifier": "TestLookupGooglePublicDNSAddr",
                "newPage": false,
                "searchKey": "net.TestLookupGooglePublicDNSAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupGooglePublicDNSAddr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupGooglePublicDNSAddr(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupIPv6LinkLocalAddr",
              "documentation": {
                "identifier": "TestLookupIPv6LinkLocalAddr",
                "newPage": false,
                "searchKey": "net.TestLookupIPv6LinkLocalAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupIPv6LinkLocalAddr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupIPv6LinkLocalAddr(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupIPv6LinkLocalAddrWithZone",
              "documentation": {
                "identifier": "TestLookupIPv6LinkLocalAddrWithZone",
                "newPage": false,
                "searchKey": "net.TestLookupIPv6LinkLocalAddrWithZone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupIPv6LinkLocalAddrWithZone(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupIPv6LinkLocalAddrWithZone(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupCNAME",
              "documentation": {
                "identifier": "TestLookupCNAME",
                "newPage": false,
                "searchKey": "net.TestLookupCNAME",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupCNAME(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupCNAME(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupGoogleHost",
              "documentation": {
                "identifier": "TestLookupGoogleHost",
                "newPage": false,
                "searchKey": "net.TestLookupGoogleHost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupGoogleHost(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupGoogleHost(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupLongTXT",
              "documentation": {
                "identifier": "TestLookupLongTXT",
                "newPage": false,
                "searchKey": "net.TestLookupLongTXT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupLongTXT(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupLongTXT(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupGoogleIP",
              "documentation": {
                "identifier": "TestLookupGoogleIP",
                "newPage": false,
                "searchKey": "net.TestLookupGoogleIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupGoogleIP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupGoogleIP(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReverseAddress",
              "documentation": {
                "identifier": "TestReverseAddress",
                "newPage": false,
                "searchKey": "net.TestReverseAddress",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReverseAddress(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReverseAddress(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDNSFlood",
              "documentation": {
                "identifier": "TestDNSFlood",
                "newPage": false,
                "searchKey": "net.TestDNSFlood",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDNSFlood(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDNSFlood(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupDotsWithLocalSource",
              "documentation": {
                "identifier": "TestLookupDotsWithLocalSource",
                "newPage": false,
                "searchKey": "net.TestLookupDotsWithLocalSource",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupDotsWithLocalSource(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupDotsWithLocalSource(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupDotsWithRemoteSource",
              "documentation": {
                "identifier": "TestLookupDotsWithRemoteSource",
                "newPage": false,
                "searchKey": "net.TestLookupDotsWithRemoteSource",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupDotsWithRemoteSource(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupDotsWithRemoteSource(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testDots",
              "documentation": {
                "identifier": "testDots",
                "newPage": false,
                "searchKey": "net.testDots",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testDots(t *testing.T, mode string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testDots(t *testing.T, mode string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#mxString",
              "documentation": {
                "identifier": "mxString",
                "newPage": false,
                "searchKey": "net.mxString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mxString(mxs []*MX) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mxString(mxs []*MX) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#nsString",
              "documentation": {
                "identifier": "nsString",
                "newPage": false,
                "searchKey": "net.nsString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nsString(nss []*NS) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nsString(nss []*NS) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#srvString",
              "documentation": {
                "identifier": "srvString",
                "newPage": false,
                "searchKey": "net.srvString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func srvString(srvs []*SRV) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc srvString(srvs []*SRV) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupPort",
              "documentation": {
                "identifier": "TestLookupPort",
                "newPage": false,
                "searchKey": "net.TestLookupPort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupPort(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupPort(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupPort_Minimal",
              "documentation": {
                "identifier": "TestLookupPort_Minimal",
                "newPage": false,
                "searchKey": "net.TestLookupPort_Minimal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupPort_Minimal(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupPort_Minimal(t *testing.T)\n```\n\nLike TestLookupPort but with minimal tests that should always pass because the answers are baked-in to the net package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupProtocol_Minimal",
              "documentation": {
                "identifier": "TestLookupProtocol_Minimal",
                "newPage": false,
                "searchKey": "net.TestLookupProtocol_Minimal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupProtocol_Minimal(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupProtocol_Minimal(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupNonLDH",
              "documentation": {
                "identifier": "TestLookupNonLDH",
                "newPage": false,
                "searchKey": "net.TestLookupNonLDH",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupNonLDH(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupNonLDH(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupContextCancel",
              "documentation": {
                "identifier": "TestLookupContextCancel",
                "newPage": false,
                "searchKey": "net.TestLookupContextCancel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupContextCancel(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupContextCancel(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestNilResolverLookup",
              "documentation": {
                "identifier": "TestNilResolverLookup",
                "newPage": false,
                "searchKey": "net.TestNilResolverLookup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNilResolverLookup(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNilResolverLookup(t *testing.T)\n```\n\nIssue 24330: treat the nil *Resolver like a zero value. Verify nothing crashes if nil is used. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupHostCancel",
              "documentation": {
                "identifier": "TestLookupHostCancel",
                "newPage": false,
                "searchKey": "net.TestLookupHostCancel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupHostCancel(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupHostCancel(t *testing.T)\n```\n\nTestLookupHostCancel verifies that lookup works even after many canceled lookups (see golang.org/issue/24178 for details). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestConcurrentPreferGoResolversDial",
              "documentation": {
                "identifier": "TestConcurrentPreferGoResolversDial",
                "newPage": false,
                "searchKey": "net.TestConcurrentPreferGoResolversDial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConcurrentPreferGoResolversDial(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConcurrentPreferGoResolversDial(t *testing.T)\n```\n\nTestConcurrentPreferGoResolversDial tests that multiple resolvers with the PreferGo option used concurrently are all dialed properly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPVersion",
              "documentation": {
                "identifier": "TestIPVersion",
                "newPage": false,
                "searchKey": "net.TestIPVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPVersion(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPVersion(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupIPAddrPreservesContextValues",
              "documentation": {
                "identifier": "TestLookupIPAddrPreservesContextValues",
                "newPage": false,
                "searchKey": "net.TestLookupIPAddrPreservesContextValues",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupIPAddrPreservesContextValues(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupIPAddrPreservesContextValues(t *testing.T)\n```\n\nIssue 28600: The context that is used to lookup ips should always preserve the values from the context that was passed into LookupIPAddr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupIPAddrConcurrentCallsForNetworks",
              "documentation": {
                "identifier": "TestLookupIPAddrConcurrentCallsForNetworks",
                "newPage": false,
                "searchKey": "net.TestLookupIPAddrConcurrentCallsForNetworks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupIPAddrConcurrentCallsForNetworks(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupIPAddrConcurrentCallsForNetworks(t *testing.T)\n```\n\nIssue 30521: The lookup group should call the resolver for each network. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestWithUnexpiredValuesPreserved",
              "documentation": {
                "identifier": "TestWithUnexpiredValuesPreserved",
                "newPage": false,
                "searchKey": "net.TestWithUnexpiredValuesPreserved",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWithUnexpiredValuesPreserved(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWithUnexpiredValuesPreserved(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestLookupNullByte",
              "documentation": {
                "identifier": "TestLookupNullByte",
                "newPage": false,
                "searchKey": "net.TestLookupNullByte",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookupNullByte(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookupNullByte(t *testing.T)\n```\n\nIssue 31597: don't panic on null byte in name \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestResolverLookupIP",
              "documentation": {
                "identifier": "TestResolverLookupIP",
                "newPage": false,
                "searchKey": "net.TestResolverLookupIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResolverLookupIP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResolverLookupIP(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestParseMAC",
              "documentation": {
                "identifier": "TestParseMAC",
                "newPage": false,
                "searchKey": "net.TestParseMAC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseMAC(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseMAC(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#forceGoDNS",
              "documentation": {
                "identifier": "forceGoDNS",
                "newPage": false,
                "searchKey": "net.forceGoDNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func forceGoDNS() func()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc forceGoDNS() func()\n```\n\nforceGoDNS forces the resolver configuration to use the pure Go resolver and returns a fixup function to restore the old settings. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#forceCgoDNS",
              "documentation": {
                "identifier": "forceCgoDNS",
                "newPage": false,
                "searchKey": "net.forceCgoDNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func forceCgoDNS() func()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc forceCgoDNS() func()\n```\n\nforceCgoDNS forces the resolver configuration to use the cgo resolver and returns a fixup function to restore the old settings. (On non-Unix systems forceCgoDNS returns nil.) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#enableSocketConnect",
              "documentation": {
                "identifier": "enableSocketConnect",
                "newPage": false,
                "searchKey": "net.enableSocketConnect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func enableSocketConnect()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc enableSocketConnect()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#disableSocketConnect",
              "documentation": {
                "identifier": "disableSocketConnect",
                "newPage": false,
                "searchKey": "net.disableSocketConnect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func disableSocketConnect(network string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc disableSocketConnect(network string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestMain",
              "documentation": {
                "identifier": "TestMain",
                "newPage": false,
                "searchKey": "net.TestMain",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMain(m *testing.M)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMain(m *testing.M)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#setupTestData",
              "documentation": {
                "identifier": "setupTestData",
                "newPage": false,
                "searchKey": "net.setupTestData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setupTestData()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setupTestData()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#printRunningGoroutines",
              "documentation": {
                "identifier": "printRunningGoroutines",
                "newPage": false,
                "searchKey": "net.printRunningGoroutines",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printRunningGoroutines()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printRunningGoroutines()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#runningGoroutines",
              "documentation": {
                "identifier": "runningGoroutines",
                "newPage": false,
                "searchKey": "net.runningGoroutines",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runningGoroutines() []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runningGoroutines() []string\n```\n\nrunningGoroutines returns a list of remaining goroutines. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#printInflightSockets",
              "documentation": {
                "identifier": "printInflightSockets",
                "newPage": false,
                "searchKey": "net.printInflightSockets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printInflightSockets()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printInflightSockets()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#printSocketStats",
              "documentation": {
                "identifier": "printSocketStats",
                "newPage": false,
                "searchKey": "net.printSocketStats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printSocketStats()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printSocketStats()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#installTestHooks",
              "documentation": {
                "identifier": "installTestHooks",
                "newPage": false,
                "searchKey": "net.installTestHooks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func installTestHooks()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc installTestHooks()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#uninstallTestHooks",
              "documentation": {
                "identifier": "uninstallTestHooks",
                "newPage": false,
                "searchKey": "net.uninstallTestHooks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func uninstallTestHooks()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc uninstallTestHooks()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#forceCloseSockets",
              "documentation": {
                "identifier": "forceCloseSockets",
                "newPage": false,
                "searchKey": "net.forceCloseSockets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func forceCloseSockets()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc forceCloseSockets()\n```\n\nforceCloseSockets must be called only from TestMain. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testUnixAddr",
              "documentation": {
                "identifier": "testUnixAddr",
                "newPage": false,
                "searchKey": "net.testUnixAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testUnixAddr() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testUnixAddr() string\n```\n\ntestUnixAddr uses os.CreateTemp to get a name that is unique. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#newDualStackListener",
              "documentation": {
                "identifier": "newDualStackListener",
                "newPage": false,
                "searchKey": "net.newDualStackListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newDualStackListener() (lns []*TCPListener, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newDualStackListener() (lns []*TCPListener, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#transceiver",
              "documentation": {
                "identifier": "transceiver",
                "newPage": false,
                "searchKey": "net.transceiver",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func transceiver(c Conn, wb []byte, ch chan<- error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc transceiver(c Conn, wb []byte, ch chan<- error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#timeoutReceiver",
              "documentation": {
                "identifier": "timeoutReceiver",
                "newPage": false,
                "searchKey": "net.timeoutReceiver",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func timeoutReceiver(c Conn, d, min, max time.Duration, ch chan<- error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc timeoutReceiver(c Conn, d, min, max time.Duration, ch chan<- error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#timeoutTransmitter",
              "documentation": {
                "identifier": "timeoutTransmitter",
                "newPage": false,
                "searchKey": "net.timeoutTransmitter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func timeoutTransmitter(c Conn, d, min, max time.Duration, ch chan<- error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc timeoutTransmitter(c Conn, d, min, max time.Duration, ch chan<- error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#newDualStackPacketListener",
              "documentation": {
                "identifier": "newDualStackPacketListener",
                "newPage": false,
                "searchKey": "net.newDualStackPacketListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newDualStackPacketListener() (cs []*UDPConn, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newDualStackPacketListener() (cs []*UDPConn, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#packetTransponder",
              "documentation": {
                "identifier": "packetTransponder",
                "newPage": false,
                "searchKey": "net.packetTransponder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func packetTransponder(c PacketConn, ch chan<- error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc packetTransponder(c PacketConn, ch chan<- error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#packetTransceiver",
              "documentation": {
                "identifier": "packetTransceiver",
                "newPage": false,
                "searchKey": "net.packetTransceiver",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func packetTransceiver(c PacketConn, wb []byte, dst Addr, ch chan<- error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc packetTransceiver(c PacketConn, wb []byte, dst Addr, ch chan<- error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#timeoutPacketReceiver",
              "documentation": {
                "identifier": "timeoutPacketReceiver",
                "newPage": false,
                "searchKey": "net.timeoutPacketReceiver",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func timeoutPacketReceiver(c PacketConn, d, min, max time.Duration, ch chan<- error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc timeoutPacketReceiver(c PacketConn, d, min, max time.Duration, ch chan<- error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCloseRead",
              "documentation": {
                "identifier": "TestCloseRead",
                "newPage": false,
                "searchKey": "net.TestCloseRead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloseRead(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloseRead(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCloseWrite",
              "documentation": {
                "identifier": "TestCloseWrite",
                "newPage": false,
                "searchKey": "net.TestCloseWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloseWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloseWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestConnClose",
              "documentation": {
                "identifier": "TestConnClose",
                "newPage": false,
                "searchKey": "net.TestConnClose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConnClose(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConnClose(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestListenerClose",
              "documentation": {
                "identifier": "TestListenerClose",
                "newPage": false,
                "searchKey": "net.TestListenerClose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestListenerClose(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestListenerClose(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestPacketConnClose",
              "documentation": {
                "identifier": "TestPacketConnClose",
                "newPage": false,
                "searchKey": "net.TestPacketConnClose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPacketConnClose(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPacketConnClose(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestListenCloseListen",
              "documentation": {
                "identifier": "TestListenCloseListen",
                "newPage": false,
                "searchKey": "net.TestListenCloseListen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestListenCloseListen(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestListenCloseListen(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAcceptIgnoreAbortedConnRequest",
              "documentation": {
                "identifier": "TestAcceptIgnoreAbortedConnRequest",
                "newPage": false,
                "searchKey": "net.TestAcceptIgnoreAbortedConnRequest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAcceptIgnoreAbortedConnRequest(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAcceptIgnoreAbortedConnRequest(t *testing.T)\n```\n\nSee golang.org/issue/6163, golang.org/issue/6987. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestZeroByteRead",
              "documentation": {
                "identifier": "TestZeroByteRead",
                "newPage": false,
                "searchKey": "net.TestZeroByteRead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestZeroByteRead(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestZeroByteRead(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#withTCPConnPair",
              "documentation": {
                "identifier": "withTCPConnPair",
                "newPage": false,
                "searchKey": "net.withTCPConnPair",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func withTCPConnPair(t *testing.T, peer1, peer2 func(c *TCPConn) error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc withTCPConnPair(t *testing.T, peer1, peer2 func(c *TCPConn) error)\n```\n\nwithTCPConnPair sets up a TCP connection between two peers, then runs peer1 and peer2 concurrently. withTCPConnPair returns when both have completed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadTimeoutUnblocksRead",
              "documentation": {
                "identifier": "TestReadTimeoutUnblocksRead",
                "newPage": false,
                "searchKey": "net.TestReadTimeoutUnblocksRead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadTimeoutUnblocksRead(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadTimeoutUnblocksRead(t *testing.T)\n```\n\nTests that a blocked Read is interrupted by a concurrent SetReadDeadline modifying that Conn's read deadline to the past. See golang.org/cl/30164 which documented this. The net/http package depends on this. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCloseUnblocksRead",
              "documentation": {
                "identifier": "TestCloseUnblocksRead",
                "newPage": false,
                "searchKey": "net.TestCloseUnblocksRead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloseUnblocksRead(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloseUnblocksRead(t *testing.T)\n```\n\nIssue 17695: verify that a blocked Read is woken up by a Close. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestNotTemporaryRead",
              "documentation": {
                "identifier": "TestNotTemporaryRead",
                "newPage": false,
                "searchKey": "net.TestNotTemporaryRead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNotTemporaryRead(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNotTemporaryRead(t *testing.T)\n```\n\nIssue 24808: verify that ECONNRESET is not temporary for read. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestErrors",
              "documentation": {
                "identifier": "TestErrors",
                "newPage": false,
                "searchKey": "net.TestErrors",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestErrors(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestErrors(t *testing.T)\n```\n\nThe various errors should implement the Error interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestParseNSSConf",
              "documentation": {
                "identifier": "TestParseNSSConf",
                "newPage": false,
                "searchKey": "net.TestParseNSSConf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseNSSConf(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseNSSConf(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#packetConnTestData",
              "documentation": {
                "identifier": "packetConnTestData",
                "newPage": false,
                "searchKey": "net.packetConnTestData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func packetConnTestData(t *testing.T, network string) ([]byte, func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc packetConnTestData(t *testing.T, network string) ([]byte, func())\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestPacketConn",
              "documentation": {
                "identifier": "TestPacketConn",
                "newPage": false,
                "searchKey": "net.TestPacketConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPacketConn(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPacketConn(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestConnAndPacketConn",
              "documentation": {
                "identifier": "TestConnAndPacketConn",
                "newPage": false,
                "searchKey": "net.TestConnAndPacketConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConnAndPacketConn(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConnAndPacketConn(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadLine",
              "documentation": {
                "identifier": "TestReadLine",
                "newPage": false,
                "searchKey": "net.TestReadLine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadLine(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadLine(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestGoDebugString",
              "documentation": {
                "identifier": "TestGoDebugString",
                "newPage": false,
                "searchKey": "net.TestGoDebugString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGoDebugString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGoDebugString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDtoi",
              "documentation": {
                "identifier": "TestDtoi",
                "newPage": false,
                "searchKey": "net.TestDtoi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDtoi(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDtoi(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "net.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testableNetwork",
              "documentation": {
                "identifier": "testableNetwork",
                "newPage": false,
                "searchKey": "net.testableNetwork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testableNetwork(network string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testableNetwork(network string) bool\n```\n\ntestableNetwork reports whether network is testable on the current platform configuration. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#iOS",
              "documentation": {
                "identifier": "iOS",
                "newPage": false,
                "searchKey": "net.iOS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func iOS() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc iOS() bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testableAddress",
              "documentation": {
                "identifier": "testableAddress",
                "newPage": false,
                "searchKey": "net.testableAddress",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testableAddress(network, address string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testableAddress(network, address string) bool\n```\n\ntestableAddress reports whether address of network is testable on the current platform configuration. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testableListenArgs",
              "documentation": {
                "identifier": "testableListenArgs",
                "newPage": false,
                "searchKey": "net.testableListenArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testableListenArgs(network, address, client string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testableListenArgs(network, address, client string) bool\n```\n\ntestableListenArgs reports whether arguments are testable on the current platform configuration. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#condFatalf",
              "documentation": {
                "identifier": "condFatalf",
                "newPage": false,
                "searchKey": "net.condFatalf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func condFatalf(t *testing.T, network string, format string, args ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc condFatalf(t *testing.T, network string, format string, args ...interface{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestParsePort",
              "documentation": {
                "identifier": "TestParsePort",
                "newPage": false,
                "searchKey": "net.TestParsePort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParsePort(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParsePort(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPListenerSpecificMethods",
              "documentation": {
                "identifier": "TestTCPListenerSpecificMethods",
                "newPage": false,
                "searchKey": "net.TestTCPListenerSpecificMethods",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPListenerSpecificMethods(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPListenerSpecificMethods(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPConnSpecificMethods",
              "documentation": {
                "identifier": "TestTCPConnSpecificMethods",
                "newPage": false,
                "searchKey": "net.TestTCPConnSpecificMethods",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPConnSpecificMethods(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPConnSpecificMethods(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUDPConnSpecificMethods",
              "documentation": {
                "identifier": "TestUDPConnSpecificMethods",
                "newPage": false,
                "searchKey": "net.TestUDPConnSpecificMethods",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUDPConnSpecificMethods(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUDPConnSpecificMethods(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPConnSpecificMethods",
              "documentation": {
                "identifier": "TestIPConnSpecificMethods",
                "newPage": false,
                "searchKey": "net.TestIPConnSpecificMethods",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPConnSpecificMethods(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPConnSpecificMethods(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixListenerSpecificMethods",
              "documentation": {
                "identifier": "TestUnixListenerSpecificMethods",
                "newPage": false,
                "searchKey": "net.TestUnixListenerSpecificMethods",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixListenerSpecificMethods(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixListenerSpecificMethods(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixConnSpecificMethods",
              "documentation": {
                "identifier": "TestUnixConnSpecificMethods",
                "newPage": false,
                "searchKey": "net.TestUnixConnSpecificMethods",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixConnSpecificMethods(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixConnSpecificMethods(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestRawConnReadWrite",
              "documentation": {
                "identifier": "TestRawConnReadWrite",
                "newPage": false,
                "searchKey": "net.TestRawConnReadWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRawConnReadWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRawConnReadWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestRawConnControl",
              "documentation": {
                "identifier": "TestRawConnControl",
                "newPage": false,
                "searchKey": "net.TestRawConnControl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRawConnControl(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRawConnControl(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#readRawConn",
              "documentation": {
                "identifier": "readRawConn",
                "newPage": false,
                "searchKey": "net.readRawConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readRawConn(c syscall.RawConn, b []byte) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readRawConn(c syscall.RawConn, b []byte) (int, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#writeRawConn",
              "documentation": {
                "identifier": "writeRawConn",
                "newPage": false,
                "searchKey": "net.writeRawConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeRawConn(c syscall.RawConn, b []byte) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeRawConn(c syscall.RawConn, b []byte) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#controlRawConn",
              "documentation": {
                "identifier": "controlRawConn",
                "newPage": false,
                "searchKey": "net.controlRawConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func controlRawConn(c syscall.RawConn, addr Addr) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc controlRawConn(c syscall.RawConn, addr Addr) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#controlOnConnSetup",
              "documentation": {
                "identifier": "controlOnConnSetup",
                "newPage": false,
                "searchKey": "net.controlOnConnSetup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func controlOnConnSetup(network string, address string, c syscall.RawConn) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc controlOnConnSetup(network string, address string, c syscall.RawConn) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSendfile",
              "documentation": {
                "identifier": "TestSendfile",
                "newPage": false,
                "searchKey": "net.TestSendfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSendfile(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSendfile(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSendfileParts",
              "documentation": {
                "identifier": "TestSendfileParts",
                "newPage": false,
                "searchKey": "net.TestSendfileParts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSendfileParts(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSendfileParts(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSendfileSeeked",
              "documentation": {
                "identifier": "TestSendfileSeeked",
                "newPage": false,
                "searchKey": "net.TestSendfileSeeked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSendfileSeeked(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSendfileSeeked(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSendfilePipe",
              "documentation": {
                "identifier": "TestSendfilePipe",
                "newPage": false,
                "searchKey": "net.TestSendfilePipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSendfilePipe(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSendfilePipe(t *testing.T)\n```\n\nTest that sendfile doesn't put a pipe into blocking mode. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestSendfileOnWriteTimeoutExceeded",
              "documentation": {
                "identifier": "TestSendfileOnWriteTimeoutExceeded",
                "newPage": false,
                "searchKey": "net.TestSendfileOnWriteTimeoutExceeded",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSendfileOnWriteTimeoutExceeded(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSendfileOnWriteTimeoutExceeded(t *testing.T)\n```\n\nIssue 43822: tests that returns EOF when conn write timeout. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPServer",
              "documentation": {
                "identifier": "TestTCPServer",
                "newPage": false,
                "searchKey": "net.TestTCPServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPServer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPServer(t *testing.T)\n```\n\nTestTCPServer tests concurrent accept-read-write servers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixAndUnixpacketServer",
              "documentation": {
                "identifier": "TestUnixAndUnixpacketServer",
                "newPage": false,
                "searchKey": "net.TestUnixAndUnixpacketServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixAndUnixpacketServer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixAndUnixpacketServer(t *testing.T)\n```\n\nTestUnixAndUnixpacketServer tests concurrent accept-read-write servers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUDPServer",
              "documentation": {
                "identifier": "TestUDPServer",
                "newPage": false,
                "searchKey": "net.TestUDPServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUDPServer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUDPServer(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixgramServer",
              "documentation": {
                "identifier": "TestUnixgramServer",
                "newPage": false,
                "searchKey": "net.TestUnixgramServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixgramServer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixgramServer(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP4OneShot",
              "documentation": {
                "identifier": "BenchmarkTCP4OneShot",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP4OneShot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP4OneShot(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP4OneShot(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP4OneShotTimeout",
              "documentation": {
                "identifier": "BenchmarkTCP4OneShotTimeout",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP4OneShotTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP4OneShotTimeout(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP4OneShotTimeout(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP4Persistent",
              "documentation": {
                "identifier": "BenchmarkTCP4Persistent",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP4Persistent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP4Persistent(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP4Persistent(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP4PersistentTimeout",
              "documentation": {
                "identifier": "BenchmarkTCP4PersistentTimeout",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP4PersistentTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP4PersistentTimeout(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP4PersistentTimeout(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP6OneShot",
              "documentation": {
                "identifier": "BenchmarkTCP6OneShot",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP6OneShot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP6OneShot(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP6OneShot(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP6OneShotTimeout",
              "documentation": {
                "identifier": "BenchmarkTCP6OneShotTimeout",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP6OneShotTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP6OneShotTimeout(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP6OneShotTimeout(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP6Persistent",
              "documentation": {
                "identifier": "BenchmarkTCP6Persistent",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP6Persistent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP6Persistent(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP6Persistent(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP6PersistentTimeout",
              "documentation": {
                "identifier": "BenchmarkTCP6PersistentTimeout",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP6PersistentTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP6PersistentTimeout(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP6PersistentTimeout(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#benchmarkTCP",
              "documentation": {
                "identifier": "benchmarkTCP",
                "newPage": false,
                "searchKey": "net.benchmarkTCP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkTCP(b *testing.B, persistent, timeout bool, laddr string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkTCP(b *testing.B, persistent, timeout bool, laddr string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP4ConcurrentReadWrite",
              "documentation": {
                "identifier": "BenchmarkTCP4ConcurrentReadWrite",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP4ConcurrentReadWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP4ConcurrentReadWrite(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP4ConcurrentReadWrite(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkTCP6ConcurrentReadWrite",
              "documentation": {
                "identifier": "BenchmarkTCP6ConcurrentReadWrite",
                "newPage": false,
                "searchKey": "net.BenchmarkTCP6ConcurrentReadWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTCP6ConcurrentReadWrite(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTCP6ConcurrentReadWrite(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#benchmarkTCPConcurrentReadWrite",
              "documentation": {
                "identifier": "benchmarkTCPConcurrentReadWrite",
                "newPage": false,
                "searchKey": "net.benchmarkTCPConcurrentReadWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkTCPConcurrentReadWrite(b *testing.B, laddr string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkTCPConcurrentReadWrite(b *testing.B, laddr string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestResolveTCPAddr",
              "documentation": {
                "identifier": "TestResolveTCPAddr",
                "newPage": false,
                "searchKey": "net.TestResolveTCPAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResolveTCPAddr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResolveTCPAddr(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPListenerName",
              "documentation": {
                "identifier": "TestTCPListenerName",
                "newPage": false,
                "searchKey": "net.TestTCPListenerName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPListenerName(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPListenerName(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPv6LinkLocalUnicastTCP",
              "documentation": {
                "identifier": "TestIPv6LinkLocalUnicastTCP",
                "newPage": false,
                "searchKey": "net.TestIPv6LinkLocalUnicastTCP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPv6LinkLocalUnicastTCP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPv6LinkLocalUnicastTCP(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPConcurrentAccept",
              "documentation": {
                "identifier": "TestTCPConcurrentAccept",
                "newPage": false,
                "searchKey": "net.TestTCPConcurrentAccept",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPConcurrentAccept(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPConcurrentAccept(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPReadWriteAllocs",
              "documentation": {
                "identifier": "TestTCPReadWriteAllocs",
                "newPage": false,
                "searchKey": "net.TestTCPReadWriteAllocs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPReadWriteAllocs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPReadWriteAllocs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPStress",
              "documentation": {
                "identifier": "TestTCPStress",
                "newPage": false,
                "searchKey": "net.TestTCPStress",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPStress(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPStress(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPSelfConnect",
              "documentation": {
                "identifier": "TestTCPSelfConnect",
                "newPage": false,
                "searchKey": "net.TestTCPSelfConnect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPSelfConnect(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPSelfConnect(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPBig",
              "documentation": {
                "identifier": "TestTCPBig",
                "newPage": false,
                "searchKey": "net.TestTCPBig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPBig(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPBig(t *testing.T)\n```\n\nTest that >32-bit reads work on 64-bit systems. On 32-bit systems this tests that maxint reads work. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestCopyPipeIntoTCP",
              "documentation": {
                "identifier": "TestCopyPipeIntoTCP",
                "newPage": false,
                "searchKey": "net.TestCopyPipeIntoTCP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCopyPipeIntoTCP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCopyPipeIntoTCP(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkSetReadDeadline",
              "documentation": {
                "identifier": "BenchmarkSetReadDeadline",
                "newPage": false,
                "searchKey": "net.BenchmarkSetReadDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkSetReadDeadline(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkSetReadDeadline(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPSpuriousConnSetupCompletion",
              "documentation": {
                "identifier": "TestTCPSpuriousConnSetupCompletion",
                "newPage": false,
                "searchKey": "net.TestTCPSpuriousConnSetupCompletion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPSpuriousConnSetupCompletion(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPSpuriousConnSetupCompletion(t *testing.T)\n```\n\nSee golang.org/issue/14548. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestTCPSpuriousConnSetupCompletionWithCancel",
              "documentation": {
                "identifier": "TestTCPSpuriousConnSetupCompletionWithCancel",
                "newPage": false,
                "searchKey": "net.TestTCPSpuriousConnSetupCompletionWithCancel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTCPSpuriousConnSetupCompletionWithCancel(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTCPSpuriousConnSetupCompletionWithCancel(t *testing.T)\n```\n\nIssue 19289. Test that a canceled Dial does not cause a subsequent Dial to succeed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialTimeout",
              "documentation": {
                "identifier": "TestDialTimeout",
                "newPage": false,
                "searchKey": "net.TestDialTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialTimeout(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestDialTimeoutMaxDuration",
              "documentation": {
                "identifier": "TestDialTimeoutMaxDuration",
                "newPage": false,
                "searchKey": "net.TestDialTimeoutMaxDuration",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialTimeoutMaxDuration(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialTimeoutMaxDuration(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAcceptTimeout",
              "documentation": {
                "identifier": "TestAcceptTimeout",
                "newPage": false,
                "searchKey": "net.TestAcceptTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAcceptTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAcceptTimeout(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAcceptTimeoutMustReturn",
              "documentation": {
                "identifier": "TestAcceptTimeoutMustReturn",
                "newPage": false,
                "searchKey": "net.TestAcceptTimeoutMustReturn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAcceptTimeoutMustReturn(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAcceptTimeoutMustReturn(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestAcceptTimeoutMustNotReturn",
              "documentation": {
                "identifier": "TestAcceptTimeoutMustNotReturn",
                "newPage": false,
                "searchKey": "net.TestAcceptTimeoutMustNotReturn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAcceptTimeoutMustNotReturn(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAcceptTimeoutMustNotReturn(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadTimeout",
              "documentation": {
                "identifier": "TestReadTimeout",
                "newPage": false,
                "searchKey": "net.TestReadTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadTimeout(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadTimeoutMustNotReturn",
              "documentation": {
                "identifier": "TestReadTimeoutMustNotReturn",
                "newPage": false,
                "searchKey": "net.TestReadTimeoutMustNotReturn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadTimeoutMustNotReturn(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadTimeoutMustNotReturn(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadFromTimeout",
              "documentation": {
                "identifier": "TestReadFromTimeout",
                "newPage": false,
                "searchKey": "net.TestReadFromTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadFromTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadFromTimeout(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestWriteTimeout",
              "documentation": {
                "identifier": "TestWriteTimeout",
                "newPage": false,
                "searchKey": "net.TestWriteTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteTimeout(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestWriteTimeoutMustNotReturn",
              "documentation": {
                "identifier": "TestWriteTimeoutMustNotReturn",
                "newPage": false,
                "searchKey": "net.TestWriteTimeoutMustNotReturn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteTimeoutMustNotReturn(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteTimeoutMustNotReturn(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestWriteToTimeout",
              "documentation": {
                "identifier": "TestWriteToTimeout",
                "newPage": false,
                "searchKey": "net.TestWriteToTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteToTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteToTimeout(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadTimeoutFluctuation",
              "documentation": {
                "identifier": "TestReadTimeoutFluctuation",
                "newPage": false,
                "searchKey": "net.TestReadTimeoutFluctuation",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadTimeoutFluctuation(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadTimeoutFluctuation(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadFromTimeoutFluctuation",
              "documentation": {
                "identifier": "TestReadFromTimeoutFluctuation",
                "newPage": false,
                "searchKey": "net.TestReadFromTimeoutFluctuation",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadFromTimeoutFluctuation(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadFromTimeoutFluctuation(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestWriteTimeoutFluctuation",
              "documentation": {
                "identifier": "TestWriteTimeoutFluctuation",
                "newPage": false,
                "searchKey": "net.TestWriteTimeoutFluctuation",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteTimeoutFluctuation(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteTimeoutFluctuation(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestVariousDeadlines",
              "documentation": {
                "identifier": "TestVariousDeadlines",
                "newPage": false,
                "searchKey": "net.TestVariousDeadlines",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestVariousDeadlines(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestVariousDeadlines(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestVariousDeadlines1Proc",
              "documentation": {
                "identifier": "TestVariousDeadlines1Proc",
                "newPage": false,
                "searchKey": "net.TestVariousDeadlines1Proc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestVariousDeadlines1Proc(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestVariousDeadlines1Proc(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestVariousDeadlines4Proc",
              "documentation": {
                "identifier": "TestVariousDeadlines4Proc",
                "newPage": false,
                "searchKey": "net.TestVariousDeadlines4Proc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestVariousDeadlines4Proc(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestVariousDeadlines4Proc(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testVariousDeadlines",
              "documentation": {
                "identifier": "testVariousDeadlines",
                "newPage": false,
                "searchKey": "net.testVariousDeadlines",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testVariousDeadlines(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testVariousDeadlines(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadWriteProlongedTimeout",
              "documentation": {
                "identifier": "TestReadWriteProlongedTimeout",
                "newPage": false,
                "searchKey": "net.TestReadWriteProlongedTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadWriteProlongedTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadWriteProlongedTimeout(t *testing.T)\n```\n\nTestReadWriteProlongedTimeout tests concurrent deadline modification. Known to cause data races in the past. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadWriteDeadlineRace",
              "documentation": {
                "identifier": "TestReadWriteDeadlineRace",
                "newPage": false,
                "searchKey": "net.TestReadWriteDeadlineRace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadWriteDeadlineRace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadWriteDeadlineRace(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestConcurrentSetDeadline",
              "documentation": {
                "identifier": "TestConcurrentSetDeadline",
                "newPage": false,
                "searchKey": "net.TestConcurrentSetDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConcurrentSetDeadline(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConcurrentSetDeadline(t *testing.T)\n```\n\nIssue 35367. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#isDeadlineExceeded",
              "documentation": {
                "identifier": "isDeadlineExceeded",
                "newPage": false,
                "searchKey": "net.isDeadlineExceeded",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isDeadlineExceeded(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isDeadlineExceeded(err error) bool\n```\n\nisDeadlineExceeded reports whether err is or wraps os.ErrDeadlineExceeded. We also check that the error implements net.Error, and that the Timeout method returns true. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkUDP6LinkLocalUnicast",
              "documentation": {
                "identifier": "BenchmarkUDP6LinkLocalUnicast",
                "newPage": false,
                "searchKey": "net.BenchmarkUDP6LinkLocalUnicast",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkUDP6LinkLocalUnicast(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkUDP6LinkLocalUnicast(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestResolveUDPAddr",
              "documentation": {
                "identifier": "TestResolveUDPAddr",
                "newPage": false,
                "searchKey": "net.TestResolveUDPAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResolveUDPAddr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResolveUDPAddr(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestWriteToUDP",
              "documentation": {
                "identifier": "TestWriteToUDP",
                "newPage": false,
                "searchKey": "net.TestWriteToUDP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteToUDP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteToUDP(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testWriteToConn",
              "documentation": {
                "identifier": "testWriteToConn",
                "newPage": false,
                "searchKey": "net.testWriteToConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testWriteToConn(t *testing.T, raddr string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testWriteToConn(t *testing.T, raddr string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testWriteToPacketConn",
              "documentation": {
                "identifier": "testWriteToPacketConn",
                "newPage": false,
                "searchKey": "net.testWriteToPacketConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testWriteToPacketConn(t *testing.T, raddr string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testWriteToPacketConn(t *testing.T, raddr string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUDPConnLocalName",
              "documentation": {
                "identifier": "TestUDPConnLocalName",
                "newPage": false,
                "searchKey": "net.TestUDPConnLocalName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUDPConnLocalName(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUDPConnLocalName(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUDPConnLocalAndRemoteNames",
              "documentation": {
                "identifier": "TestUDPConnLocalAndRemoteNames",
                "newPage": false,
                "searchKey": "net.TestUDPConnLocalAndRemoteNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUDPConnLocalAndRemoteNames(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUDPConnLocalAndRemoteNames(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestIPv6LinkLocalUnicastUDP",
              "documentation": {
                "identifier": "TestIPv6LinkLocalUnicastUDP",
                "newPage": false,
                "searchKey": "net.TestIPv6LinkLocalUnicastUDP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIPv6LinkLocalUnicastUDP(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIPv6LinkLocalUnicastUDP(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUDPZeroBytePayload",
              "documentation": {
                "identifier": "TestUDPZeroBytePayload",
                "newPage": false,
                "searchKey": "net.TestUDPZeroBytePayload",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUDPZeroBytePayload(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUDPZeroBytePayload(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUDPZeroByteBuffer",
              "documentation": {
                "identifier": "TestUDPZeroByteBuffer",
                "newPage": false,
                "searchKey": "net.TestUDPZeroByteBuffer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUDPZeroByteBuffer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUDPZeroByteBuffer(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUDPReadSizeError",
              "documentation": {
                "identifier": "TestUDPReadSizeError",
                "newPage": false,
                "searchKey": "net.TestUDPReadSizeError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUDPReadSizeError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUDPReadSizeError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUDPReadTimeout",
              "documentation": {
                "identifier": "TestUDPReadTimeout",
                "newPage": false,
                "searchKey": "net.TestUDPReadTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUDPReadTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUDPReadTimeout(t *testing.T)\n```\n\nTestUDPReadTimeout verifies that ReadFromUDP with timeout returns an error without data or an address. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#BenchmarkWriteToReadFromUDP",
              "documentation": {
                "identifier": "BenchmarkWriteToReadFromUDP",
                "newPage": false,
                "searchKey": "net.BenchmarkWriteToReadFromUDP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkWriteToReadFromUDP(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkWriteToReadFromUDP(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixConnReadMsgUnixSCMRightsCloseOnExec",
              "documentation": {
                "identifier": "TestUnixConnReadMsgUnixSCMRightsCloseOnExec",
                "newPage": false,
                "searchKey": "net.TestUnixConnReadMsgUnixSCMRightsCloseOnExec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixConnReadMsgUnixSCMRightsCloseOnExec(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixConnReadMsgUnixSCMRightsCloseOnExec(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestReadUnixgramWithUnnamedSocket",
              "documentation": {
                "identifier": "TestReadUnixgramWithUnnamedSocket",
                "newPage": false,
                "searchKey": "net.TestReadUnixgramWithUnnamedSocket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadUnixgramWithUnnamedSocket(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadUnixgramWithUnnamedSocket(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixgramZeroBytePayload",
              "documentation": {
                "identifier": "TestUnixgramZeroBytePayload",
                "newPage": false,
                "searchKey": "net.TestUnixgramZeroBytePayload",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixgramZeroBytePayload(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixgramZeroBytePayload(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixgramZeroByteBuffer",
              "documentation": {
                "identifier": "TestUnixgramZeroByteBuffer",
                "newPage": false,
                "searchKey": "net.TestUnixgramZeroByteBuffer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixgramZeroByteBuffer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixgramZeroByteBuffer(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixgramWrite",
              "documentation": {
                "identifier": "TestUnixgramWrite",
                "newPage": false,
                "searchKey": "net.TestUnixgramWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixgramWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixgramWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testUnixgramWriteConn",
              "documentation": {
                "identifier": "testUnixgramWriteConn",
                "newPage": false,
                "searchKey": "net.testUnixgramWriteConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testUnixgramWriteConn(t *testing.T, raddr *UnixAddr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testUnixgramWriteConn(t *testing.T, raddr *UnixAddr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testUnixgramWritePacketConn",
              "documentation": {
                "identifier": "testUnixgramWritePacketConn",
                "newPage": false,
                "searchKey": "net.testUnixgramWritePacketConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testUnixgramWritePacketConn(t *testing.T, raddr *UnixAddr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testUnixgramWritePacketConn(t *testing.T, raddr *UnixAddr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixConnLocalAndRemoteNames",
              "documentation": {
                "identifier": "TestUnixConnLocalAndRemoteNames",
                "newPage": false,
                "searchKey": "net.TestUnixConnLocalAndRemoteNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixConnLocalAndRemoteNames(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixConnLocalAndRemoteNames(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixgramConnLocalAndRemoteNames",
              "documentation": {
                "identifier": "TestUnixgramConnLocalAndRemoteNames",
                "newPage": false,
                "searchKey": "net.TestUnixgramConnLocalAndRemoteNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixgramConnLocalAndRemoteNames(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixgramConnLocalAndRemoteNames(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestUnixUnlink",
              "documentation": {
                "identifier": "TestUnixUnlink",
                "newPage": false,
                "searchKey": "net.TestUnixUnlink",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnixUnlink(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnixUnlink(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestEndlessWrite",
              "documentation": {
                "identifier": "TestEndlessWrite",
                "newPage": false,
                "searchKey": "net.TestEndlessWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEndlessWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEndlessWrite(t *testing.T)\n```\n\nTest that a client can't trigger an endless loop of write system calls on the server by shutting down the write side on the client. Possibility raised in the discussion of [https://golang.org/cl/71973](https://golang.org/cl/71973). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestBuffers_read",
              "documentation": {
                "identifier": "TestBuffers_read",
                "newPage": false,
                "searchKey": "net.TestBuffers_read",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBuffers_read(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBuffers_read(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestBuffers_consume",
              "documentation": {
                "identifier": "TestBuffers_consume",
                "newPage": false,
                "searchKey": "net.TestBuffers_consume",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBuffers_consume(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBuffers_consume(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestBuffers_WriteTo",
              "documentation": {
                "identifier": "TestBuffers_WriteTo",
                "newPage": false,
                "searchKey": "net.TestBuffers_WriteTo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBuffers_WriteTo(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBuffers_WriteTo(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#testBuffer_writeTo",
              "documentation": {
                "identifier": "testBuffer_writeTo",
                "newPage": false,
                "searchKey": "net.testBuffer_writeTo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testBuffer_writeTo(t *testing.T, chunks int, useCopy bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testBuffer_writeTo(t *testing.T, chunks int, useCopy bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#TestWritevError",
              "documentation": {
                "identifier": "TestWritevError",
                "newPage": false,
                "searchKey": "net.TestWritevError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWritevError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWritevError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoNameinfoPTR",
              "documentation": {
                "identifier": "cgoNameinfoPTR",
                "newPage": false,
                "searchKey": "net.cgoNameinfoPTR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoNameinfoPTR(b []byte, sa *C.struct_sockaddr, salen C.socklen_t) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoNameinfoPTR(b []byte, sa *C.struct_sockaddr, salen C.socklen_t) (int, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoSockaddrInet4",
              "documentation": {
                "identifier": "cgoSockaddrInet4",
                "newPage": false,
                "searchKey": "net.cgoSockaddrInet4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoSockaddrInet4(ip IP) *C.struct_sockaddr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoSockaddrInet4(ip IP) *C.struct_sockaddr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoSockaddrInet6",
              "documentation": {
                "identifier": "cgoSockaddrInet6",
                "newPage": false,
                "searchKey": "net.cgoSockaddrInet6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoSockaddrInet6(ip IP, zone int) *C.struct_sockaddr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoSockaddrInet6(ip IP, zone int) *C.struct_sockaddr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoLookupHost",
              "documentation": {
                "identifier": "cgoLookupHost",
                "newPage": false,
                "searchKey": "net.cgoLookupHost",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoLookupHost(ctx context.Context, name string) (hosts []string, err error, completed bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoLookupHost(ctx context.Context, name string) (hosts []string, err error, completed bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoLookupPort",
              "documentation": {
                "identifier": "cgoLookupPort",
                "newPage": false,
                "searchKey": "net.cgoLookupPort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoLookupPort(ctx context.Context, network, service string) (port int, err error, completed bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoLookupPort(ctx context.Context, network, service string) (port int, err error, completed bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoLookupServicePort",
              "documentation": {
                "identifier": "cgoLookupServicePort",
                "newPage": false,
                "searchKey": "net.cgoLookupServicePort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoLookupServicePort(hints *C.struct_addrinfo, network, service string) (port int, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoLookupServicePort(hints *C.struct_addrinfo, network, service string) (port int, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoPortLookup",
              "documentation": {
                "identifier": "cgoPortLookup",
                "newPage": false,
                "searchKey": "net.cgoPortLookup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoPortLookup(result chan<- portLookupResult, hints *C.struct_addrinfo, network, service string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoPortLookup(result chan<- portLookupResult, hints *C.struct_addrinfo, network, service string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoLookupIPCNAME",
              "documentation": {
                "identifier": "cgoLookupIPCNAME",
                "newPage": false,
                "searchKey": "net.cgoLookupIPCNAME",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoLookupIPCNAME(network, name string) (addrs []IPAddr, cname string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoLookupIPCNAME(network, name string) (addrs []IPAddr, cname string, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoIPLookup",
              "documentation": {
                "identifier": "cgoIPLookup",
                "newPage": false,
                "searchKey": "net.cgoIPLookup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoIPLookup(result chan<- ipLookupResult, network, name string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoIPLookup(result chan<- ipLookupResult, network, name string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoLookupIP",
              "documentation": {
                "identifier": "cgoLookupIP",
                "newPage": false,
                "searchKey": "net.cgoLookupIP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoLookupIP(ctx context.Context, network, name string) (addrs []IPAddr, err error, completed bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoLookupIP(ctx context.Context, network, name string) (addrs []IPAddr, err error, completed bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoLookupCNAME",
              "documentation": {
                "identifier": "cgoLookupCNAME",
                "newPage": false,
                "searchKey": "net.cgoLookupCNAME",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoLookupCNAME(ctx context.Context, name string) (cname string, err error, completed bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoLookupCNAME(ctx context.Context, name string) (cname string, err error, completed bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoLookupPTR",
              "documentation": {
                "identifier": "cgoLookupPTR",
                "newPage": false,
                "searchKey": "net.cgoLookupPTR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoLookupPTR(ctx context.Context, addr string) (names []string, err error, completed bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoLookupPTR(ctx context.Context, addr string) (names []string, err error, completed bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoLookupAddrPTR",
              "documentation": {
                "identifier": "cgoLookupAddrPTR",
                "newPage": false,
                "searchKey": "net.cgoLookupAddrPTR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoLookupAddrPTR(addr string, sa *C.struct_sockaddr, salen C.socklen_t) (names []string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoLookupAddrPTR(addr string, sa *C.struct_sockaddr, salen C.socklen_t) (names []string, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoReverseLookup",
              "documentation": {
                "identifier": "cgoReverseLookup",
                "newPage": false,
                "searchKey": "net.cgoReverseLookup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoReverseLookup(result chan<- reverseLookupResult, addr string, sa *C.struct_sockaddr, salen C.socklen_t)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoReverseLookup(result chan<- reverseLookupResult, addr string, sa *C.struct_sockaddr, salen C.socklen_t)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/net#cgoSockaddr",
              "documentation": {
                "identifier": "cgoSockaddr",
                "newPage": false,
                "searchKey": "net.cgoSockaddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoSockaddr(ip IP, zone string) (*C.struct_sockaddr, C.socklen_t)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoSockaddr(ip IP, zone string) (*C.struct_sockaddr, C.socklen_t)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/std/net/http"
    },
    {
      "pathID": "/std/net/http_test"
    },
    {
      "pathID": "/std/net/mail"
    },
    {
      "pathID": "/std/net/mail_test"
    },
    {
      "pathID": "/std/net/rpc"
    },
    {
      "pathID": "/std/net/smtp"
    },
    {
      "pathID": "/std/net/smtp_test"
    },
    {
      "pathID": "/std/net/textproto"
    },
    {
      "pathID": "/std/net/url"
    },
    {
      "pathID": "/std/net/url_test"
    }
  ]
}
