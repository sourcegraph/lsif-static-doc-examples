{
  "pathID": "/std/bytes",
  "documentation": {
    "identifier": "bytes",
    "newPage": true,
    "searchKey": "std/bytes",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package bytes"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/std/bytes#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/bytes#smallBufferSize",
              "documentation": {
                "identifier": "smallBufferSize",
                "newPage": false,
                "searchKey": "bytes.smallBufferSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const smallBufferSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst smallBufferSize = 64\n```\n\nsmallBufferSize is an initial allocation minimal capacity. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#opRead",
              "documentation": {
                "identifier": "opRead",
                "newPage": false,
                "searchKey": "bytes.opRead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opRead"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opRead readOp = -1 // Any other read operation.\n\n```\n\nDon't use iota for these, as the values need to correspond with the names and comments, which is easier to see when being explicit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#opInvalid",
              "documentation": {
                "identifier": "opInvalid",
                "newPage": false,
                "searchKey": "bytes.opInvalid",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opInvalid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opInvalid readOp = 0 // Non-read operation.\n\n```\n\nDon't use iota for these, as the values need to correspond with the names and comments, which is easier to see when being explicit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#opReadRune1",
              "documentation": {
                "identifier": "opReadRune1",
                "newPage": false,
                "searchKey": "bytes.opReadRune1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opReadRune1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opReadRune1 readOp = 1 // Read rune of size 1.\n\n```\n\nDon't use iota for these, as the values need to correspond with the names and comments, which is easier to see when being explicit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#opReadRune2",
              "documentation": {
                "identifier": "opReadRune2",
                "newPage": false,
                "searchKey": "bytes.opReadRune2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opReadRune2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opReadRune2 readOp = 2 // Read rune of size 2.\n\n```\n\nDon't use iota for these, as the values need to correspond with the names and comments, which is easier to see when being explicit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#opReadRune3",
              "documentation": {
                "identifier": "opReadRune3",
                "newPage": false,
                "searchKey": "bytes.opReadRune3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opReadRune3"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opReadRune3 readOp = 3 // Read rune of size 3.\n\n```\n\nDon't use iota for these, as the values need to correspond with the names and comments, which is easier to see when being explicit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#opReadRune4",
              "documentation": {
                "identifier": "opReadRune4",
                "newPage": false,
                "searchKey": "bytes.opReadRune4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opReadRune4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opReadRune4 readOp = 4 // Read rune of size 4.\n\n```\n\nDon't use iota for these, as the values need to correspond with the names and comments, which is easier to see when being explicit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#maxInt",
              "documentation": {
                "identifier": "maxInt",
                "newPage": false,
                "searchKey": "bytes.maxInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxInt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxInt = int(^uint(0) >> 1)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#MinRead",
              "documentation": {
                "identifier": "MinRead",
                "newPage": false,
                "searchKey": "bytes.MinRead",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MinRead"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MinRead = 512\n```\n\nMinRead is the minimum slice size passed to a Read call by Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond what is required to hold the contents of r, ReadFrom will not grow the underlying buffer. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/bytes#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/bytes#ErrTooLarge",
              "documentation": {
                "identifier": "ErrTooLarge",
                "newPage": false,
                "searchKey": "bytes.ErrTooLarge",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrTooLarge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrTooLarge = errors.New(\"bytes.Buffer: too large\")\n```\n\nErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#errNegativeRead",
              "documentation": {
                "identifier": "errNegativeRead",
                "newPage": false,
                "searchKey": "bytes.errNegativeRead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNegativeRead"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNegativeRead = errors.New(\"bytes.Buffer: reader returned negative count from Read\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#errUnreadByte",
              "documentation": {
                "identifier": "errUnreadByte",
                "newPage": false,
                "searchKey": "bytes.errUnreadByte",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errUnreadByte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errUnreadByte = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#asciiSpace",
              "documentation": {
                "identifier": "asciiSpace",
                "newPage": false,
                "searchKey": "bytes.asciiSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var asciiSpace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar asciiSpace = [256]uint8{'\\t': 1, '\\n': 1, '\\v': 1, '\\f': 1, '\\r': 1, ' ': 1}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#IndexBytePortable",
              "documentation": {
                "identifier": "IndexBytePortable",
                "newPage": false,
                "searchKey": "bytes.IndexBytePortable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var IndexBytePortable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IndexBytePortable = indexBytePortable\n```\n\nExport func for testing \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/bytes#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/bytes#Buffer",
              "documentation": {
                "identifier": "Buffer",
                "newPage": false,
                "searchKey": "bytes.Buffer",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Buffer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Buffer struct {\n\tbuf      []byte // contents are the bytes buf[off : len(buf)]\n\toff      int    // read at &buf[off], write at &buf[len(buf)]\n\tlastRead readOp // last read operation, so that Unread* can work correctly.\n}\n```\n\nA Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/bytes#NewBuffer",
                    "documentation": {
                      "identifier": "NewBuffer",
                      "newPage": false,
                      "searchKey": "bytes.NewBuffer",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewBuffer(buf []byte) *Buffer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewBuffer(buf []byte) *Buffer\n```\n\nNewBuffer creates and initializes a new Buffer using buf as its initial contents. The new Buffer takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a Buffer to read existing data. It can also be used to set the initial size of the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero. \n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#NewBufferString",
                    "documentation": {
                      "identifier": "NewBufferString",
                      "newPage": false,
                      "searchKey": "bytes.NewBufferString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewBufferString(s string) *Buffer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewBufferString(s string) *Buffer\n```\n\nNewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string. \n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.Bytes",
                    "documentation": {
                      "identifier": "Buffer.Bytes",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.Bytes",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) Bytes() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) Bytes() []byte\n```\n\nBytes returns a slice of length b.Len() holding the unread portion of the buffer. The slice is valid for use only until the next buffer modification (that is, only until the next call to a method like Read, Write, Reset, or Truncate). The slice aliases the buffer content at least until the next buffer modification, so immediate changes to the slice will affect the result of future reads. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.String",
                    "documentation": {
                      "identifier": "Buffer.String",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) String() string\n```\n\nString returns the contents of the unread portion of the buffer as a string. If the Buffer is a nil pointer, it returns \"<nil>\". \n\nTo build strings more efficiently, see the strings.Builder type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.empty",
                    "documentation": {
                      "identifier": "Buffer.empty",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) empty() bool\n```\n\nempty reports whether the unread portion of the buffer is empty. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.Len",
                    "documentation": {
                      "identifier": "Buffer.Len",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.Len",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) Len() int\n```\n\nLen returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.Cap",
                    "documentation": {
                      "identifier": "Buffer.Cap",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.Cap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) Cap() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) Cap() int\n```\n\nCap returns the capacity of the buffer's underlying byte slice, that is, the total space allocated for the buffer's data. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.Truncate",
                    "documentation": {
                      "identifier": "Buffer.Truncate",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.Truncate",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) Truncate(n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) Truncate(n int)\n```\n\nTruncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.Reset",
                    "documentation": {
                      "identifier": "Buffer.Reset",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.Reset",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) Reset()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) Reset()\n```\n\nReset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as Truncate(0). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.tryGrowByReslice",
                    "documentation": {
                      "identifier": "Buffer.tryGrowByReslice",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.tryGrowByReslice",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) tryGrowByReslice(n int) (int, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) tryGrowByReslice(n int) (int, bool)\n```\n\ntryGrowByReslice is a inlineable version of grow for the fast-case where the internal buffer only needs to be resliced. It returns the index where bytes should be written and whether it succeeded. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.grow",
                    "documentation": {
                      "identifier": "Buffer.grow",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.grow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) grow(n int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) grow(n int) int\n```\n\ngrow grows the buffer to guarantee space for n more bytes. It returns the index where bytes should be written. If the buffer can't grow it will panic with ErrTooLarge. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.Grow",
                    "documentation": {
                      "identifier": "Buffer.Grow",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.Grow",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) Grow(n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) Grow(n int)\n```\n\nGrow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.Write",
                    "documentation": {
                      "identifier": "Buffer.Write",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.Write",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) Write(p []byte) (n int, err error)\n```\n\nWrite appends the contents of p to the buffer, growing the buffer as needed. The return value n is the length of p; err is always nil. If the buffer becomes too large, Write will panic with ErrTooLarge. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.WriteString",
                    "documentation": {
                      "identifier": "Buffer.WriteString",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.WriteString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) WriteString(s string) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) WriteString(s string) (n int, err error)\n```\n\nWriteString appends the contents of s to the buffer, growing the buffer as needed. The return value n is the length of s; err is always nil. If the buffer becomes too large, WriteString will panic with ErrTooLarge. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.ReadFrom",
                    "documentation": {
                      "identifier": "Buffer.ReadFrom",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.ReadFrom",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)\n```\n\nReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.WriteTo",
                    "documentation": {
                      "identifier": "Buffer.WriteTo",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.WriteTo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) WriteTo(w io.Writer) (n int64, err error)\n```\n\nWriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the io.WriterTo interface. Any error encountered during the write is also returned. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.WriteByte",
                    "documentation": {
                      "identifier": "Buffer.WriteByte",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.WriteByte",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) WriteByte(c byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) WriteByte(c byte) error\n```\n\nWriteByte appends the byte c to the buffer, growing the buffer as needed. The returned error is always nil, but is included to match bufio.Writer's WriteByte. If the buffer becomes too large, WriteByte will panic with ErrTooLarge. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.WriteRune",
                    "documentation": {
                      "identifier": "Buffer.WriteRune",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.WriteRune",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) WriteRune(r rune) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) WriteRune(r rune) (n int, err error)\n```\n\nWriteRune appends the UTF-8 encoding of Unicode code point r to the buffer, returning its length and an error, which is always nil but is included to match bufio.Writer's WriteRune. The buffer is grown as needed; if it becomes too large, WriteRune will panic with ErrTooLarge. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.Read",
                    "documentation": {
                      "identifier": "Buffer.Read",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.Read",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) Read(p []byte) (n int, err error)\n```\n\nRead reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.Next",
                    "documentation": {
                      "identifier": "Buffer.Next",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.Next",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) Next(n int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) Next(n int) []byte\n```\n\nNext returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.ReadByte",
                    "documentation": {
                      "identifier": "Buffer.ReadByte",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.ReadByte",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) ReadByte() (byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) ReadByte() (byte, error)\n```\n\nReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.ReadRune",
                    "documentation": {
                      "identifier": "Buffer.ReadRune",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.ReadRune",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) ReadRune() (r rune, size int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) ReadRune() (r rune, size int, err error)\n```\n\nReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.UnreadRune",
                    "documentation": {
                      "identifier": "Buffer.UnreadRune",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.UnreadRune",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) UnreadRune() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) UnreadRune() error\n```\n\nUnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error.  (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.UnreadByte",
                    "documentation": {
                      "identifier": "Buffer.UnreadByte",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.UnreadByte",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) UnreadByte() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) UnreadByte() error\n```\n\nUnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.ReadBytes",
                    "documentation": {
                      "identifier": "Buffer.ReadBytes",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.ReadBytes",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) ReadBytes(delim byte) (line []byte, err error)\n```\n\nReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.readSlice",
                    "documentation": {
                      "identifier": "Buffer.readSlice",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.readSlice",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) readSlice(delim byte) (line []byte, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) readSlice(delim byte) (line []byte, err error)\n```\n\nreadSlice is like ReadBytes but returns a reference to internal buffer data. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Buffer.ReadString",
                    "documentation": {
                      "identifier": "Buffer.ReadString",
                      "newPage": false,
                      "searchKey": "bytes.Buffer.ReadString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Buffer) ReadString(delim byte) (line string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Buffer) ReadString(delim byte) (line string, err error)\n```\n\nReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#readOp",
              "documentation": {
                "identifier": "readOp",
                "newPage": false,
                "searchKey": "bytes.readOp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type readOp int8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readOp int8\n```\n\nThe readOp constants describe the last action performed on the buffer, so that UnreadRune and UnreadByte can check for invalid usage. opReadRuneX constants are chosen such that converted to int they correspond to the rune size that was read. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#asciiSet",
              "documentation": {
                "identifier": "asciiSet",
                "newPage": false,
                "searchKey": "bytes.asciiSet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type asciiSet [8]uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype asciiSet [8]uint32\n```\n\nasciiSet is a 32-byte value, where each bit represents the presence of a given ASCII character in the set. The 128-bits of the lower 16 bytes, starting with the least-significant bit of the lowest word to the most-significant bit of the highest word, map to the full range of all 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed, ensuring that any non-ASCII character will be reported as not in the set. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/bytes#makeASCIISet",
                    "documentation": {
                      "identifier": "makeASCIISet",
                      "newPage": false,
                      "searchKey": "bytes.makeASCIISet",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeASCIISet(chars string) (as asciiSet, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeASCIISet(chars string) (as asciiSet, ok bool)\n```\n\nmakeASCIISet creates a set of ASCII characters and reports whether all characters in chars are ASCII. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#asciiSet.contains",
                    "documentation": {
                      "identifier": "asciiSet.contains",
                      "newPage": false,
                      "searchKey": "bytes.asciiSet.contains",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (as *asciiSet) contains(c byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (as *asciiSet) contains(c byte) bool\n```\n\ncontains reports whether c is inside the set. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Reader",
              "documentation": {
                "identifier": "Reader",
                "newPage": false,
                "searchKey": "bytes.Reader",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Reader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Reader struct {\n\ts        []byte\n\ti        int64 // current reading index\n\tprevRune int   // index of previous rune; or < 0\n}\n```\n\nA Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker, io.ByteScanner, and io.RuneScanner interfaces by reading from a byte slice. Unlike a Buffer, a Reader is read-only and supports seeking. The zero value for Reader operates like a Reader of an empty slice. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/bytes#NewReader",
                    "documentation": {
                      "identifier": "NewReader",
                      "newPage": false,
                      "searchKey": "bytes.NewReader",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewReader(b []byte) *Reader"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewReader(b []byte) *Reader\n```\n\nNewReader returns a new Reader reading from b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.Len",
                    "documentation": {
                      "identifier": "Reader.Len",
                      "newPage": false,
                      "searchKey": "bytes.Reader.Len",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) Len() int\n```\n\nLen returns the number of bytes of the unread portion of the slice. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.Size",
                    "documentation": {
                      "identifier": "Reader.Size",
                      "newPage": false,
                      "searchKey": "bytes.Reader.Size",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) Size() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) Size() int64\n```\n\nSize returns the original length of the underlying byte slice. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.Read",
                    "documentation": {
                      "identifier": "Reader.Read",
                      "newPage": false,
                      "searchKey": "bytes.Reader.Read",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) Read(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) Read(b []byte) (n int, err error)\n```\n\nRead implements the io.Reader interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.ReadAt",
                    "documentation": {
                      "identifier": "Reader.ReadAt",
                      "newPage": false,
                      "searchKey": "bytes.Reader.ReadAt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) ReadAt(b []byte, off int64) (n int, err error)\n```\n\nReadAt implements the io.ReaderAt interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.ReadByte",
                    "documentation": {
                      "identifier": "Reader.ReadByte",
                      "newPage": false,
                      "searchKey": "bytes.Reader.ReadByte",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) ReadByte() (byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) ReadByte() (byte, error)\n```\n\nReadByte implements the io.ByteReader interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.UnreadByte",
                    "documentation": {
                      "identifier": "Reader.UnreadByte",
                      "newPage": false,
                      "searchKey": "bytes.Reader.UnreadByte",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) UnreadByte() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) UnreadByte() error\n```\n\nUnreadByte complements ReadByte in implementing the io.ByteScanner interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.ReadRune",
                    "documentation": {
                      "identifier": "Reader.ReadRune",
                      "newPage": false,
                      "searchKey": "bytes.Reader.ReadRune",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) ReadRune() (ch rune, size int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) ReadRune() (ch rune, size int, err error)\n```\n\nReadRune implements the io.RuneReader interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.UnreadRune",
                    "documentation": {
                      "identifier": "Reader.UnreadRune",
                      "newPage": false,
                      "searchKey": "bytes.Reader.UnreadRune",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) UnreadRune() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) UnreadRune() error\n```\n\nUnreadRune complements ReadRune in implementing the io.RuneScanner interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.Seek",
                    "documentation": {
                      "identifier": "Reader.Seek",
                      "newPage": false,
                      "searchKey": "bytes.Reader.Seek",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) Seek(offset int64, whence int) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) Seek(offset int64, whence int) (int64, error)\n```\n\nSeek implements the io.Seeker interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.WriteTo",
                    "documentation": {
                      "identifier": "Reader.WriteTo",
                      "newPage": false,
                      "searchKey": "bytes.Reader.WriteTo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) WriteTo(w io.Writer) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) WriteTo(w io.Writer) (n int64, err error)\n```\n\nWriteTo implements the io.WriterTo interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/bytes#Reader.Reset",
                    "documentation": {
                      "identifier": "Reader.Reset",
                      "newPage": false,
                      "searchKey": "bytes.Reader.Reset",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) Reset(b []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) Reset(b []byte)\n```\n\nReset resets the Reader to be reading from b. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/bytes#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/bytes#makeSlice",
              "documentation": {
                "identifier": "makeSlice",
                "newPage": false,
                "searchKey": "bytes.makeSlice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeSlice(n int) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeSlice(n int) []byte\n```\n\nmakeSlice allocates a slice of size n. If the allocation fails, it panics with ErrTooLarge. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Equal",
              "documentation": {
                "identifier": "Equal",
                "newPage": false,
                "searchKey": "bytes.Equal",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Equal(a, b []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Equal(a, b []byte) bool\n```\n\nEqual reports whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Compare",
              "documentation": {
                "identifier": "Compare",
                "newPage": false,
                "searchKey": "bytes.Compare",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Compare(a, b []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Compare(a, b []byte) int\n```\n\nCompare returns an integer comparing two byte slices lexicographically. The result will be 0 if a==b, -1 if a < b, and +1 if a > b. A nil argument is equivalent to an empty slice. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#explode",
              "documentation": {
                "identifier": "explode",
                "newPage": false,
                "searchKey": "bytes.explode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func explode(s []byte, n int) [][]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc explode(s []byte, n int) [][]byte\n```\n\nexplode splits s into a slice of UTF-8 sequences, one per Unicode code point (still slices of bytes), up to a maximum of n byte slices. Invalid UTF-8 sequences are chopped into individual bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Count",
              "documentation": {
                "identifier": "Count",
                "newPage": false,
                "searchKey": "bytes.Count",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Count(s, sep []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Count(s, sep []byte) int\n```\n\nCount counts the number of non-overlapping instances of sep in s. If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Contains",
              "documentation": {
                "identifier": "Contains",
                "newPage": false,
                "searchKey": "bytes.Contains",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Contains(b, subslice []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Contains(b, subslice []byte) bool\n```\n\nContains reports whether subslice is within b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ContainsAny",
              "documentation": {
                "identifier": "ContainsAny",
                "newPage": false,
                "searchKey": "bytes.ContainsAny",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ContainsAny(b []byte, chars string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ContainsAny(b []byte, chars string) bool\n```\n\nContainsAny reports whether any of the UTF-8-encoded code points in chars are within b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ContainsRune",
              "documentation": {
                "identifier": "ContainsRune",
                "newPage": false,
                "searchKey": "bytes.ContainsRune",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ContainsRune(b []byte, r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ContainsRune(b []byte, r rune) bool\n```\n\nContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#IndexByte",
              "documentation": {
                "identifier": "IndexByte",
                "newPage": false,
                "searchKey": "bytes.IndexByte",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IndexByte(b []byte, c byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IndexByte(b []byte, c byte) int\n```\n\nIndexByte returns the index of the first instance of c in b, or -1 if c is not present in b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#indexBytePortable",
              "documentation": {
                "identifier": "indexBytePortable",
                "newPage": false,
                "searchKey": "bytes.indexBytePortable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func indexBytePortable(s []byte, c byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc indexBytePortable(s []byte, c byte) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#LastIndex",
              "documentation": {
                "identifier": "LastIndex",
                "newPage": false,
                "searchKey": "bytes.LastIndex",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LastIndex(s, sep []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LastIndex(s, sep []byte) int\n```\n\nLastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#LastIndexByte",
              "documentation": {
                "identifier": "LastIndexByte",
                "newPage": false,
                "searchKey": "bytes.LastIndexByte",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LastIndexByte(s []byte, c byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LastIndexByte(s []byte, c byte) int\n```\n\nLastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#IndexRune",
              "documentation": {
                "identifier": "IndexRune",
                "newPage": false,
                "searchKey": "bytes.IndexRune",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IndexRune(s []byte, r rune) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IndexRune(s []byte, r rune) int\n```\n\nIndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#IndexAny",
              "documentation": {
                "identifier": "IndexAny",
                "newPage": false,
                "searchKey": "bytes.IndexAny",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IndexAny(s []byte, chars string) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IndexAny(s []byte, chars string) int\n```\n\nIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#LastIndexAny",
              "documentation": {
                "identifier": "LastIndexAny",
                "newPage": false,
                "searchKey": "bytes.LastIndexAny",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LastIndexAny(s []byte, chars string) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LastIndexAny(s []byte, chars string) int\n```\n\nLastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#genSplit",
              "documentation": {
                "identifier": "genSplit",
                "newPage": false,
                "searchKey": "bytes.genSplit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func genSplit(s, sep []byte, sepSave, n int) [][]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc genSplit(s, sep []byte, sepSave, n int) [][]byte\n```\n\nGeneric split: splits after each instance of sep, including sepSave bytes of sep in the subslices. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#SplitN",
              "documentation": {
                "identifier": "SplitN",
                "newPage": false,
                "searchKey": "bytes.SplitN",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SplitN(s, sep []byte, n int) [][]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SplitN(s, sep []byte, n int) [][]byte\n```\n\nSplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return: \n\n```\nn > 0: at most n subslices; the last subslice will be the unsplit remainder.\nn == 0: the result is nil (zero subslices)\nn < 0: all subslices\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#SplitAfterN",
              "documentation": {
                "identifier": "SplitAfterN",
                "newPage": false,
                "searchKey": "bytes.SplitAfterN",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SplitAfterN(s, sep []byte, n int) [][]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SplitAfterN(s, sep []byte, n int) [][]byte\n```\n\nSplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return: \n\n```\nn > 0: at most n subslices; the last subslice will be the unsplit remainder.\nn == 0: the result is nil (zero subslices)\nn < 0: all subslices\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Split",
              "documentation": {
                "identifier": "Split",
                "newPage": false,
                "searchKey": "bytes.Split",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Split(s, sep []byte) [][]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Split(s, sep []byte) [][]byte\n```\n\nSplit slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#SplitAfter",
              "documentation": {
                "identifier": "SplitAfter",
                "newPage": false,
                "searchKey": "bytes.SplitAfter",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SplitAfter(s, sep []byte) [][]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SplitAfter(s, sep []byte) [][]byte\n```\n\nSplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Fields",
              "documentation": {
                "identifier": "Fields",
                "newPage": false,
                "searchKey": "bytes.Fields",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Fields(s []byte) [][]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Fields(s []byte) [][]byte\n```\n\nFields interprets s as a sequence of UTF-8-encoded code points. It splits the slice s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an empty slice if s contains only white space. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#FieldsFunc",
              "documentation": {
                "identifier": "FieldsFunc",
                "newPage": false,
                "searchKey": "bytes.FieldsFunc",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func FieldsFunc(s []byte, f func(rune) bool) [][]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc FieldsFunc(s []byte, f func(rune) bool) [][]byte\n```\n\nFieldsFunc interprets s as a sequence of UTF-8-encoded code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If all code points in s satisfy f(c), or len(s) == 0, an empty slice is returned. \n\nFieldsFunc makes no guarantees about the order in which it calls f(c) and assumes that f always returns the same value for a given c. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Join",
              "documentation": {
                "identifier": "Join",
                "newPage": false,
                "searchKey": "bytes.Join",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Join(s [][]byte, sep []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Join(s [][]byte, sep []byte) []byte\n```\n\nJoin concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#HasPrefix",
              "documentation": {
                "identifier": "HasPrefix",
                "newPage": false,
                "searchKey": "bytes.HasPrefix",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HasPrefix(s, prefix []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HasPrefix(s, prefix []byte) bool\n```\n\nHasPrefix tests whether the byte slice s begins with prefix. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#HasSuffix",
              "documentation": {
                "identifier": "HasSuffix",
                "newPage": false,
                "searchKey": "bytes.HasSuffix",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HasSuffix(s, suffix []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HasSuffix(s, suffix []byte) bool\n```\n\nHasSuffix tests whether the byte slice s ends with suffix. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Map",
              "documentation": {
                "identifier": "Map",
                "newPage": false,
                "searchKey": "bytes.Map",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Map(mapping func(r rune) rune, s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Map(mapping func(r rune) rune, s []byte) []byte\n```\n\nMap returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Repeat",
              "documentation": {
                "identifier": "Repeat",
                "newPage": false,
                "searchKey": "bytes.Repeat",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Repeat(b []byte, count int) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Repeat(b []byte, count int) []byte\n```\n\nRepeat returns a new byte slice consisting of count copies of b. \n\nIt panics if count is negative or if the result of (len(b) * count) overflows. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ToUpper",
              "documentation": {
                "identifier": "ToUpper",
                "newPage": false,
                "searchKey": "bytes.ToUpper",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ToUpper(s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ToUpper(s []byte) []byte\n```\n\nToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ToLower",
              "documentation": {
                "identifier": "ToLower",
                "newPage": false,
                "searchKey": "bytes.ToLower",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ToLower(s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ToLower(s []byte) []byte\n```\n\nToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ToTitle",
              "documentation": {
                "identifier": "ToTitle",
                "newPage": false,
                "searchKey": "bytes.ToTitle",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ToTitle(s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ToTitle(s []byte) []byte\n```\n\nToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ToUpperSpecial",
              "documentation": {
                "identifier": "ToUpperSpecial",
                "newPage": false,
                "searchKey": "bytes.ToUpperSpecial",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte\n```\n\nToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ToLowerSpecial",
              "documentation": {
                "identifier": "ToLowerSpecial",
                "newPage": false,
                "searchKey": "bytes.ToLowerSpecial",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte\n```\n\nToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ToTitleSpecial",
              "documentation": {
                "identifier": "ToTitleSpecial",
                "newPage": false,
                "searchKey": "bytes.ToTitleSpecial",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte\n```\n\nToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ToValidUTF8",
              "documentation": {
                "identifier": "ToValidUTF8",
                "newPage": false,
                "searchKey": "bytes.ToValidUTF8",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ToValidUTF8(s, replacement []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ToValidUTF8(s, replacement []byte) []byte\n```\n\nToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#isSeparator",
              "documentation": {
                "identifier": "isSeparator",
                "newPage": false,
                "searchKey": "bytes.isSeparator",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSeparator(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSeparator(r rune) bool\n```\n\nisSeparator reports whether the rune could mark a word boundary. TODO: update when package unicode captures more of the properties. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Title",
              "documentation": {
                "identifier": "Title",
                "newPage": false,
                "searchKey": "bytes.Title",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Title(s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Title(s []byte) []byte\n```\n\nTitle treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case. \n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#TrimLeftFunc",
              "documentation": {
                "identifier": "TrimLeftFunc",
                "newPage": false,
                "searchKey": "bytes.TrimLeftFunc",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TrimLeftFunc(s []byte, f func(r rune) bool) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TrimLeftFunc(s []byte, f func(r rune) bool) []byte\n```\n\nTrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#TrimRightFunc",
              "documentation": {
                "identifier": "TrimRightFunc",
                "newPage": false,
                "searchKey": "bytes.TrimRightFunc",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TrimRightFunc(s []byte, f func(r rune) bool) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TrimRightFunc(s []byte, f func(r rune) bool) []byte\n```\n\nTrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#TrimFunc",
              "documentation": {
                "identifier": "TrimFunc",
                "newPage": false,
                "searchKey": "bytes.TrimFunc",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TrimFunc(s []byte, f func(r rune) bool) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TrimFunc(s []byte, f func(r rune) bool) []byte\n```\n\nTrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#TrimPrefix",
              "documentation": {
                "identifier": "TrimPrefix",
                "newPage": false,
                "searchKey": "bytes.TrimPrefix",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TrimPrefix(s, prefix []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TrimPrefix(s, prefix []byte) []byte\n```\n\nTrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#TrimSuffix",
              "documentation": {
                "identifier": "TrimSuffix",
                "newPage": false,
                "searchKey": "bytes.TrimSuffix",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TrimSuffix(s, suffix []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TrimSuffix(s, suffix []byte) []byte\n```\n\nTrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#IndexFunc",
              "documentation": {
                "identifier": "IndexFunc",
                "newPage": false,
                "searchKey": "bytes.IndexFunc",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IndexFunc(s []byte, f func(r rune) bool) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IndexFunc(s []byte, f func(r rune) bool) int\n```\n\nIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#LastIndexFunc",
              "documentation": {
                "identifier": "LastIndexFunc",
                "newPage": false,
                "searchKey": "bytes.LastIndexFunc",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LastIndexFunc(s []byte, f func(r rune) bool) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LastIndexFunc(s []byte, f func(r rune) bool) int\n```\n\nLastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#indexFunc",
              "documentation": {
                "identifier": "indexFunc",
                "newPage": false,
                "searchKey": "bytes.indexFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func indexFunc(s []byte, f func(r rune) bool, truth bool) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc indexFunc(s []byte, f func(r rune) bool, truth bool) int\n```\n\nindexFunc is the same as IndexFunc except that if truth==false, the sense of the predicate function is inverted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#lastIndexFunc",
              "documentation": {
                "identifier": "lastIndexFunc",
                "newPage": false,
                "searchKey": "bytes.lastIndexFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int\n```\n\nlastIndexFunc is the same as LastIndexFunc except that if truth==false, the sense of the predicate function is inverted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#makeCutsetFunc",
              "documentation": {
                "identifier": "makeCutsetFunc",
                "newPage": false,
                "searchKey": "bytes.makeCutsetFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeCutsetFunc(cutset string) func(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeCutsetFunc(cutset string) func(r rune) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Trim",
              "documentation": {
                "identifier": "Trim",
                "newPage": false,
                "searchKey": "bytes.Trim",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Trim(s []byte, cutset string) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Trim(s []byte, cutset string) []byte\n```\n\nTrim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#TrimLeft",
              "documentation": {
                "identifier": "TrimLeft",
                "newPage": false,
                "searchKey": "bytes.TrimLeft",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TrimLeft(s []byte, cutset string) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TrimLeft(s []byte, cutset string) []byte\n```\n\nTrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#TrimRight",
              "documentation": {
                "identifier": "TrimRight",
                "newPage": false,
                "searchKey": "bytes.TrimRight",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TrimRight(s []byte, cutset string) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TrimRight(s []byte, cutset string) []byte\n```\n\nTrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#TrimSpace",
              "documentation": {
                "identifier": "TrimSpace",
                "newPage": false,
                "searchKey": "bytes.TrimSpace",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TrimSpace(s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TrimSpace(s []byte) []byte\n```\n\nTrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Runes",
              "documentation": {
                "identifier": "Runes",
                "newPage": false,
                "searchKey": "bytes.Runes",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Runes(s []byte) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Runes(s []byte) []rune\n```\n\nRunes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Replace",
              "documentation": {
                "identifier": "Replace",
                "newPage": false,
                "searchKey": "bytes.Replace",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Replace(s, old, new []byte, n int) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Replace(s, old, new []byte, n int) []byte\n```\n\nReplace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n < 0, there is no limit on the number of replacements. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#ReplaceAll",
              "documentation": {
                "identifier": "ReplaceAll",
                "newPage": false,
                "searchKey": "bytes.ReplaceAll",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ReplaceAll(s, old, new []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ReplaceAll(s, old, new []byte) []byte\n```\n\nReplaceAll returns a copy of the slice s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#EqualFold",
              "documentation": {
                "identifier": "EqualFold",
                "newPage": false,
                "searchKey": "bytes.EqualFold",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func EqualFold(s, t []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc EqualFold(s, t []byte) bool\n```\n\nEqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding, which is a more general form of case-insensitivity. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/bytes#Index",
              "documentation": {
                "identifier": "Index",
                "newPage": false,
                "searchKey": "bytes.Index",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Index(s, sep []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Index(s, sep []byte) int\n```\n\nIndex returns the index of the first instance of sep in s, or -1 if sep is not present in s. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
