{
  "pathID": "/std/compress/flate",
  "documentation": {
    "identifier": "flate",
    "newPage": true,
    "searchKey": "std/compress/flate",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package flate"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package flate implements the DEFLATE compressed data format, described in RFC 1951.  The gzip and zlib packages implement access to DEFLATE-based file formats. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/std/compress/flate#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/compress/flate#NoCompression",
              "documentation": {
                "identifier": "NoCompression",
                "newPage": false,
                "searchKey": "flate.NoCompression",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const NoCompression"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst NoCompression = 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#BestSpeed",
              "documentation": {
                "identifier": "BestSpeed",
                "newPage": false,
                "searchKey": "flate.BestSpeed",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const BestSpeed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst BestSpeed = 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#BestCompression",
              "documentation": {
                "identifier": "BestCompression",
                "newPage": false,
                "searchKey": "flate.BestCompression",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const BestCompression"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst BestCompression = 9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#DefaultCompression",
              "documentation": {
                "identifier": "DefaultCompression",
                "newPage": false,
                "searchKey": "flate.DefaultCompression",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const DefaultCompression"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DefaultCompression = -1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#HuffmanOnly",
              "documentation": {
                "identifier": "HuffmanOnly",
                "newPage": false,
                "searchKey": "flate.HuffmanOnly",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const HuffmanOnly"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst HuffmanOnly = -2\n```\n\nHuffmanOnly disables Lempel-Ziv match searching and only performs Huffman entropy encoding. This mode is useful in compressing data that has already been compressed with an LZ style algorithm (e.g. Snappy or LZ4) that lacks an entropy encoder. Compression gains are achieved when certain bytes in the input stream occur more frequently than others. \n\nNote that HuffmanOnly produces a compressed output that is RFC 1951 compliant. That is, any valid DEFLATE decompressor will continue to be able to decompress this output. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#logWindowSize",
              "documentation": {
                "identifier": "logWindowSize",
                "newPage": false,
                "searchKey": "flate.logWindowSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const logWindowSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst logWindowSize = 15\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#windowSize",
              "documentation": {
                "identifier": "windowSize",
                "newPage": false,
                "searchKey": "flate.windowSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const windowSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst windowSize = 1 << logWindowSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#windowMask",
              "documentation": {
                "identifier": "windowMask",
                "newPage": false,
                "searchKey": "flate.windowMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const windowMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst windowMask = windowSize - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#baseMatchLength",
              "documentation": {
                "identifier": "baseMatchLength",
                "newPage": false,
                "searchKey": "flate.baseMatchLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const baseMatchLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst baseMatchLength = 3 // The smallest match length per the RFC section 3.2.5\n\n```\n\nThe LZ77 step produces a sequence of literal tokens and <length, offset> pair tokens. The offset is also known as distance. The underlying wire format limits the range of lengths and offsets. For example, there are 256 legitimate lengths: those in the range [3, 258]. This package's compressor uses a higher minimum match length, enabling optimizations such as finding matches via 32-bit loads and compares. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#minMatchLength",
              "documentation": {
                "identifier": "minMatchLength",
                "newPage": false,
                "searchKey": "flate.minMatchLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const minMatchLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minMatchLength = 4 // The smallest match length that the compressor actually emits\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#maxMatchLength",
              "documentation": {
                "identifier": "maxMatchLength",
                "newPage": false,
                "searchKey": "flate.maxMatchLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxMatchLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxMatchLength = 258 // The largest match length\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#baseMatchOffset",
              "documentation": {
                "identifier": "baseMatchOffset",
                "newPage": false,
                "searchKey": "flate.baseMatchOffset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const baseMatchOffset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst baseMatchOffset = 1 // The smallest match offset\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#maxMatchOffset",
              "documentation": {
                "identifier": "maxMatchOffset",
                "newPage": false,
                "searchKey": "flate.maxMatchOffset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxMatchOffset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxMatchOffset = 1 << 15 // The largest match offset\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#maxFlateBlockTokens",
              "documentation": {
                "identifier": "maxFlateBlockTokens",
                "newPage": false,
                "searchKey": "flate.maxFlateBlockTokens",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxFlateBlockTokens"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxFlateBlockTokens = 1 << 14\n```\n\nThe maximum number of tokens we put into a single flate block, just to stop things from getting too large. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#maxStoreBlockSize",
              "documentation": {
                "identifier": "maxStoreBlockSize",
                "newPage": false,
                "searchKey": "flate.maxStoreBlockSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxStoreBlockSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxStoreBlockSize = 65535\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#hashBits",
              "documentation": {
                "identifier": "hashBits",
                "newPage": false,
                "searchKey": "flate.hashBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hashBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hashBits = 17 // After 17 performance degrades\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#hashSize",
              "documentation": {
                "identifier": "hashSize",
                "newPage": false,
                "searchKey": "flate.hashSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hashSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hashSize = 1 << hashBits\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#hashMask",
              "documentation": {
                "identifier": "hashMask",
                "newPage": false,
                "searchKey": "flate.hashMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hashMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hashMask = (1 << hashBits) - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#maxHashOffset",
              "documentation": {
                "identifier": "maxHashOffset",
                "newPage": false,
                "searchKey": "flate.maxHashOffset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxHashOffset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxHashOffset = 1 << 24\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#skipNever",
              "documentation": {
                "identifier": "skipNever",
                "newPage": false,
                "searchKey": "flate.skipNever",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const skipNever"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst skipNever = math.MaxInt32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#hashmul",
              "documentation": {
                "identifier": "hashmul",
                "newPage": false,
                "searchKey": "flate.hashmul",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hashmul"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hashmul = 0x1e35a7bd\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#tableBits",
              "documentation": {
                "identifier": "tableBits",
                "newPage": false,
                "searchKey": "flate.tableBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tableBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tableBits = 14 // Bits used in the table.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#tableSize",
              "documentation": {
                "identifier": "tableSize",
                "newPage": false,
                "searchKey": "flate.tableSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tableSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tableSize = 1 << tableBits // Size of the table.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#tableMask",
              "documentation": {
                "identifier": "tableMask",
                "newPage": false,
                "searchKey": "flate.tableMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tableMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tableMask // Mask for table indices. Redundant, but can eliminate bounds checks.\n = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#tableShift",
              "documentation": {
                "identifier": "tableShift",
                "newPage": false,
                "searchKey": "flate.tableShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tableShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tableShift // Right-shift to get the tableBits most significant bits of a uint32.\n = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#bufferReset",
              "documentation": {
                "identifier": "bufferReset",
                "newPage": false,
                "searchKey": "flate.bufferReset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bufferReset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bufferReset = math.MaxInt32 - maxStoreBlockSize*2\n```\n\nReset the buffer offset when reaching this. Offsets are stored between blocks as int32 values. Since the offset we are checking against is at the beginning of the buffer, we need to subtract the current and input buffer to not risk overflowing the int32. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#inputMargin",
              "documentation": {
                "identifier": "inputMargin",
                "newPage": false,
                "searchKey": "flate.inputMargin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const inputMargin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst inputMargin = 16 - 1\n```\n\nThese constants are defined by the Snappy implementation so that its assembly implementation can fast-path some 16-bytes-at-a-time copies. They aren't necessary in the pure Go implementation, as we don't use those same optimizations, but using the same thresholds doesn't really hurt. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#minNonLiteralBlockSize",
              "documentation": {
                "identifier": "minNonLiteralBlockSize",
                "newPage": false,
                "searchKey": "flate.minNonLiteralBlockSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const minNonLiteralBlockSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minNonLiteralBlockSize = 1 + 1 + inputMargin\n```\n\nThese constants are defined by the Snappy implementation so that its assembly implementation can fast-path some 16-bytes-at-a-time copies. They aren't necessary in the pure Go implementation, as we don't use those same optimizations, but using the same thresholds doesn't really hurt. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#offsetCodeCount",
              "documentation": {
                "identifier": "offsetCodeCount",
                "newPage": false,
                "searchKey": "flate.offsetCodeCount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const offsetCodeCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst offsetCodeCount = 30\n```\n\nThe largest offset code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#endBlockMarker",
              "documentation": {
                "identifier": "endBlockMarker",
                "newPage": false,
                "searchKey": "flate.endBlockMarker",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const endBlockMarker"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst endBlockMarker = 256\n```\n\nThe special code used to mark the end of a block. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#lengthCodesStart",
              "documentation": {
                "identifier": "lengthCodesStart",
                "newPage": false,
                "searchKey": "flate.lengthCodesStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lengthCodesStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lengthCodesStart = 257\n```\n\nThe first length code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#codegenCodeCount",
              "documentation": {
                "identifier": "codegenCodeCount",
                "newPage": false,
                "searchKey": "flate.codegenCodeCount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const codegenCodeCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst codegenCodeCount = 19\n```\n\nThe number of codegen codes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#badCode",
              "documentation": {
                "identifier": "badCode",
                "newPage": false,
                "searchKey": "flate.badCode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const badCode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst badCode = 255\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#bufferFlushSize",
              "documentation": {
                "identifier": "bufferFlushSize",
                "newPage": false,
                "searchKey": "flate.bufferFlushSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bufferFlushSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bufferFlushSize = 240\n```\n\nbufferFlushSize indicates the buffer size after which bytes are flushed to the writer. Should preferably be a multiple of 6, since we accumulate 6 bytes between writes to the buffer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#bufferSize",
              "documentation": {
                "identifier": "bufferSize",
                "newPage": false,
                "searchKey": "flate.bufferSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bufferSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bufferSize = bufferFlushSize + 8\n```\n\nbufferSize is the actual output byte buffer size. It must have additional headroom for a flush which can contain up to 8 bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#maxBitsLimit",
              "documentation": {
                "identifier": "maxBitsLimit",
                "newPage": false,
                "searchKey": "flate.maxBitsLimit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxBitsLimit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxBitsLimit = 16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#maxCodeLen",
              "documentation": {
                "identifier": "maxCodeLen",
                "newPage": false,
                "searchKey": "flate.maxCodeLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxCodeLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxCodeLen = 16 // max length of Huffman code\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#maxNumLit",
              "documentation": {
                "identifier": "maxNumLit",
                "newPage": false,
                "searchKey": "flate.maxNumLit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxNumLit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxNumLit = 286\n```\n\nThe next three numbers come from the RFC section 3.2.7, with the additional proviso in section 3.2.5 which implies that distance codes 30 and 31 should never occur in compressed data. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#maxNumDist",
              "documentation": {
                "identifier": "maxNumDist",
                "newPage": false,
                "searchKey": "flate.maxNumDist",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxNumDist"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxNumDist = 30\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#numCodes",
              "documentation": {
                "identifier": "numCodes",
                "newPage": false,
                "searchKey": "flate.numCodes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const numCodes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst numCodes = 19 // number of codes in Huffman meta-code\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#huffmanChunkBits",
              "documentation": {
                "identifier": "huffmanChunkBits",
                "newPage": false,
                "searchKey": "flate.huffmanChunkBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const huffmanChunkBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst huffmanChunkBits = 9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#huffmanNumChunks",
              "documentation": {
                "identifier": "huffmanNumChunks",
                "newPage": false,
                "searchKey": "flate.huffmanNumChunks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const huffmanNumChunks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst huffmanNumChunks = 1 << huffmanChunkBits\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#huffmanCountMask",
              "documentation": {
                "identifier": "huffmanCountMask",
                "newPage": false,
                "searchKey": "flate.huffmanCountMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const huffmanCountMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst huffmanCountMask = 15\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#huffmanValueShift",
              "documentation": {
                "identifier": "huffmanValueShift",
                "newPage": false,
                "searchKey": "flate.huffmanValueShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const huffmanValueShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst huffmanValueShift = 4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#lengthShift",
              "documentation": {
                "identifier": "lengthShift",
                "newPage": false,
                "searchKey": "flate.lengthShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lengthShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lengthShift = 22\n```\n\n2 bits:   type   0 = literal  1=EOF  2=Match   3=Unused 8 bits:   xlength = length - MIN_MATCH_LENGTH 22 bits   xoffset = offset - MIN_OFFSET_SIZE, or literal \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#offsetMask",
              "documentation": {
                "identifier": "offsetMask",
                "newPage": false,
                "searchKey": "flate.offsetMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const offsetMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst offsetMask = 1<<lengthShift - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#typeMask",
              "documentation": {
                "identifier": "typeMask",
                "newPage": false,
                "searchKey": "flate.typeMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeMask = 3 << 30\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#literalType",
              "documentation": {
                "identifier": "literalType",
                "newPage": false,
                "searchKey": "flate.literalType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const literalType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst literalType = 0 << 30\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#matchType",
              "documentation": {
                "identifier": "matchType",
                "newPage": false,
                "searchKey": "flate.matchType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const matchType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst matchType = 1 << 30\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#ml",
              "documentation": {
                "identifier": "ml",
                "newPage": false,
                "searchKey": "flate.ml",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ml"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ml = 0x7fc00000 // Maximum length token. Used to reduce the size of writeBlockTests\n\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/compress/flate#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/compress/flate#levels",
              "documentation": {
                "identifier": "levels",
                "newPage": false,
                "searchKey": "flate.levels",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var levels"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar levels = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#lengthExtraBits",
              "documentation": {
                "identifier": "lengthExtraBits",
                "newPage": false,
                "searchKey": "flate.lengthExtraBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lengthExtraBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lengthExtraBits = ...\n```\n\nThe number of extra bits needed by length code X - LENGTH_CODES_START. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#lengthBase",
              "documentation": {
                "identifier": "lengthBase",
                "newPage": false,
                "searchKey": "flate.lengthBase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lengthBase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lengthBase = ...\n```\n\nThe length indicated by length code X - LENGTH_CODES_START. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#offsetExtraBits",
              "documentation": {
                "identifier": "offsetExtraBits",
                "newPage": false,
                "searchKey": "flate.offsetExtraBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var offsetExtraBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar offsetExtraBits = ...\n```\n\noffset code word extra bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#offsetBase",
              "documentation": {
                "identifier": "offsetBase",
                "newPage": false,
                "searchKey": "flate.offsetBase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var offsetBase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar offsetBase = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#codegenOrder",
              "documentation": {
                "identifier": "codegenOrder",
                "newPage": false,
                "searchKey": "flate.codegenOrder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var codegenOrder"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar codegenOrder = []uint32{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15}\n```\n\nThe odd order in which the codegen code sizes are written. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#huffOffset",
              "documentation": {
                "identifier": "huffOffset",
                "newPage": false,
                "searchKey": "flate.huffOffset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var huffOffset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar huffOffset *huffmanEncoder\n```\n\nhuffOffset is a static offset encoder used for huffman only encoding. It can be reused since we will not be encoding offset values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#fixedLiteralEncoding",
              "documentation": {
                "identifier": "fixedLiteralEncoding",
                "newPage": false,
                "searchKey": "flate.fixedLiteralEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fixedLiteralEncoding"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fixedLiteralEncoding *huffmanEncoder = generateFixedLiteralEncoding()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#fixedOffsetEncoding",
              "documentation": {
                "identifier": "fixedOffsetEncoding",
                "newPage": false,
                "searchKey": "flate.fixedOffsetEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fixedOffsetEncoding"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fixedOffsetEncoding *huffmanEncoder = generateFixedOffsetEncoding()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#fixedOnce",
              "documentation": {
                "identifier": "fixedOnce",
                "newPage": false,
                "searchKey": "flate.fixedOnce",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fixedOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fixedOnce sync.Once\n```\n\nInitialize the fixedHuffmanDecoder only once upon first use. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#fixedHuffmanDecoder",
              "documentation": {
                "identifier": "fixedHuffmanDecoder",
                "newPage": false,
                "searchKey": "flate.fixedHuffmanDecoder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fixedHuffmanDecoder"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fixedHuffmanDecoder huffmanDecoder\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#codeOrder",
              "documentation": {
                "identifier": "codeOrder",
                "newPage": false,
                "searchKey": "flate.codeOrder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var codeOrder"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar codeOrder = [...]int{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#lengthCodes",
              "documentation": {
                "identifier": "lengthCodes",
                "newPage": false,
                "searchKey": "flate.lengthCodes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lengthCodes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lengthCodes = ...\n```\n\nThe length code for length X (MIN_MATCH_LENGTH <= X <= MAX_MATCH_LENGTH) is lengthCodes[length - MIN_MATCH_LENGTH] \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#offsetCodes",
              "documentation": {
                "identifier": "offsetCodes",
                "newPage": false,
                "searchKey": "flate.offsetCodes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var offsetCodes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar offsetCodes = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#deflateTests",
              "documentation": {
                "identifier": "deflateTests",
                "newPage": false,
                "searchKey": "flate.deflateTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var deflateTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar deflateTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#deflateInflateTests",
              "documentation": {
                "identifier": "deflateInflateTests",
                "newPage": false,
                "searchKey": "flate.deflateInflateTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var deflateInflateTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar deflateInflateTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#reverseBitsTests",
              "documentation": {
                "identifier": "reverseBitsTests",
                "newPage": false,
                "searchKey": "flate.reverseBitsTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var reverseBitsTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar reverseBitsTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#deflateInflateStringTests",
              "documentation": {
                "identifier": "deflateInflateStringTests",
                "newPage": false,
                "searchKey": "flate.deflateInflateStringTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var deflateInflateStringTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar deflateInflateStringTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#errIO",
              "documentation": {
                "identifier": "errIO",
                "newPage": false,
                "searchKey": "flate.errIO",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errIO"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errIO = errors.New(\"IO error\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#update",
              "documentation": {
                "identifier": "update",
                "newPage": false,
                "searchKey": "flate.update",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var update"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar update = flag.Bool(\"update\", false, \"update reference files\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#writeBlockTests",
              "documentation": {
                "identifier": "writeBlockTests",
                "newPage": false,
                "searchKey": "flate.writeBlockTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var writeBlockTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar writeBlockTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#suites",
              "documentation": {
                "identifier": "suites",
                "newPage": false,
                "searchKey": "flate.suites",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var suites"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar suites = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#levelTests",
              "documentation": {
                "identifier": "levelTests",
                "newPage": false,
                "searchKey": "flate.levelTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var levelTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar levelTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#sizes",
              "documentation": {
                "identifier": "sizes",
                "newPage": false,
                "searchKey": "flate.sizes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sizes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sizes = []struct {\n\tname string\n\tn    int\n}{\n\t{\"1e4\", 1e4},\n\t{\"1e5\", 1e5},\n\t{\"1e6\", 1e6},\n}\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/compress/flate#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/compress/flate#compressionLevel",
              "documentation": {
                "identifier": "compressionLevel",
                "newPage": false,
                "searchKey": "flate.compressionLevel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type compressionLevel struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype compressionLevel struct {\n\tlevel, good, lazy, nice, chain, fastSkipHashing int\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#compressor",
              "documentation": {
                "identifier": "compressor",
                "newPage": false,
                "searchKey": "flate.compressor",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type compressor struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype compressor struct {\n\tcompressionLevel\n\n\tw          *huffmanBitWriter\n\tbulkHasher func([]byte, []uint32)\n\n\t// compression algorithm\n\tfill      func(*compressor, []byte) int // copy data to window\n\tstep      func(*compressor)             // process window\n\tsync      bool                          // requesting flush\n\tbestSpeed *deflateFast                  // Encoder for BestSpeed\n\n\t// Input hash chains\n\t// hashHead[hashValue] contains the largest inputIndex with the specified hash value\n\t// If hashHead[hashValue] is within the current window, then\n\t// hashPrev[hashHead[hashValue] & windowMask] contains the previous index\n\t// with the same hash value.\n\tchainHead  int\n\thashHead   [hashSize]uint32\n\thashPrev   [windowSize]uint32\n\thashOffset int\n\n\t// input window: unprocessed data is window[index:windowEnd]\n\tindex         int\n\twindow        []byte\n\twindowEnd     int\n\tblockStart    int  // window index where current tokens start\n\tbyteAvailable bool // if true, still need to process window[index-1].\n\n\t// queued output tokens\n\ttokens []token\n\n\t// deflate state\n\tlength         int\n\toffset         int\n\thash           uint32\n\tmaxInsertIndex int\n\terr            error\n\n\t// hashMatch must be able to contain hashes for the maximum match length.\n\thashMatch [maxMatchLength - 1]uint32\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.fillDeflate",
                    "documentation": {
                      "identifier": "compressor.fillDeflate",
                      "newPage": false,
                      "searchKey": "flate.compressor.fillDeflate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) fillDeflate(b []byte) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) fillDeflate(b []byte) int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.writeBlock",
                    "documentation": {
                      "identifier": "compressor.writeBlock",
                      "newPage": false,
                      "searchKey": "flate.compressor.writeBlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) writeBlock(tokens []token, index int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) writeBlock(tokens []token, index int) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.fillWindow",
                    "documentation": {
                      "identifier": "compressor.fillWindow",
                      "newPage": false,
                      "searchKey": "flate.compressor.fillWindow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) fillWindow(b []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) fillWindow(b []byte)\n```\n\nfillWindow will fill the current window with the supplied dictionary and calculate all hashes. This is much faster than doing a full encode. Should only be used after a reset. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.findMatch",
                    "documentation": {
                      "identifier": "compressor.findMatch",
                      "newPage": false,
                      "searchKey": "flate.compressor.findMatch",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead int) (length, offset int, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead int) (length, offset int, ok bool)\n```\n\nTry to find a match starting at index whose length is greater than prevSize. We only look at chainCount possibilities before giving up. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.writeStoredBlock",
                    "documentation": {
                      "identifier": "compressor.writeStoredBlock",
                      "newPage": false,
                      "searchKey": "flate.compressor.writeStoredBlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) writeStoredBlock(buf []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) writeStoredBlock(buf []byte) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.encSpeed",
                    "documentation": {
                      "identifier": "compressor.encSpeed",
                      "newPage": false,
                      "searchKey": "flate.compressor.encSpeed",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) encSpeed()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) encSpeed()\n```\n\nencSpeed will compress and store the currently added data, if enough has been accumulated or we at the end of the stream. Any error that occurred will be in d.err \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.initDeflate",
                    "documentation": {
                      "identifier": "compressor.initDeflate",
                      "newPage": false,
                      "searchKey": "flate.compressor.initDeflate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) initDeflate()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) initDeflate()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.deflate",
                    "documentation": {
                      "identifier": "compressor.deflate",
                      "newPage": false,
                      "searchKey": "flate.compressor.deflate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) deflate()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) deflate()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.fillStore",
                    "documentation": {
                      "identifier": "compressor.fillStore",
                      "newPage": false,
                      "searchKey": "flate.compressor.fillStore",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) fillStore(b []byte) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) fillStore(b []byte) int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.store",
                    "documentation": {
                      "identifier": "compressor.store",
                      "newPage": false,
                      "searchKey": "flate.compressor.store",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) store()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) store()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.storeHuff",
                    "documentation": {
                      "identifier": "compressor.storeHuff",
                      "newPage": false,
                      "searchKey": "flate.compressor.storeHuff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) storeHuff()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) storeHuff()\n```\n\nstoreHuff compresses and stores the currently added data when the d.window is full or we are at the end of the stream. Any error that occurred will be in d.err \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.write",
                    "documentation": {
                      "identifier": "compressor.write",
                      "newPage": false,
                      "searchKey": "flate.compressor.write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) write(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.syncFlush",
                    "documentation": {
                      "identifier": "compressor.syncFlush",
                      "newPage": false,
                      "searchKey": "flate.compressor.syncFlush",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) syncFlush() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) syncFlush() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.init",
                    "documentation": {
                      "identifier": "compressor.init",
                      "newPage": false,
                      "searchKey": "flate.compressor.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) init(w io.Writer, level int) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) init(w io.Writer, level int) (err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.reset",
                    "documentation": {
                      "identifier": "compressor.reset",
                      "newPage": false,
                      "searchKey": "flate.compressor.reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) reset(w io.Writer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) reset(w io.Writer)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#compressor.close",
                    "documentation": {
                      "identifier": "compressor.close",
                      "newPage": false,
                      "searchKey": "flate.compressor.close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *compressor) close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *compressor) close() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#dictWriter",
              "documentation": {
                "identifier": "dictWriter",
                "newPage": false,
                "searchKey": "flate.dictWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dictWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dictWriter struct {\n\tw io.Writer\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictWriter.Write",
                    "documentation": {
                      "identifier": "dictWriter.Write",
                      "newPage": false,
                      "searchKey": "flate.dictWriter.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *dictWriter) Write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *dictWriter) Write(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#Writer",
              "documentation": {
                "identifier": "Writer",
                "newPage": false,
                "searchKey": "flate.Writer",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Writer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Writer struct {\n\td    compressor\n\tdict []byte\n}\n```\n\nA Writer takes data written to it and writes the compressed form of that data to an underlying writer (see NewWriter). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#NewWriter",
                    "documentation": {
                      "identifier": "NewWriter",
                      "newPage": false,
                      "searchKey": "flate.NewWriter",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewWriter(w io.Writer, level int) (*Writer, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewWriter(w io.Writer, level int) (*Writer, error)\n```\n\nNewWriter returns a new Writer compressing data at the given level. Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression); higher levels typically run slower but compress more. Level 0 (NoCompression) does not attempt any compression; it only adds the necessary DEFLATE framing. Level -1 (DefaultCompression) uses the default compression level. Level -2 (HuffmanOnly) will use Huffman compression only, giving a very fast compression for all types of input, but sacrificing considerable compression efficiency. \n\nIf level is in the range [-2, 9] then the error returned will be nil. Otherwise the error returned will be non-nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#NewWriterDict",
                    "documentation": {
                      "identifier": "NewWriterDict",
                      "newPage": false,
                      "searchKey": "flate.NewWriterDict",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)\n```\n\nNewWriterDict is like NewWriter but initializes the new Writer with a preset dictionary. The returned Writer behaves as if the dictionary had been written to it without producing any compressed output. The compressed data written to w can only be decompressed by a Reader initialized with the same dictionary. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#Writer.Write",
                    "documentation": {
                      "identifier": "Writer.Write",
                      "newPage": false,
                      "searchKey": "flate.Writer.Write",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *Writer) Write(data []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *Writer) Write(data []byte) (n int, err error)\n```\n\nWrite writes data to w, which will eventually write the compressed form of data to its underlying writer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#Writer.Flush",
                    "documentation": {
                      "identifier": "Writer.Flush",
                      "newPage": false,
                      "searchKey": "flate.Writer.Flush",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *Writer) Flush() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *Writer) Flush() error\n```\n\nFlush flushes any pending data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. Calling Flush when there is no pending data still causes the Writer to emit a sync marker of at least 4 bytes. If the underlying writer returns an error, Flush returns that error. \n\nIn the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#Writer.Close",
                    "documentation": {
                      "identifier": "Writer.Close",
                      "newPage": false,
                      "searchKey": "flate.Writer.Close",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *Writer) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *Writer) Close() error\n```\n\nClose flushes and closes the writer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#Writer.Reset",
                    "documentation": {
                      "identifier": "Writer.Reset",
                      "newPage": false,
                      "searchKey": "flate.Writer.Reset",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *Writer) Reset(dst io.Writer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *Writer) Reset(dst io.Writer)\n```\n\nReset discards the writer's state and makes it equivalent to the result of NewWriter or NewWriterDict called with dst and w's level and dictionary. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#tableEntry",
              "documentation": {
                "identifier": "tableEntry",
                "newPage": false,
                "searchKey": "flate.tableEntry",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type tableEntry struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tableEntry struct {\n\tval    uint32 // Value at destination\n\toffset int32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#deflateFast",
              "documentation": {
                "identifier": "deflateFast",
                "newPage": false,
                "searchKey": "flate.deflateFast",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type deflateFast struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype deflateFast struct {\n\ttable [tableSize]tableEntry\n\tprev  []byte // Previous block, zero length if unknown.\n\tcur   int32  // Current match offset.\n}\n```\n\ndeflateFast maintains the table for matches, and the previous byte block for cross block matching. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#newDeflateFast",
                    "documentation": {
                      "identifier": "newDeflateFast",
                      "newPage": false,
                      "searchKey": "flate.newDeflateFast",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newDeflateFast() *deflateFast"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newDeflateFast() *deflateFast\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#deflateFast.encode",
                    "documentation": {
                      "identifier": "deflateFast.encode",
                      "newPage": false,
                      "searchKey": "flate.deflateFast.encode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *deflateFast) encode(dst []token, src []byte) []token"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *deflateFast) encode(dst []token, src []byte) []token\n```\n\nencode encodes a block given in src and appends tokens to dst and returns the result. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#deflateFast.matchLen",
                    "documentation": {
                      "identifier": "deflateFast.matchLen",
                      "newPage": false,
                      "searchKey": "flate.deflateFast.matchLen",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *deflateFast) matchLen(s, t int32, src []byte) int32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *deflateFast) matchLen(s, t int32, src []byte) int32\n```\n\nmatchLen returns the match length between src[s:] and src[t:]. t can be negative to indicate the match is starting in e.prev. We assume that src[s-4:s] and src[t-4:t] already match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#deflateFast.reset",
                    "documentation": {
                      "identifier": "deflateFast.reset",
                      "newPage": false,
                      "searchKey": "flate.deflateFast.reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *deflateFast) reset()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *deflateFast) reset()\n```\n\nReset resets the encoding history. This ensures that no matches are made to the previous block. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#deflateFast.shiftOffsets",
                    "documentation": {
                      "identifier": "deflateFast.shiftOffsets",
                      "newPage": false,
                      "searchKey": "flate.deflateFast.shiftOffsets",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *deflateFast) shiftOffsets()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *deflateFast) shiftOffsets()\n```\n\nshiftOffsets will shift down all match offset. This is only called in rare situations to prevent integer overflow. \n\nSee [https://golang.org/issue/18636](https://golang.org/issue/18636) and [https://github.com/golang/go/issues/34121](https://github.com/golang/go/issues/34121). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#dictDecoder",
              "documentation": {
                "identifier": "dictDecoder",
                "newPage": false,
                "searchKey": "flate.dictDecoder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dictDecoder struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dictDecoder struct {\n\thist []byte // Sliding window history\n\n\t// Invariant: 0 <= rdPos <= wrPos <= len(hist)\n\twrPos int  // Current output position in buffer\n\trdPos int  // Have emitted hist[:rdPos] already\n\tfull  bool // Has a full window length been written yet?\n}\n```\n\ndictDecoder implements the LZ77 sliding dictionary as used in decompression. LZ77 decompresses data through sequences of two forms of commands: \n\n```\n* Literal insertions: Runs of one or more symbols are inserted into the data\nstream as is. This is accomplished through the writeByte method for a\nsingle symbol, or combinations of writeSlice/writeMark for multiple symbols.\nAny valid stream must start with a literal insertion if no preset dictionary\nis used.\n\n* Backward copies: Runs of one or more symbols are copied from previously\nemitted data. Backward copies come as the tuple (dist, length) where dist\ndetermines how far back in the stream to copy from and length determines how\nmany bytes to copy. Note that it is valid for the length to be greater than\nthe distance. Since LZ77 uses forward copies, that situation is used to\nperform a form of run-length encoding on repeated runs of symbols.\nThe writeCopy and tryWriteCopy are used to implement this command.\n\n```\nFor performance reasons, this implementation performs little to no sanity checks about the arguments. As such, the invariants documented for each method call must be respected. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.init",
                    "documentation": {
                      "identifier": "dictDecoder.init",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) init(size int, dict []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) init(size int, dict []byte)\n```\n\ninit initializes dictDecoder to have a sliding window dictionary of the given size. If a preset dict is provided, it will initialize the dictionary with the contents of dict. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.histSize",
                    "documentation": {
                      "identifier": "dictDecoder.histSize",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.histSize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) histSize() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) histSize() int\n```\n\nhistSize reports the total amount of historical data in the dictionary. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.availRead",
                    "documentation": {
                      "identifier": "dictDecoder.availRead",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.availRead",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) availRead() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) availRead() int\n```\n\navailRead reports the number of bytes that can be flushed by readFlush. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.availWrite",
                    "documentation": {
                      "identifier": "dictDecoder.availWrite",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.availWrite",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) availWrite() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) availWrite() int\n```\n\navailWrite reports the available amount of output buffer space. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.writeSlice",
                    "documentation": {
                      "identifier": "dictDecoder.writeSlice",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.writeSlice",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) writeSlice() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) writeSlice() []byte\n```\n\nwriteSlice returns a slice of the available buffer to write data to. \n\nThis invariant will be kept: len(s) <= availWrite() \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.writeMark",
                    "documentation": {
                      "identifier": "dictDecoder.writeMark",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.writeMark",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) writeMark(cnt int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) writeMark(cnt int)\n```\n\nwriteMark advances the writer pointer by cnt. \n\nThis invariant must be kept: 0 <= cnt <= availWrite() \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.writeByte",
                    "documentation": {
                      "identifier": "dictDecoder.writeByte",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.writeByte",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) writeByte(c byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) writeByte(c byte)\n```\n\nwriteByte writes a single byte to the dictionary. \n\nThis invariant must be kept: 0 < availWrite() \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.writeCopy",
                    "documentation": {
                      "identifier": "dictDecoder.writeCopy",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.writeCopy",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) writeCopy(dist, length int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) writeCopy(dist, length int) int\n```\n\nwriteCopy copies a string at a given (dist, length) to the output. This returns the number of bytes copied and may be less than the requested length if the available space in the output buffer is too small. \n\nThis invariant must be kept: 0 < dist <= histSize() \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.tryWriteCopy",
                    "documentation": {
                      "identifier": "dictDecoder.tryWriteCopy",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.tryWriteCopy",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) tryWriteCopy(dist, length int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) tryWriteCopy(dist, length int) int\n```\n\ntryWriteCopy tries to copy a string at a given (distance, length) to the output. This specialized version is optimized for short distances. \n\nThis method is designed to be inlined for performance reasons. \n\nThis invariant must be kept: 0 < dist <= histSize() \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#dictDecoder.readFlush",
                    "documentation": {
                      "identifier": "dictDecoder.readFlush",
                      "newPage": false,
                      "searchKey": "flate.dictDecoder.readFlush",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dd *dictDecoder) readFlush() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dd *dictDecoder) readFlush() []byte\n```\n\nreadFlush returns a slice of the historical buffer that is ready to be emitted to the user. The data returned by readFlush must be fully consumed before calling any other dictDecoder methods. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#huffmanBitWriter",
              "documentation": {
                "identifier": "huffmanBitWriter",
                "newPage": false,
                "searchKey": "flate.huffmanBitWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type huffmanBitWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype huffmanBitWriter struct {\n\t// writer is the underlying writer.\n\t// Do not use it directly; use the write method, which ensures\n\t// that Write errors are sticky.\n\twriter io.Writer\n\n\t// Data waiting to be written is bytes[0:nbytes]\n\t// and then the low nbits of bits.  Data is always written\n\t// sequentially into the bytes array.\n\tbits            uint64\n\tnbits           uint\n\tbytes           [bufferSize]byte\n\tcodegenFreq     [codegenCodeCount]int32\n\tnbytes          int\n\tliteralFreq     []int32\n\toffsetFreq      []int32\n\tcodegen         []uint8\n\tliteralEncoding *huffmanEncoder\n\toffsetEncoding  *huffmanEncoder\n\tcodegenEncoding *huffmanEncoder\n\terr             error\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#newHuffmanBitWriter",
                    "documentation": {
                      "identifier": "newHuffmanBitWriter",
                      "newPage": false,
                      "searchKey": "flate.newHuffmanBitWriter",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newHuffmanBitWriter(w io.Writer) *huffmanBitWriter\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.reset",
                    "documentation": {
                      "identifier": "huffmanBitWriter.reset",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) reset(writer io.Writer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) reset(writer io.Writer)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.flush",
                    "documentation": {
                      "identifier": "huffmanBitWriter.flush",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.flush",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) flush()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) flush()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.write",
                    "documentation": {
                      "identifier": "huffmanBitWriter.write",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) write(b []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) write(b []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeBits",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeBits",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeBits",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeBits(b int32, nb uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeBits(b int32, nb uint)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeBytes",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeBytes",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeBytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeBytes(bytes []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeBytes(bytes []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.generateCodegen",
                    "documentation": {
                      "identifier": "huffmanBitWriter.generateCodegen",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.generateCodegen",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int, litEnc, offEnc *huffmanEncoder)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int, litEnc, offEnc *huffmanEncoder)\n```\n\nRFC 1951 3.2.7 specifies a special run-length encoding for specifying the literal and offset lengths arrays (which are concatenated into a single array).  This method generates that run-length encoding. \n\nThe result is written into the codegen array, and the frequencies of each code is written into the codegenFreq array. Codes 0-15 are single byte codes. Codes 16-18 are followed by additional information. Code badCode is an end marker \n\n```\nnumLiterals      The number of literals in literalEncoding\nnumOffsets       The number of offsets in offsetEncoding\nlitenc, offenc   The literal and offset encoder to use\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.dynamicSize",
                    "documentation": {
                      "identifier": "huffmanBitWriter.dynamicSize",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.dynamicSize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) dynamicSize(litEnc, offEnc *huffmanEncoder, extraBits int) (size, numCodegens int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) dynamicSize(litEnc, offEnc *huffmanEncoder, extraBits int) (size, numCodegens int)\n```\n\ndynamicSize returns the size of dynamically encoded data in bits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.fixedSize",
                    "documentation": {
                      "identifier": "huffmanBitWriter.fixedSize",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.fixedSize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) fixedSize(extraBits int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) fixedSize(extraBits int) int\n```\n\nfixedSize returns the size of dynamically encoded data in bits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.storedSize",
                    "documentation": {
                      "identifier": "huffmanBitWriter.storedSize",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.storedSize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) storedSize(in []byte) (int, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) storedSize(in []byte) (int, bool)\n```\n\nstoredSize calculates the stored size, including header. The function returns the size in bits and whether the block fits inside a single block. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeCode",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeCode",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeCode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeCode(c hcode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeCode(c hcode)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeDynamicHeader",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeDynamicHeader",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeDynamicHeader",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, numCodegens int, isEof bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, numCodegens int, isEof bool)\n```\n\nWrite the header of a dynamic Huffman block to the output stream. \n\n```\nnumLiterals  The number of literals specified in codegen\nnumOffsets   The number of offsets specified in codegen\nnumCodegens  The number of codegens used in codegen\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeStoredHeader",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeStoredHeader",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeStoredHeader",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeStoredHeader(length int, isEof bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeStoredHeader(length int, isEof bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeFixedHeader",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeFixedHeader",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeFixedHeader",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeFixedHeader(isEof bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeFixedHeader(isEof bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeBlock",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeBlock",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeBlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte)\n```\n\nwriteBlock will write a block of tokens with the smallest encoding. The original input can be supplied, and if the huffman encoded data is larger than the original bytes, the data will be written as a stored block. If the input is nil, the tokens will always be Huffman encoded. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeBlockDynamic",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeBlockDynamic",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeBlockDynamic",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeBlockDynamic(tokens []token, eof bool, input []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeBlockDynamic(tokens []token, eof bool, input []byte)\n```\n\nwriteBlockDynamic encodes a block using a dynamic Huffman table. This should be used if the symbols used have a disproportionate histogram distribution. If input is supplied and the compression savings are below 1/16th of the input size the block is stored. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.indexTokens",
                    "documentation": {
                      "identifier": "huffmanBitWriter.indexTokens",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.indexTokens",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) indexTokens(tokens []token) (numLiterals, numOffsets int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) indexTokens(tokens []token) (numLiterals, numOffsets int)\n```\n\nindexTokens indexes a slice of tokens, and updates literalFreq and offsetFreq, and generates literalEncoding and offsetEncoding. The number of literal and offset tokens is returned. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeTokens",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeTokens",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeTokens",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeTokens(tokens []token, leCodes, oeCodes []hcode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeTokens(tokens []token, leCodes, oeCodes []hcode)\n```\n\nwriteTokens writes a slice of tokens to the output. codes for literal and offset encoding must be supplied. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanBitWriter.writeBlockHuff",
                    "documentation": {
                      "identifier": "huffmanBitWriter.writeBlockHuff",
                      "newPage": false,
                      "searchKey": "flate.huffmanBitWriter.writeBlockHuff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *huffmanBitWriter) writeBlockHuff(eof bool, input []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *huffmanBitWriter) writeBlockHuff(eof bool, input []byte)\n```\n\nwriteBlockHuff encodes a block of bytes as either Huffman encoded literals or uncompressed bytes if the results only gains very little from compression. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#hcode",
              "documentation": {
                "identifier": "hcode",
                "newPage": false,
                "searchKey": "flate.hcode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type hcode struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype hcode struct {\n\tcode, len uint16\n}\n```\n\nhcode is a huffman code with a bit code and bit length. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#hcode.set",
                    "documentation": {
                      "identifier": "hcode.set",
                      "newPage": false,
                      "searchKey": "flate.hcode.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *hcode) set(code uint16, length uint16)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *hcode) set(code uint16, length uint16)\n```\n\nset sets the code and length of an hcode. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#huffmanEncoder",
              "documentation": {
                "identifier": "huffmanEncoder",
                "newPage": false,
                "searchKey": "flate.huffmanEncoder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type huffmanEncoder struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype huffmanEncoder struct {\n\tcodes     []hcode\n\tfreqcache []literalNode\n\tbitCount  [17]int32\n\tlns       byLiteral // stored to avoid repeated allocation in generate\n\tlfs       byFreq    // stored to avoid repeated allocation in generate\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#newHuffmanEncoder",
                    "documentation": {
                      "identifier": "newHuffmanEncoder",
                      "newPage": false,
                      "searchKey": "flate.newHuffmanEncoder",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newHuffmanEncoder(size int) *huffmanEncoder"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newHuffmanEncoder(size int) *huffmanEncoder\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#generateFixedLiteralEncoding",
                    "documentation": {
                      "identifier": "generateFixedLiteralEncoding",
                      "newPage": false,
                      "searchKey": "flate.generateFixedLiteralEncoding",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func generateFixedLiteralEncoding() *huffmanEncoder"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc generateFixedLiteralEncoding() *huffmanEncoder\n```\n\nGenerates a HuffmanCode corresponding to the fixed literal table \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#generateFixedOffsetEncoding",
                    "documentation": {
                      "identifier": "generateFixedOffsetEncoding",
                      "newPage": false,
                      "searchKey": "flate.generateFixedOffsetEncoding",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func generateFixedOffsetEncoding() *huffmanEncoder"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc generateFixedOffsetEncoding() *huffmanEncoder\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanEncoder.bitLength",
                    "documentation": {
                      "identifier": "huffmanEncoder.bitLength",
                      "newPage": false,
                      "searchKey": "flate.huffmanEncoder.bitLength",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *huffmanEncoder) bitLength(freq []int32) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *huffmanEncoder) bitLength(freq []int32) int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanEncoder.bitCounts",
                    "documentation": {
                      "identifier": "huffmanEncoder.bitCounts",
                      "newPage": false,
                      "searchKey": "flate.huffmanEncoder.bitCounts",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32\n```\n\nReturn the number of literals assigned to each bit size in the Huffman encoding \n\nThis method is only called when list.length >= 3 The cases of 0, 1, and 2 literals are handled by special case code. \n\nlist  An array of the literals with non-zero frequencies \n\n```\nand their associated frequencies. The array is in order of increasing\nfrequency, and has as its last element a special element with frequency\nMaxInt32\n\n```\nmaxBits     The maximum number of bits that should be used to encode any literal. \n\n```\nMust be less than 16.\n\n```\nreturn      An integer array in which array[i] indicates the number of literals \n\n```\nthat should be encoded in i bits.\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanEncoder.assignEncodingAndSize",
                    "documentation": {
                      "identifier": "huffmanEncoder.assignEncodingAndSize",
                      "newPage": false,
                      "searchKey": "flate.huffmanEncoder.assignEncodingAndSize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *huffmanEncoder) assignEncodingAndSize(bitCount []int32, list []literalNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *huffmanEncoder) assignEncodingAndSize(bitCount []int32, list []literalNode)\n```\n\nLook at the leaves and assign them a bit count and an encoding as specified in RFC 1951 3.2.2 \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanEncoder.generate",
                    "documentation": {
                      "identifier": "huffmanEncoder.generate",
                      "newPage": false,
                      "searchKey": "flate.huffmanEncoder.generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *huffmanEncoder) generate(freq []int32, maxBits int32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *huffmanEncoder) generate(freq []int32, maxBits int32)\n```\n\nUpdate this Huffman Code object to be the minimum code for the specified frequency count. \n\nfreq  An array of frequencies, in which frequency[i] gives the frequency of literal i. maxBits  The maximum number of bits to use for any literal. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#literalNode",
              "documentation": {
                "identifier": "literalNode",
                "newPage": false,
                "searchKey": "flate.literalNode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type literalNode struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype literalNode struct {\n\tliteral uint16\n\tfreq    int32\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#maxNode",
                    "documentation": {
                      "identifier": "maxNode",
                      "newPage": false,
                      "searchKey": "flate.maxNode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func maxNode() literalNode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc maxNode() literalNode\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#levelInfo",
              "documentation": {
                "identifier": "levelInfo",
                "newPage": false,
                "searchKey": "flate.levelInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type levelInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype levelInfo struct {\n\t// Our level.  for better printing\n\tlevel int32\n\n\t// The frequency of the last node at this level\n\tlastFreq int32\n\n\t// The frequency of the next character to add to this level\n\tnextCharFreq int32\n\n\t// The frequency of the next pair (from level below) to add to this level.\n\t// Only valid if the \"needed\" value of the next lower level is 0.\n\tnextPairFreq int32\n\n\t// The number of chains remaining to generate for this level before moving\n\t// up to the next level\n\tneeded int32\n}\n```\n\nA levelInfo describes the state of the constructed tree for a given depth. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#byLiteral",
              "documentation": {
                "identifier": "byLiteral",
                "newPage": false,
                "searchKey": "flate.byLiteral",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type byLiteral []flate.literalNode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byLiteral []literalNode\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#byLiteral.sort",
                    "documentation": {
                      "identifier": "byLiteral.sort",
                      "newPage": false,
                      "searchKey": "flate.byLiteral.sort",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *byLiteral) sort(a []literalNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *byLiteral) sort(a []literalNode)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#byLiteral.Len",
                    "documentation": {
                      "identifier": "byLiteral.Len",
                      "newPage": false,
                      "searchKey": "flate.byLiteral.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byLiteral) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byLiteral) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#byLiteral.Less",
                    "documentation": {
                      "identifier": "byLiteral.Less",
                      "newPage": false,
                      "searchKey": "flate.byLiteral.Less",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byLiteral) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byLiteral) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#byLiteral.Swap",
                    "documentation": {
                      "identifier": "byLiteral.Swap",
                      "newPage": false,
                      "searchKey": "flate.byLiteral.Swap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byLiteral) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byLiteral) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#byFreq",
              "documentation": {
                "identifier": "byFreq",
                "newPage": false,
                "searchKey": "flate.byFreq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type byFreq []flate.literalNode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byFreq []literalNode\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#byFreq.sort",
                    "documentation": {
                      "identifier": "byFreq.sort",
                      "newPage": false,
                      "searchKey": "flate.byFreq.sort",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *byFreq) sort(a []literalNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *byFreq) sort(a []literalNode)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#byFreq.Len",
                    "documentation": {
                      "identifier": "byFreq.Len",
                      "newPage": false,
                      "searchKey": "flate.byFreq.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byFreq) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byFreq) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#byFreq.Less",
                    "documentation": {
                      "identifier": "byFreq.Less",
                      "newPage": false,
                      "searchKey": "flate.byFreq.Less",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byFreq) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byFreq) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#byFreq.Swap",
                    "documentation": {
                      "identifier": "byFreq.Swap",
                      "newPage": false,
                      "searchKey": "flate.byFreq.Swap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s byFreq) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s byFreq) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#CorruptInputError",
              "documentation": {
                "identifier": "CorruptInputError",
                "newPage": false,
                "searchKey": "flate.CorruptInputError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type CorruptInputError int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype CorruptInputError int64\n```\n\nA CorruptInputError reports the presence of corrupt input at a given offset. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#CorruptInputError.Error",
                    "documentation": {
                      "identifier": "CorruptInputError.Error",
                      "newPage": false,
                      "searchKey": "flate.CorruptInputError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e CorruptInputError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e CorruptInputError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#InternalError",
              "documentation": {
                "identifier": "InternalError",
                "newPage": false,
                "searchKey": "flate.InternalError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type InternalError string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype InternalError string\n```\n\nAn InternalError reports an error in the flate code itself. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#InternalError.Error",
                    "documentation": {
                      "identifier": "InternalError.Error",
                      "newPage": false,
                      "searchKey": "flate.InternalError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e InternalError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e InternalError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#ReadError",
              "documentation": {
                "identifier": "ReadError",
                "newPage": false,
                "searchKey": "flate.ReadError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ReadError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ReadError struct {\n\tOffset int64 // byte offset where error occurred\n\tErr    error // error returned by underlying Read\n}\n```\n\nA ReadError reports an error encountered while reading input. \n\nDeprecated: No longer returned. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#ReadError.Error",
                    "documentation": {
                      "identifier": "ReadError.Error",
                      "newPage": false,
                      "searchKey": "flate.ReadError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ReadError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ReadError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#WriteError",
              "documentation": {
                "identifier": "WriteError",
                "newPage": false,
                "searchKey": "flate.WriteError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type WriteError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype WriteError struct {\n\tOffset int64 // byte offset where error occurred\n\tErr    error // error returned by underlying Write\n}\n```\n\nA WriteError reports an error encountered while writing output. \n\nDeprecated: No longer returned. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#WriteError.Error",
                    "documentation": {
                      "identifier": "WriteError.Error",
                      "newPage": false,
                      "searchKey": "flate.WriteError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *WriteError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *WriteError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#Resetter",
              "documentation": {
                "identifier": "Resetter",
                "newPage": false,
                "searchKey": "flate.Resetter",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Resetter interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Resetter interface {\n\t// Reset discards any buffered data and resets the Resetter as if it was\n\t// newly initialized with the given reader.\n\tReset(r io.Reader, dict []byte) error\n}\n```\n\nResetter resets a ReadCloser returned by NewReader or NewReaderDict to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#huffmanDecoder",
              "documentation": {
                "identifier": "huffmanDecoder",
                "newPage": false,
                "searchKey": "flate.huffmanDecoder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type huffmanDecoder struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype huffmanDecoder struct {\n\tmin      int                      // the minimum code length\n\tchunks   [huffmanNumChunks]uint32 // chunks as described above\n\tlinks    [][]uint32               // overflow links\n\tlinkMask uint32                   // mask the width of the link table\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#huffmanDecoder.init",
                    "documentation": {
                      "identifier": "huffmanDecoder.init",
                      "newPage": false,
                      "searchKey": "flate.huffmanDecoder.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *huffmanDecoder) init(lengths []int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *huffmanDecoder) init(lengths []int) bool\n```\n\nInitialize Huffman decoding tables from array of code lengths. Following this function, h is guaranteed to be initialized into a complete tree (i.e., neither over-subscribed nor under-subscribed). The exception is a degenerate case where the tree has only a single symbol with length 1. Empty trees are permitted. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#Reader",
              "documentation": {
                "identifier": "Reader",
                "newPage": false,
                "searchKey": "flate.Reader",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Reader interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Reader interface {\n\tio.Reader\n\tio.ByteReader\n}\n```\n\nThe actual read interface needed by NewReader. If the passed in io.Reader does not also have ReadByte, the NewReader will introduce its own buffering. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#makeReader",
                    "documentation": {
                      "identifier": "makeReader",
                      "newPage": false,
                      "searchKey": "flate.makeReader",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeReader(r io.Reader) Reader"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeReader(r io.Reader) Reader\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#decompressor",
              "documentation": {
                "identifier": "decompressor",
                "newPage": false,
                "searchKey": "flate.decompressor",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type decompressor struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype decompressor struct {\n\t// Input source.\n\tr       Reader\n\troffset int64\n\n\t// Input bits, in top of b.\n\tb  uint32\n\tnb uint\n\n\t// Huffman decoders for literal/length, distance.\n\th1, h2 huffmanDecoder\n\n\t// Length arrays used to define Huffman codes.\n\tbits     *[maxNumLit + maxNumDist]int\n\tcodebits *[numCodes]int\n\n\t// Output history, buffer.\n\tdict dictDecoder\n\n\t// Temporary buffer (avoids repeated allocation).\n\tbuf [4]byte\n\n\t// Next step in the decompression,\n\t// and decompression state.\n\tstep      func(*decompressor)\n\tstepState int\n\tfinal     bool\n\terr       error\n\ttoRead    []byte\n\thl, hd    *huffmanDecoder\n\tcopyLen   int\n\tcopyDist  int\n}\n```\n\nDecompress state. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.nextBlock",
                    "documentation": {
                      "identifier": "decompressor.nextBlock",
                      "newPage": false,
                      "searchKey": "flate.decompressor.nextBlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) nextBlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) nextBlock()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.Read",
                    "documentation": {
                      "identifier": "decompressor.Read",
                      "newPage": false,
                      "searchKey": "flate.decompressor.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) Read(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.Close",
                    "documentation": {
                      "identifier": "decompressor.Close",
                      "newPage": false,
                      "searchKey": "flate.decompressor.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.readHuffman",
                    "documentation": {
                      "identifier": "decompressor.readHuffman",
                      "newPage": false,
                      "searchKey": "flate.decompressor.readHuffman",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) readHuffman() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) readHuffman() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.huffmanBlock",
                    "documentation": {
                      "identifier": "decompressor.huffmanBlock",
                      "newPage": false,
                      "searchKey": "flate.decompressor.huffmanBlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) huffmanBlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) huffmanBlock()\n```\n\nDecode a single Huffman block from f. hl and hd are the Huffman states for the lit/length values and the distance values, respectively. If hd == nil, using the fixed distance encoding associated with fixed Huffman blocks. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.dataBlock",
                    "documentation": {
                      "identifier": "decompressor.dataBlock",
                      "newPage": false,
                      "searchKey": "flate.decompressor.dataBlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) dataBlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) dataBlock()\n```\n\nCopy a single uncompressed data block from input to output. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.copyData",
                    "documentation": {
                      "identifier": "decompressor.copyData",
                      "newPage": false,
                      "searchKey": "flate.decompressor.copyData",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) copyData()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) copyData()\n```\n\ncopyData copies f.copyLen bytes from the underlying reader into f.hist. It pauses for reads when f.hist is full. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.finishBlock",
                    "documentation": {
                      "identifier": "decompressor.finishBlock",
                      "newPage": false,
                      "searchKey": "flate.decompressor.finishBlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) finishBlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) finishBlock()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.moreBits",
                    "documentation": {
                      "identifier": "decompressor.moreBits",
                      "newPage": false,
                      "searchKey": "flate.decompressor.moreBits",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) moreBits() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) moreBits() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.huffSym",
                    "documentation": {
                      "identifier": "decompressor.huffSym",
                      "newPage": false,
                      "searchKey": "flate.decompressor.huffSym",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) huffSym(h *huffmanDecoder) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) huffSym(h *huffmanDecoder) (int, error)\n```\n\nRead the next Huffman-encoded symbol from f according to h. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#decompressor.Reset",
                    "documentation": {
                      "identifier": "decompressor.Reset",
                      "newPage": false,
                      "searchKey": "flate.decompressor.Reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *decompressor) Reset(r io.Reader, dict []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *decompressor) Reset(r io.Reader, dict []byte) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#token",
              "documentation": {
                "identifier": "token",
                "newPage": false,
                "searchKey": "flate.token",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type token uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype token uint32\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#literalToken",
                    "documentation": {
                      "identifier": "literalToken",
                      "newPage": false,
                      "searchKey": "flate.literalToken",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func literalToken(literal uint32) token"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc literalToken(literal uint32) token\n```\n\nConvert a literal into a literal token. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#matchToken",
                    "documentation": {
                      "identifier": "matchToken",
                      "newPage": false,
                      "searchKey": "flate.matchToken",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func matchToken(xlength uint32, xoffset uint32) token"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc matchToken(xlength uint32, xoffset uint32) token\n```\n\nConvert a < xlength, xoffset > pair into a match token. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#token.literal",
                    "documentation": {
                      "identifier": "token.literal",
                      "newPage": false,
                      "searchKey": "flate.token.literal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t token) literal() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t token) literal() uint32\n```\n\nReturns the literal of a literal token \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#token.offset",
                    "documentation": {
                      "identifier": "token.offset",
                      "newPage": false,
                      "searchKey": "flate.token.offset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t token) offset() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t token) offset() uint32\n```\n\nReturns the extra offset of a match token \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#token.length",
                    "documentation": {
                      "identifier": "token.length",
                      "newPage": false,
                      "searchKey": "flate.token.length",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t token) length() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t token) length() uint32\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#deflateTest",
              "documentation": {
                "identifier": "deflateTest",
                "newPage": false,
                "searchKey": "flate.deflateTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type deflateTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype deflateTest struct {\n\tin    []byte\n\tlevel int\n\tout   []byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#deflateInflateTest",
              "documentation": {
                "identifier": "deflateInflateTest",
                "newPage": false,
                "searchKey": "flate.deflateInflateTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type deflateInflateTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype deflateInflateTest struct {\n\tin []byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#reverseBitsTest",
              "documentation": {
                "identifier": "reverseBitsTest",
                "newPage": false,
                "searchKey": "flate.reverseBitsTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type reverseBitsTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype reverseBitsTest struct {\n\tin       uint16\n\tbitCount uint8\n\tout      uint16\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#sparseReader",
              "documentation": {
                "identifier": "sparseReader",
                "newPage": false,
                "searchKey": "flate.sparseReader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sparseReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sparseReader struct {\n\tl   int64\n\tcur int64\n}\n```\n\nA sparseReader returns a stream consisting of 0s followed by 1<<16 1s. This tests missing hash references in a very large input. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#sparseReader.Read",
                    "documentation": {
                      "identifier": "sparseReader.Read",
                      "newPage": false,
                      "searchKey": "flate.sparseReader.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *sparseReader) Read(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *sparseReader) Read(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#syncBuffer",
              "documentation": {
                "identifier": "syncBuffer",
                "newPage": false,
                "searchKey": "flate.syncBuffer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type syncBuffer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype syncBuffer struct {\n\tbuf    bytes.Buffer\n\tmu     sync.RWMutex\n\tclosed bool\n\tready  chan bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#newSyncBuffer",
                    "documentation": {
                      "identifier": "newSyncBuffer",
                      "newPage": false,
                      "searchKey": "flate.newSyncBuffer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newSyncBuffer() *syncBuffer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newSyncBuffer() *syncBuffer\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#syncBuffer.Read",
                    "documentation": {
                      "identifier": "syncBuffer.Read",
                      "newPage": false,
                      "searchKey": "flate.syncBuffer.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *syncBuffer) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *syncBuffer) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#syncBuffer.signal",
                    "documentation": {
                      "identifier": "syncBuffer.signal",
                      "newPage": false,
                      "searchKey": "flate.syncBuffer.signal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *syncBuffer) signal()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *syncBuffer) signal()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#syncBuffer.Write",
                    "documentation": {
                      "identifier": "syncBuffer.Write",
                      "newPage": false,
                      "searchKey": "flate.syncBuffer.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *syncBuffer) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *syncBuffer) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#syncBuffer.WriteMode",
                    "documentation": {
                      "identifier": "syncBuffer.WriteMode",
                      "newPage": false,
                      "searchKey": "flate.syncBuffer.WriteMode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *syncBuffer) WriteMode()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *syncBuffer) WriteMode()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#syncBuffer.ReadMode",
                    "documentation": {
                      "identifier": "syncBuffer.ReadMode",
                      "newPage": false,
                      "searchKey": "flate.syncBuffer.ReadMode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *syncBuffer) ReadMode()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *syncBuffer) ReadMode()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/flate#syncBuffer.Close",
                    "documentation": {
                      "identifier": "syncBuffer.Close",
                      "newPage": false,
                      "searchKey": "flate.syncBuffer.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *syncBuffer) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *syncBuffer) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#deflateInflateStringTest",
              "documentation": {
                "identifier": "deflateInflateStringTest",
                "newPage": false,
                "searchKey": "flate.deflateInflateStringTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type deflateInflateStringTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype deflateInflateStringTest struct {\n\tfilename string\n\tlabel    string\n\tlimit    [11]int\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#failWriter",
              "documentation": {
                "identifier": "failWriter",
                "newPage": false,
                "searchKey": "flate.failWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type failWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype failWriter struct{ n int }\n```\n\nfailWriter fails with errIO exactly at the nth call to Write. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#failWriter.Write",
                    "documentation": {
                      "identifier": "failWriter.Write",
                      "newPage": false,
                      "searchKey": "flate.failWriter.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *failWriter) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *failWriter) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#huffTest",
              "documentation": {
                "identifier": "huffTest",
                "newPage": false,
                "searchKey": "flate.huffTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type huffTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype huffTest struct {\n\ttokens      []token\n\tinput       string // File name of input data matching the tokens.\n\twant        string // File name of data with the expected output with input available.\n\twantNoInput string // File name of the expected output when no input is available.\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#errorWriter",
              "documentation": {
                "identifier": "errorWriter",
                "newPage": false,
                "searchKey": "flate.errorWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type errorWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype errorWriter struct {\n\tN int\n}\n```\n\nerrorWriter is a writer that fails after N writes. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/flate#errorWriter.Write",
                    "documentation": {
                      "identifier": "errorWriter.Write",
                      "newPage": false,
                      "searchKey": "flate.errorWriter.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *errorWriter) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *errorWriter) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/compress/flate#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/compress/flate#hash4",
              "documentation": {
                "identifier": "hash4",
                "newPage": false,
                "searchKey": "flate.hash4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hash4(b []byte) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hash4(b []byte) uint32\n```\n\nhash4 returns a hash representation of the first 4 bytes of the supplied slice. The caller must ensure that len(b) >= 4. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#bulkHash4",
              "documentation": {
                "identifier": "bulkHash4",
                "newPage": false,
                "searchKey": "flate.bulkHash4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bulkHash4(b []byte, dst []uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bulkHash4(b []byte, dst []uint32)\n```\n\nbulkHash4 will compute hashes using the same algorithm as hash4 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#matchLen",
              "documentation": {
                "identifier": "matchLen",
                "newPage": false,
                "searchKey": "flate.matchLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func matchLen(a, b []byte, max int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc matchLen(a, b []byte, max int) int\n```\n\nmatchLen returns the number of matching bytes in a and b up to length 'max'. Both slices must be at least 'max' bytes in size. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#load32",
              "documentation": {
                "identifier": "load32",
                "newPage": false,
                "searchKey": "flate.load32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func load32(b []byte, i int32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc load32(b []byte, i int32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#load64",
              "documentation": {
                "identifier": "load64",
                "newPage": false,
                "searchKey": "flate.load64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func load64(b []byte, i int32) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc load64(b []byte, i int32) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#hash",
              "documentation": {
                "identifier": "hash",
                "newPage": false,
                "searchKey": "flate.hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hash(u uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hash(u uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#emitLiteral",
              "documentation": {
                "identifier": "emitLiteral",
                "newPage": false,
                "searchKey": "flate.emitLiteral",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func emitLiteral(dst []token, lit []byte) []token"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc emitLiteral(dst []token, lit []byte) []token\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "flate.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#histogram",
              "documentation": {
                "identifier": "histogram",
                "newPage": false,
                "searchKey": "flate.histogram",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func histogram(b []byte, h []int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc histogram(b []byte, h []int32)\n```\n\nhistogram accumulates a histogram of b in h. \n\nlen(h) must be >= 256, and h's elements must be all zeroes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#reverseBits",
              "documentation": {
                "identifier": "reverseBits",
                "newPage": false,
                "searchKey": "flate.reverseBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reverseBits(number uint16, bitLength byte) uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reverseBits(number uint16, bitLength byte) uint16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#noEOF",
              "documentation": {
                "identifier": "noEOF",
                "newPage": false,
                "searchKey": "flate.noEOF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func noEOF(e error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc noEOF(e error) error\n```\n\nnoEOF returns err, unless err == io.EOF, in which case it returns io.ErrUnexpectedEOF. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#fixedHuffmanDecoderInit",
              "documentation": {
                "identifier": "fixedHuffmanDecoderInit",
                "newPage": false,
                "searchKey": "flate.fixedHuffmanDecoderInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fixedHuffmanDecoderInit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fixedHuffmanDecoderInit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#NewReader",
              "documentation": {
                "identifier": "NewReader",
                "newPage": false,
                "searchKey": "flate.NewReader",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func NewReader(r io.Reader) io.ReadCloser"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc NewReader(r io.Reader) io.ReadCloser\n```\n\nNewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. \n\nThe ReadCloser returned by NewReader also implements Resetter. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#NewReaderDict",
              "documentation": {
                "identifier": "NewReaderDict",
                "newPage": false,
                "searchKey": "flate.NewReaderDict",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc NewReaderDict(r io.Reader, dict []byte) io.ReadCloser\n```\n\nNewReaderDict is like NewReader but initializes the reader with a preset dictionary. The returned Reader behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by NewWriterDict. \n\nThe ReadCloser returned by NewReader also implements Resetter. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#lengthCode",
              "documentation": {
                "identifier": "lengthCode",
                "newPage": false,
                "searchKey": "flate.lengthCode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lengthCode(len uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lengthCode(len uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#offsetCode",
              "documentation": {
                "identifier": "offsetCode",
                "newPage": false,
                "searchKey": "flate.offsetCode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func offsetCode(off uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc offsetCode(off uint32) uint32\n```\n\nReturns the offset code corresponding to a specific offset \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#largeDataChunk",
              "documentation": {
                "identifier": "largeDataChunk",
                "newPage": false,
                "searchKey": "flate.largeDataChunk",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func largeDataChunk() []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc largeDataChunk() []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestBulkHash4",
              "documentation": {
                "identifier": "TestBulkHash4",
                "newPage": false,
                "searchKey": "flate.TestBulkHash4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBulkHash4(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBulkHash4(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestDeflate",
              "documentation": {
                "identifier": "TestDeflate",
                "newPage": false,
                "searchKey": "flate.TestDeflate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDeflate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDeflate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestVeryLongSparseChunk",
              "documentation": {
                "identifier": "TestVeryLongSparseChunk",
                "newPage": false,
                "searchKey": "flate.TestVeryLongSparseChunk",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestVeryLongSparseChunk(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestVeryLongSparseChunk(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#testSync",
              "documentation": {
                "identifier": "testSync",
                "newPage": false,
                "searchKey": "flate.testSync",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testSync(t *testing.T, level int, input []byte, name string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testSync(t *testing.T, level int, input []byte, name string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#testToFromWithLevelAndLimit",
              "documentation": {
                "identifier": "testToFromWithLevelAndLimit",
                "newPage": false,
                "searchKey": "flate.testToFromWithLevelAndLimit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testToFromWithLevelAndLimit(t *testing.T, level int, input []byte, name string, limit int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testToFromWithLevelAndLimit(t *testing.T, level int, input []byte, name string, limit int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#testToFromWithLimit",
              "documentation": {
                "identifier": "testToFromWithLimit",
                "newPage": false,
                "searchKey": "flate.testToFromWithLimit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testToFromWithLimit(t *testing.T, input []byte, name string, limit [11]int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testToFromWithLimit(t *testing.T, input []byte, name string, limit [11]int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestDeflateInflate",
              "documentation": {
                "identifier": "TestDeflateInflate",
                "newPage": false,
                "searchKey": "flate.TestDeflateInflate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDeflateInflate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDeflateInflate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestReverseBits",
              "documentation": {
                "identifier": "TestReverseBits",
                "newPage": false,
                "searchKey": "flate.TestReverseBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReverseBits(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReverseBits(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestDeflateInflateString",
              "documentation": {
                "identifier": "TestDeflateInflateString",
                "newPage": false,
                "searchKey": "flate.TestDeflateInflateString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDeflateInflateString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDeflateInflateString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestReaderDict",
              "documentation": {
                "identifier": "TestReaderDict",
                "newPage": false,
                "searchKey": "flate.TestReaderDict",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReaderDict(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReaderDict(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestWriterDict",
              "documentation": {
                "identifier": "TestWriterDict",
                "newPage": false,
                "searchKey": "flate.TestWriterDict",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriterDict(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriterDict(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestRegression2508",
              "documentation": {
                "identifier": "TestRegression2508",
                "newPage": false,
                "searchKey": "flate.TestRegression2508",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRegression2508(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRegression2508(t *testing.T)\n```\n\nSee [https://golang.org/issue/2508](https://golang.org/issue/2508) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestWriterReset",
              "documentation": {
                "identifier": "TestWriterReset",
                "newPage": false,
                "searchKey": "flate.TestWriterReset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriterReset(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriterReset(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#testResetOutput",
              "documentation": {
                "identifier": "testResetOutput",
                "newPage": false,
                "searchKey": "flate.testResetOutput",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testResetOutput(t *testing.T, level int, dict []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testResetOutput(t *testing.T, level int, dict []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestBestSpeed",
              "documentation": {
                "identifier": "TestBestSpeed",
                "newPage": false,
                "searchKey": "flate.TestBestSpeed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBestSpeed(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBestSpeed(t *testing.T)\n```\n\nTestBestSpeed tests that round-tripping through deflate and then inflate recovers the original input. The Write sizes are near the thresholds in the compressor.encSpeed method (0, 16, 128), as well as near maxStoreBlockSize (65535). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestWriterPersistentError",
              "documentation": {
                "identifier": "TestWriterPersistentError",
                "newPage": false,
                "searchKey": "flate.TestWriterPersistentError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriterPersistentError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriterPersistentError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestBestSpeedMatch",
              "documentation": {
                "identifier": "TestBestSpeedMatch",
                "newPage": false,
                "searchKey": "flate.TestBestSpeedMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBestSpeedMatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBestSpeedMatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestBestSpeedMaxMatchOffset",
              "documentation": {
                "identifier": "TestBestSpeedMaxMatchOffset",
                "newPage": false,
                "searchKey": "flate.TestBestSpeedMaxMatchOffset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBestSpeedMaxMatchOffset(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBestSpeedMaxMatchOffset(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestBestSpeedShiftOffsets",
              "documentation": {
                "identifier": "TestBestSpeedShiftOffsets",
                "newPage": false,
                "searchKey": "flate.TestBestSpeedShiftOffsets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBestSpeedShiftOffsets(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBestSpeedShiftOffsets(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestMaxStackSize",
              "documentation": {
                "identifier": "TestMaxStackSize",
                "newPage": false,
                "searchKey": "flate.TestMaxStackSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMaxStackSize(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMaxStackSize(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestDictDecoder",
              "documentation": {
                "identifier": "TestDictDecoder",
                "newPage": false,
                "searchKey": "flate.TestDictDecoder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDictDecoder(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDictDecoder(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestIssue5915",
              "documentation": {
                "identifier": "TestIssue5915",
                "newPage": false,
                "searchKey": "flate.TestIssue5915",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue5915(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue5915(t *testing.T)\n```\n\nThe following test should not panic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestIssue5962",
              "documentation": {
                "identifier": "TestIssue5962",
                "newPage": false,
                "searchKey": "flate.TestIssue5962",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue5962(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue5962(t *testing.T)\n```\n\nThe following test should not panic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestIssue6255",
              "documentation": {
                "identifier": "TestIssue6255",
                "newPage": false,
                "searchKey": "flate.TestIssue6255",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue6255(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue6255(t *testing.T)\n```\n\nThe following test should not panic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestInvalidEncoding",
              "documentation": {
                "identifier": "TestInvalidEncoding",
                "newPage": false,
                "searchKey": "flate.TestInvalidEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInvalidEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInvalidEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestInvalidBits",
              "documentation": {
                "identifier": "TestInvalidBits",
                "newPage": false,
                "searchKey": "flate.TestInvalidBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInvalidBits(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInvalidBits(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestStreams",
              "documentation": {
                "identifier": "TestStreams",
                "newPage": false,
                "searchKey": "flate.TestStreams",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestStreams(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestStreams(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestTruncatedStreams",
              "documentation": {
                "identifier": "TestTruncatedStreams",
                "newPage": false,
                "searchKey": "flate.TestTruncatedStreams",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTruncatedStreams(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTruncatedStreams(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestReaderEarlyEOF",
              "documentation": {
                "identifier": "TestReaderEarlyEOF",
                "newPage": false,
                "searchKey": "flate.TestReaderEarlyEOF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReaderEarlyEOF(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReaderEarlyEOF(t *testing.T)\n```\n\nVerify that flate.Reader.Read returns (n, io.EOF) instead of (n, nil) + (0, io.EOF) when possible. \n\nThis helps net/http.Transport reuse HTTP/1 connections more aggressively. \n\nSee [https://github.com/google/go-github/pull/317](https://github.com/google/go-github/pull/317) for background. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestBlockHuff",
              "documentation": {
                "identifier": "TestBlockHuff",
                "newPage": false,
                "searchKey": "flate.TestBlockHuff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBlockHuff(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBlockHuff(t *testing.T)\n```\n\nTestBlockHuff tests huffman encoding against reference files to detect possible regressions. If encoding/bit allocation changes you can regenerate these files by using the -update flag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#testBlockHuff",
              "documentation": {
                "identifier": "testBlockHuff",
                "newPage": false,
                "searchKey": "flate.testBlockHuff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testBlockHuff(t *testing.T, in, out string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testBlockHuff(t *testing.T, in, out string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestWriteBlock",
              "documentation": {
                "identifier": "TestWriteBlock",
                "newPage": false,
                "searchKey": "flate.TestWriteBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteBlock(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteBlock(t *testing.T)\n```\n\nTestWriteBlock tests if the writeBlock encoding has changed. To update the reference files use the \"-update\" flag on the test. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestWriteBlockDynamic",
              "documentation": {
                "identifier": "TestWriteBlockDynamic",
                "newPage": false,
                "searchKey": "flate.TestWriteBlockDynamic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteBlockDynamic(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteBlockDynamic(t *testing.T)\n```\n\nTestWriteBlockDynamic tests if the writeBlockDynamic encoding has changed. To update the reference files use the \"-update\" flag on the test. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#testBlock",
              "documentation": {
                "identifier": "testBlock",
                "newPage": false,
                "searchKey": "flate.testBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testBlock(t *testing.T, test huffTest, ttype string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testBlock(t *testing.T, test huffTest, ttype string)\n```\n\ntestBlock tests a block against its references, or regenerate the references, if \"-update\" flag is set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#writeToType",
              "documentation": {
                "identifier": "writeToType",
                "newPage": false,
                "searchKey": "flate.writeToType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeToType(t *testing.T, ttype string, bw *huffmanBitWriter, tok []token, input []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeToType(t *testing.T, ttype string, bw *huffmanBitWriter, tok []token, input []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#testWriterEOF",
              "documentation": {
                "identifier": "testWriterEOF",
                "newPage": false,
                "searchKey": "flate.testWriterEOF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testWriterEOF(t *testing.T, ttype string, test huffTest, useInput bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testWriterEOF(t *testing.T, ttype string, test huffTest, useInput bool)\n```\n\ntestWriterEOF tests if the written block contains an EOF marker. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestReset",
              "documentation": {
                "identifier": "TestReset",
                "newPage": false,
                "searchKey": "flate.TestReset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReset(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReset(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestReaderTruncated",
              "documentation": {
                "identifier": "TestReaderTruncated",
                "newPage": false,
                "searchKey": "flate.TestReaderTruncated",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReaderTruncated(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReaderTruncated(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestResetDict",
              "documentation": {
                "identifier": "TestResetDict",
                "newPage": false,
                "searchKey": "flate.TestResetDict",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResetDict(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResetDict(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestNlitOutOfRange",
              "documentation": {
                "identifier": "TestNlitOutOfRange",
                "newPage": false,
                "searchKey": "flate.TestNlitOutOfRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNlitOutOfRange(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNlitOutOfRange(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#BenchmarkDecode",
              "documentation": {
                "identifier": "BenchmarkDecode",
                "newPage": false,
                "searchKey": "flate.BenchmarkDecode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkDecode(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkDecode(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#doBench",
              "documentation": {
                "identifier": "doBench",
                "newPage": false,
                "searchKey": "flate.doBench",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func doBench(b *testing.B, f func(b *testing.B, buf []byte, level, n int))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc doBench(b *testing.B, f func(b *testing.B, buf []byte, level, n int))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#BenchmarkEncode",
              "documentation": {
                "identifier": "BenchmarkEncode",
                "newPage": false,
                "searchKey": "flate.BenchmarkEncode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkEncode(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkEncode(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestWriteError",
              "documentation": {
                "identifier": "TestWriteError",
                "newPage": false,
                "searchKey": "flate.TestWriteError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteError(t *testing.T)\n```\n\nTest if errors from the underlying writer is passed upwards. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestDeterministic",
              "documentation": {
                "identifier": "TestDeterministic",
                "newPage": false,
                "searchKey": "flate.TestDeterministic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDeterministic(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDeterministic(t *testing.T)\n```\n\nTest if two runs produce identical results even when writing different sizes to the Writer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#testDeterministic",
              "documentation": {
                "identifier": "testDeterministic",
                "newPage": false,
                "searchKey": "flate.testDeterministic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testDeterministic(i int, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testDeterministic(i int, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/flate#TestDeflateFast_Reset",
              "documentation": {
                "identifier": "TestDeflateFast_Reset",
                "newPage": false,
                "searchKey": "flate.TestDeflateFast_Reset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDeflateFast_Reset(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDeflateFast_Reset(t *testing.T)\n```\n\nTestDeflateFast_Reset will test that encoding is consistent across a warparound of the table offset. See [https://github.com/golang/go/issues/34121](https://github.com/golang/go/issues/34121) \n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
