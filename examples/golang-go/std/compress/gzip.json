{
  "pathID": "/std/compress/gzip",
  "documentation": {
    "identifier": "gzip",
    "newPage": true,
    "searchKey": "std/compress/gzip",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package gzip"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/std/compress/gzip#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/compress/gzip#gzipID1",
              "documentation": {
                "identifier": "gzipID1",
                "newPage": false,
                "searchKey": "gzip.gzipID1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gzipID1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gzipID1 = 0x1f\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#gzipID2",
              "documentation": {
                "identifier": "gzipID2",
                "newPage": false,
                "searchKey": "gzip.gzipID2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gzipID2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gzipID2 = 0x8b\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#gzipDeflate",
              "documentation": {
                "identifier": "gzipDeflate",
                "newPage": false,
                "searchKey": "gzip.gzipDeflate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gzipDeflate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gzipDeflate = 8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#flagText",
              "documentation": {
                "identifier": "flagText",
                "newPage": false,
                "searchKey": "gzip.flagText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagText = 1 << 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#flagHdrCrc",
              "documentation": {
                "identifier": "flagHdrCrc",
                "newPage": false,
                "searchKey": "gzip.flagHdrCrc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagHdrCrc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagHdrCrc = 1 << 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#flagExtra",
              "documentation": {
                "identifier": "flagExtra",
                "newPage": false,
                "searchKey": "gzip.flagExtra",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagExtra"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagExtra = 1 << 2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#flagName",
              "documentation": {
                "identifier": "flagName",
                "newPage": false,
                "searchKey": "gzip.flagName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagName = 1 << 3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#flagComment",
              "documentation": {
                "identifier": "flagComment",
                "newPage": false,
                "searchKey": "gzip.flagComment",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const flagComment"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst flagComment = 1 << 4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#NoCompression",
              "documentation": {
                "identifier": "NoCompression",
                "newPage": false,
                "searchKey": "gzip.NoCompression",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const NoCompression"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst NoCompression = flate.NoCompression\n```\n\nThese constants are copied from the flate package, so that code that imports \"compress/gzip\" does not also have to import \"compress/flate\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#BestSpeed",
              "documentation": {
                "identifier": "BestSpeed",
                "newPage": false,
                "searchKey": "gzip.BestSpeed",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const BestSpeed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst BestSpeed = flate.BestSpeed\n```\n\nThese constants are copied from the flate package, so that code that imports \"compress/gzip\" does not also have to import \"compress/flate\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#BestCompression",
              "documentation": {
                "identifier": "BestCompression",
                "newPage": false,
                "searchKey": "gzip.BestCompression",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const BestCompression"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst BestCompression = flate.BestCompression\n```\n\nThese constants are copied from the flate package, so that code that imports \"compress/gzip\" does not also have to import \"compress/flate\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#DefaultCompression",
              "documentation": {
                "identifier": "DefaultCompression",
                "newPage": false,
                "searchKey": "gzip.DefaultCompression",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const DefaultCompression"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DefaultCompression = flate.DefaultCompression\n```\n\nThese constants are copied from the flate package, so that code that imports \"compress/gzip\" does not also have to import \"compress/flate\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#HuffmanOnly",
              "documentation": {
                "identifier": "HuffmanOnly",
                "newPage": false,
                "searchKey": "gzip.HuffmanOnly",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const HuffmanOnly"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst HuffmanOnly = flate.HuffmanOnly\n```\n\nThese constants are copied from the flate package, so that code that imports \"compress/gzip\" does not also have to import \"compress/flate\". \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/compress/gzip#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/compress/gzip#ErrChecksum",
              "documentation": {
                "identifier": "ErrChecksum",
                "newPage": false,
                "searchKey": "gzip.ErrChecksum",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrChecksum"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrChecksum = errors.New(\"gzip: invalid checksum\")\n```\n\nErrChecksum is returned when reading GZIP data that has an invalid checksum. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#ErrHeader",
              "documentation": {
                "identifier": "ErrHeader",
                "newPage": false,
                "searchKey": "gzip.ErrHeader",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrHeader = errors.New(\"gzip: invalid header\")\n```\n\nErrHeader is returned when reading GZIP data that has an invalid header. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#le",
              "documentation": {
                "identifier": "le",
                "newPage": false,
                "searchKey": "gzip.le",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var le"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar le = binary.LittleEndian\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#gunzipTests",
              "documentation": {
                "identifier": "gunzipTests",
                "newPage": false,
                "searchKey": "gzip.gunzipTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gunzipTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gunzipTests = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/compress/gzip#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/compress/gzip#Header",
              "documentation": {
                "identifier": "Header",
                "newPage": false,
                "searchKey": "gzip.Header",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Header struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Header struct {\n\tComment string    // comment\n\tExtra   []byte    // \"extra data\"\n\tModTime time.Time // modification time\n\tName    string    // file name\n\tOS      byte      // operating system type\n}\n```\n\nThe gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs. \n\nStrings must be UTF-8 encoded and may only contain Unicode code points U+0001 through U+00FF, due to limitations of the GZIP file format. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#Reader",
              "documentation": {
                "identifier": "Reader",
                "newPage": false,
                "searchKey": "gzip.Reader",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Reader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Reader struct {\n\tHeader       // valid after NewReader or Reader.Reset\n\tr            flate.Reader\n\tdecompressor io.ReadCloser\n\tdigest       uint32 // CRC-32, IEEE polynomial (section 8)\n\tsize         uint32 // Uncompressed size (section 2.3.1)\n\tbuf          [512]byte\n\terr          error\n\tmultistream  bool\n}\n```\n\nA Reader is an io.Reader that can be read to retrieve uncompressed data from a gzip-format compressed file. \n\nIn general, a gzip file can be a concatenation of gzip files, each with its own header. Reads from the Reader return the concatenation of the uncompressed data of each. Only the first header is recorded in the Reader fields. \n\nGzip files store a length and checksum of the uncompressed data. The Reader will return an ErrChecksum when Read reaches the end of the uncompressed data if it does not have the expected length or checksum. Clients should treat data returned by Read as tentative until they receive the io.EOF marking the end of the data. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/gzip#NewReader",
                    "documentation": {
                      "identifier": "NewReader",
                      "newPage": false,
                      "searchKey": "gzip.NewReader",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewReader(r io.Reader) (*Reader, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewReader(r io.Reader) (*Reader, error)\n```\n\nNewReader creates a new Reader reading the given reader. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. \n\nIt is the caller's responsibility to call Close on the Reader when done. \n\nThe Reader.Header fields will be valid in the Reader returned. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Reader.Reset",
                    "documentation": {
                      "identifier": "Reader.Reset",
                      "newPage": false,
                      "searchKey": "gzip.Reader.Reset",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Reader) Reset(r io.Reader) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Reader) Reset(r io.Reader) error\n```\n\nReset discards the Reader z's state and makes it equivalent to the result of its original state from NewReader, but reading from r instead. This permits reusing a Reader rather than allocating a new one. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Reader.Multistream",
                    "documentation": {
                      "identifier": "Reader.Multistream",
                      "newPage": false,
                      "searchKey": "gzip.Reader.Multistream",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Reader) Multistream(ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Reader) Multistream(ok bool)\n```\n\nMultistream controls whether the reader supports multistream files. \n\nIf enabled (the default), the Reader expects the input to be a sequence of individually gzipped data streams, each with its own header and trailer, ending at EOF. The effect is that the concatenation of a sequence of gzipped files is treated as equivalent to the gzip of the concatenation of the sequence. This is standard behavior for gzip readers. \n\nCalling Multistream(false) disables this behavior; disabling the behavior can be useful when reading file formats that distinguish individual gzip data streams or mix gzip data streams with other data streams. In this mode, when the Reader reaches the end of the data stream, Read returns io.EOF. The underlying reader must implement io.ByteReader in order to be left positioned just after the gzip stream. To start the next stream, call z.Reset(r) followed by z.Multistream(false). If there is no next stream, z.Reset(r) will return io.EOF. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Reader.readString",
                    "documentation": {
                      "identifier": "Reader.readString",
                      "newPage": false,
                      "searchKey": "gzip.Reader.readString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Reader) readString() (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Reader) readString() (string, error)\n```\n\nreadString reads a NUL-terminated string from z.r. It treats the bytes read as being encoded as ISO 8859-1 (Latin-1) and will output a string encoded using UTF-8. This method always updates z.digest with the data read. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Reader.readHeader",
                    "documentation": {
                      "identifier": "Reader.readHeader",
                      "newPage": false,
                      "searchKey": "gzip.Reader.readHeader",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Reader) readHeader() (hdr Header, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Reader) readHeader() (hdr Header, err error)\n```\n\nreadHeader reads the GZIP header according to section 2.3.1. This method does not set z.err. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Reader.Read",
                    "documentation": {
                      "identifier": "Reader.Read",
                      "newPage": false,
                      "searchKey": "gzip.Reader.Read",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Reader) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Reader) Read(p []byte) (n int, err error)\n```\n\nRead implements io.Reader, reading uncompressed bytes from its underlying Reader. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Reader.Close",
                    "documentation": {
                      "identifier": "Reader.Close",
                      "newPage": false,
                      "searchKey": "gzip.Reader.Close",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Reader) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Reader) Close() error\n```\n\nClose closes the Reader. It does not close the underlying io.Reader. In order for the GZIP checksum to be verified, the reader must be fully consumed until the io.EOF. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#Writer",
              "documentation": {
                "identifier": "Writer",
                "newPage": false,
                "searchKey": "gzip.Writer",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Writer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Writer struct {\n\tHeader      // written at first call to Write, Flush, or Close\n\tw           io.Writer\n\tlevel       int\n\twroteHeader bool\n\tcompressor  *flate.Writer\n\tdigest      uint32 // CRC-32, IEEE polynomial (section 8)\n\tsize        uint32 // Uncompressed size (section 2.3.1)\n\tclosed      bool\n\tbuf         [10]byte\n\terr         error\n}\n```\n\nA Writer is an io.WriteCloser. Writes to a Writer are compressed and written to w. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/gzip#NewWriter",
                    "documentation": {
                      "identifier": "NewWriter",
                      "newPage": false,
                      "searchKey": "gzip.NewWriter",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewWriter(w io.Writer) *Writer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewWriter(w io.Writer) *Writer\n```\n\nNewWriter returns a new Writer. Writes to the returned writer are compressed and written to w. \n\nIt is the caller's responsibility to call Close on the Writer when done. Writes may be buffered and not flushed until Close. \n\nCallers that wish to set the fields in Writer.Header must do so before the first call to Write, Flush, or Close. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#NewWriterLevel",
                    "documentation": {
                      "identifier": "NewWriterLevel",
                      "newPage": false,
                      "searchKey": "gzip.NewWriterLevel",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewWriterLevel(w io.Writer, level int) (*Writer, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewWriterLevel(w io.Writer, level int) (*Writer, error)\n```\n\nNewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression. \n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Writer.init",
                    "documentation": {
                      "identifier": "Writer.init",
                      "newPage": false,
                      "searchKey": "gzip.Writer.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Writer) init(w io.Writer, level int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Writer) init(w io.Writer, level int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Writer.Reset",
                    "documentation": {
                      "identifier": "Writer.Reset",
                      "newPage": false,
                      "searchKey": "gzip.Writer.Reset",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Writer) Reset(w io.Writer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Writer) Reset(w io.Writer)\n```\n\nReset discards the Writer z's state and makes it equivalent to the result of its original state from NewWriter or NewWriterLevel, but writing to w instead. This permits reusing a Writer rather than allocating a new one. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Writer.writeBytes",
                    "documentation": {
                      "identifier": "Writer.writeBytes",
                      "newPage": false,
                      "searchKey": "gzip.Writer.writeBytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Writer) writeBytes(b []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Writer) writeBytes(b []byte) error\n```\n\nwriteBytes writes a length-prefixed byte slice to z.w. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Writer.writeString",
                    "documentation": {
                      "identifier": "Writer.writeString",
                      "newPage": false,
                      "searchKey": "gzip.Writer.writeString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Writer) writeString(s string) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Writer) writeString(s string) (err error)\n```\n\nwriteString writes a UTF-8 string s in GZIP's format to z.w. GZIP (RFC 1952) specifies that strings are NUL-terminated ISO 8859-1 (Latin-1). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Writer.Write",
                    "documentation": {
                      "identifier": "Writer.Write",
                      "newPage": false,
                      "searchKey": "gzip.Writer.Write",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Writer) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Writer) Write(p []byte) (int, error)\n```\n\nWrite writes a compressed form of p to the underlying io.Writer. The compressed bytes are not necessarily flushed until the Writer is closed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Writer.Flush",
                    "documentation": {
                      "identifier": "Writer.Flush",
                      "newPage": false,
                      "searchKey": "gzip.Writer.Flush",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Writer) Flush() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Writer) Flush() error\n```\n\nFlush flushes any pending compressed data to the underlying writer. \n\nIt is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. If the underlying writer returns an error, Flush returns that error. \n\nIn the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/compress/gzip#Writer.Close",
                    "documentation": {
                      "identifier": "Writer.Close",
                      "newPage": false,
                      "searchKey": "gzip.Writer.Close",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Writer) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Writer) Close() error\n```\n\nClose closes the Writer by flushing any unwritten data to the underlying io.Writer and writing the GZIP footer. It does not close the underlying io.Writer. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#gunzipTest",
              "documentation": {
                "identifier": "gunzipTest",
                "newPage": false,
                "searchKey": "gzip.gunzipTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gunzipTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gunzipTest struct {\n\tname string\n\tdesc string\n\traw  string\n\tgzip []byte\n\terr  error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#limitedWriter",
              "documentation": {
                "identifier": "limitedWriter",
                "newPage": false,
                "searchKey": "gzip.limitedWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type limitedWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype limitedWriter struct {\n\tN int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/compress/gzip#limitedWriter.Write",
                    "documentation": {
                      "identifier": "limitedWriter.Write",
                      "newPage": false,
                      "searchKey": "gzip.limitedWriter.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *limitedWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *limitedWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/compress/gzip#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/compress/gzip#noEOF",
              "documentation": {
                "identifier": "noEOF",
                "newPage": false,
                "searchKey": "gzip.noEOF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func noEOF(err error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc noEOF(err error) error\n```\n\nnoEOF converts io.EOF to io.ErrUnexpectedEOF. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestDecompressor",
              "documentation": {
                "identifier": "TestDecompressor",
                "newPage": false,
                "searchKey": "gzip.TestDecompressor",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDecompressor(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDecompressor(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestIssue6550",
              "documentation": {
                "identifier": "TestIssue6550",
                "newPage": false,
                "searchKey": "gzip.TestIssue6550",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue6550(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue6550(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestMultistreamFalse",
              "documentation": {
                "identifier": "TestMultistreamFalse",
                "newPage": false,
                "searchKey": "gzip.TestMultistreamFalse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMultistreamFalse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMultistreamFalse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestNilStream",
              "documentation": {
                "identifier": "TestNilStream",
                "newPage": false,
                "searchKey": "gzip.TestNilStream",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNilStream(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNilStream(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestTruncatedStreams",
              "documentation": {
                "identifier": "TestTruncatedStreams",
                "newPage": false,
                "searchKey": "gzip.TestTruncatedStreams",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTruncatedStreams(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTruncatedStreams(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestEmpty",
              "documentation": {
                "identifier": "TestEmpty",
                "newPage": false,
                "searchKey": "gzip.TestEmpty",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEmpty(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEmpty(t *testing.T)\n```\n\nTestEmpty tests that an empty payload still forms a valid GZIP stream. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestRoundTrip",
              "documentation": {
                "identifier": "TestRoundTrip",
                "newPage": false,
                "searchKey": "gzip.TestRoundTrip",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRoundTrip(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRoundTrip(t *testing.T)\n```\n\nTestRoundTrip tests that gzipping and then gunzipping is the identity function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestLatin1",
              "documentation": {
                "identifier": "TestLatin1",
                "newPage": false,
                "searchKey": "gzip.TestLatin1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLatin1(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLatin1(t *testing.T)\n```\n\nTestLatin1 tests the internal functions for converting to and from Latin-1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestLatin1RoundTrip",
              "documentation": {
                "identifier": "TestLatin1RoundTrip",
                "newPage": false,
                "searchKey": "gzip.TestLatin1RoundTrip",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLatin1RoundTrip(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLatin1RoundTrip(t *testing.T)\n```\n\nTestLatin1RoundTrip tests that metadata that is representable in Latin-1 survives a round trip. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestWriterFlush",
              "documentation": {
                "identifier": "TestWriterFlush",
                "newPage": false,
                "searchKey": "gzip.TestWriterFlush",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriterFlush(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriterFlush(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestConcat",
              "documentation": {
                "identifier": "TestConcat",
                "newPage": false,
                "searchKey": "gzip.TestConcat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConcat(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConcat(t *testing.T)\n```\n\nMultiple gzip files concatenated form a valid gzip file. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestWriterReset",
              "documentation": {
                "identifier": "TestWriterReset",
                "newPage": false,
                "searchKey": "gzip.TestWriterReset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriterReset(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriterReset(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestLimitedWrite",
              "documentation": {
                "identifier": "TestLimitedWrite",
                "newPage": false,
                "searchKey": "gzip.TestLimitedWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLimitedWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLimitedWrite(t *testing.T)\n```\n\nWrite should never return more bytes than the input slice. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#TestGZIPFilesHaveZeroMTimes",
              "documentation": {
                "identifier": "TestGZIPFilesHaveZeroMTimes",
                "newPage": false,
                "searchKey": "gzip.TestGZIPFilesHaveZeroMTimes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGZIPFilesHaveZeroMTimes(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGZIPFilesHaveZeroMTimes(t *testing.T)\n```\n\nTestGZIPFilesHaveZeroMTimes checks that every .gz file in the tree has a zero MTIME. This is a requirement for the Debian maintainers to be able to have deterministic packages. \n\nSee [https://golang.org/issue/14937](https://golang.org/issue/14937). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/compress/gzip#checkZeroMTime",
              "documentation": {
                "identifier": "checkZeroMTime",
                "newPage": false,
                "searchKey": "gzip.checkZeroMTime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkZeroMTime(t *testing.T, path string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkZeroMTime(t *testing.T, path string)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
