{
  "pathID": "/os/exec",
  "documentation": {
    "identifier": "exec",
    "newPage": true,
    "searchKey": "os/exec",
    "tags": [
      "package"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package exec"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package exec runs external commands. It wraps os.StartProcess to make it easier to remap stdin and stdout, connect I/O with pipes, and do other adjustments. \n\nUnlike the \"system\" library call from C and other languages, the os/exec package intentionally does not invoke the system shell and does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells. The package behaves more like C's \"exec\" family of functions. To expand glob patterns, either call the shell directly, taking care to escape any dangerous input, or use the path/filepath package's Glob function. To expand environment variables, use package os's ExpandEnv. \n\nNote that the examples in this package assume a Unix system. They may not run on Windows, and they do not run in the Go Playground used by golang.org and godoc.org. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/os/exec#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/os/exec#ErrNotFound",
              "documentation": {
                "identifier": "ErrNotFound",
                "newPage": false,
                "searchKey": "exec.ErrNotFound",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrNotFound"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrNotFound = errors.New(\"executable file not found in $PATH\")\n```\n\nErrNotFound is the error resulting if a path search failed to find an executable file. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#nonExistentPaths",
              "documentation": {
                "identifier": "nonExistentPaths",
                "newPage": false,
                "searchKey": "exec.nonExistentPaths",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var nonExistentPaths"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar nonExistentPaths = []string{\n\t\"some-non-existent-path\",\n\t\"non-existent-path/slashed\",\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#skipStdinCopyError",
              "documentation": {
                "identifier": "skipStdinCopyError",
                "newPage": false,
                "searchKey": "exec.skipStdinCopyError",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var skipStdinCopyError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar skipStdinCopyError func(error) bool\n```\n\nskipStdinCopyError optionally specifies a function which reports whether the provided stdin copy error should be ignored. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/os/exec#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/os/exec#Cmd",
              "documentation": {
                "identifier": "Cmd",
                "newPage": false,
                "searchKey": "exec.Cmd",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Cmd struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Cmd struct {\n\t// Path is the path of the command to run.\n\t//\n\t// This is the only field that must be set to a non-zero\n\t// value. If Path is relative, it is evaluated relative\n\t// to Dir.\n\tPath string\n\n\t// Args holds command line arguments, including the command as Args[0].\n\t// If the Args field is empty or nil, Run uses {Path}.\n\t//\n\t// In typical use, both Path and Args are set by calling Command.\n\tArgs []string\n\n\t// Env specifies the environment of the process.\n\t// Each entry is of the form \"key=value\".\n\t// If Env is nil, the new process uses the current process's\n\t// environment.\n\t// If Env contains duplicate environment keys, only the last\n\t// value in the slice for each duplicate key is used.\n\t// As a special case on Windows, SYSTEMROOT is always added if\n\t// missing and not explicitly set to the empty string.\n\tEnv []string\n\n\t// Dir specifies the working directory of the command.\n\t// If Dir is the empty string, Run runs the command in the\n\t// calling process's current directory.\n\tDir string\n\n\t// Stdin specifies the process's standard input.\n\t//\n\t// If Stdin is nil, the process reads from the null device (os.DevNull).\n\t//\n\t// If Stdin is an *os.File, the process's standard input is connected\n\t// directly to that file.\n\t//\n\t// Otherwise, during the execution of the command a separate\n\t// goroutine reads from Stdin and delivers that data to the command\n\t// over a pipe. In this case, Wait does not complete until the goroutine\n\t// stops copying, either because it has reached the end of Stdin\n\t// (EOF or a read error) or because writing to the pipe returned an error.\n\tStdin io.Reader\n\n\t// Stdout and Stderr specify the process's standard output and error.\n\t//\n\t// If either is nil, Run connects the corresponding file descriptor\n\t// to the null device (os.DevNull).\n\t//\n\t// If either is an *os.File, the corresponding output from the process\n\t// is connected directly to that file.\n\t//\n\t// Otherwise, during the execution of the command a separate goroutine\n\t// reads from the process over a pipe and delivers that data to the\n\t// corresponding Writer. In this case, Wait does not complete until the\n\t// goroutine reaches EOF or encounters an error.\n\t//\n\t// If Stdout and Stderr are the same writer, and have a type that can\n\t// be compared with ==, at most one goroutine at a time will call Write.\n\tStdout io.Writer\n\tStderr io.Writer\n\n\t// ExtraFiles specifies additional open files to be inherited by the\n\t// new process. It does not include standard input, standard output, or\n\t// standard error. If non-nil, entry i becomes file descriptor 3+i.\n\t//\n\t// ExtraFiles is not supported on Windows.\n\tExtraFiles []*os.File\n\n\t// SysProcAttr holds optional, operating system-specific attributes.\n\t// Run passes it to os.StartProcess as the os.ProcAttr's Sys field.\n\tSysProcAttr *syscall.SysProcAttr\n\n\t// Process is the underlying process, once started.\n\tProcess *os.Process\n\n\t// ProcessState contains information about an exited process,\n\t// available after a call to Wait or Run.\n\tProcessState *os.ProcessState\n\n\tctx             context.Context // nil means none\n\tlookPathErr     error           // LookPath error, if any.\n\tfinished        bool            // when Wait was called\n\tchildFiles      []*os.File\n\tcloseAfterStart []io.Closer\n\tcloseAfterWait  []io.Closer\n\tgoroutine       []func() error\n\terrch           chan error // one send per goroutine\n\twaitDone        chan struct{}\n}\n```\n\nCmd represents an external command being prepared or run. \n\nA Cmd cannot be reused after calling its Run, Output or CombinedOutput methods. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/os/exec#Command",
                    "documentation": {
                      "identifier": "Command",
                      "newPage": false,
                      "searchKey": "exec.Command",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Command(name string, arg ...string) *Cmd"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Command(name string, arg ...string) *Cmd\n```\n\nCommand returns the Cmd struct to execute the named program with the given arguments. \n\nIt sets only the Path and Args in the returned structure. \n\nIf name contains no path separators, Command uses LookPath to resolve name to a complete path if possible. Otherwise it uses name directly as Path. \n\nThe returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(\"echo\", \"hello\"). Args[0] is always name, not the possibly resolved Path. \n\nOn Windows, processes receive the whole command line as a single string and do their own parsing. Command combines and quotes Args into a command line string with an algorithm compatible with applications using CommandLineToArgvW (which is the most common way). Notable exceptions are msiexec.exe and cmd.exe (and thus, all batch files), which have a different unquoting algorithm. In these or other similar cases, you can do the quoting yourself and provide the full command line in SysProcAttr.CmdLine, leaving Args empty. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#CommandContext",
                    "documentation": {
                      "identifier": "CommandContext",
                      "newPage": false,
                      "searchKey": "exec.CommandContext",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func CommandContext(ctx context.Context, name string, arg ...string) *Cmd"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc CommandContext(ctx context.Context, name string, arg ...string) *Cmd\n```\n\nCommandContext is like Command but includes a context. \n\nThe provided context is used to kill the process (by calling os.Process.Kill) if the context becomes done before the command completes on its own. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.CombinedOutput",
                    "documentation": {
                      "identifier": "Cmd.CombinedOutput",
                      "newPage": false,
                      "searchKey": "exec.Cmd.CombinedOutput",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) CombinedOutput() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) CombinedOutput() ([]byte, error)\n```\n\nCombinedOutput runs the command and returns its combined standard output and standard error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.Output",
                    "documentation": {
                      "identifier": "Cmd.Output",
                      "newPage": false,
                      "searchKey": "exec.Cmd.Output",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) Output() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) Output() ([]byte, error)\n```\n\nOutput runs the command and returns its standard output. Any returned error will usually be of type *ExitError. If c.Stderr was nil, Output populates ExitError.Stderr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.Run",
                    "documentation": {
                      "identifier": "Cmd.Run",
                      "newPage": false,
                      "searchKey": "exec.Cmd.Run",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) Run() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) Run() error\n```\n\nRun starts the specified command and waits for it to complete. \n\nThe returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status. \n\nIf the command starts but does not complete successfully, the error is of type *ExitError. Other error types may be returned for other situations. \n\nIf the calling goroutine has locked the operating system thread with runtime.LockOSThread and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.Start",
                    "documentation": {
                      "identifier": "Cmd.Start",
                      "newPage": false,
                      "searchKey": "exec.Cmd.Start",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) Start() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) Start() error\n```\n\nStart starts the specified command but does not wait for it to complete. \n\nIf Start returns successfully, the c.Process field will be set. \n\nThe Wait method will return the exit code and release associated resources once the command exits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.StderrPipe",
                    "documentation": {
                      "identifier": "Cmd.StderrPipe",
                      "newPage": false,
                      "searchKey": "exec.Cmd.StderrPipe",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) StderrPipe() (io.ReadCloser, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) StderrPipe() (io.ReadCloser, error)\n```\n\nStderrPipe returns a pipe that will be connected to the command's standard error when the command starts. \n\nWait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.StdinPipe",
                    "documentation": {
                      "identifier": "Cmd.StdinPipe",
                      "newPage": false,
                      "searchKey": "exec.Cmd.StdinPipe",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) StdinPipe() (io.WriteCloser, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) StdinPipe() (io.WriteCloser, error)\n```\n\nStdinPipe returns a pipe that will be connected to the command's standard input when the command starts. The pipe will be closed automatically after Wait sees the command exit. A caller need only call Close to force the pipe to close sooner. For example, if the command being run will not exit until standard input is closed, the caller must close the pipe. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.StdoutPipe",
                    "documentation": {
                      "identifier": "Cmd.StdoutPipe",
                      "newPage": false,
                      "searchKey": "exec.Cmd.StdoutPipe",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) StdoutPipe() (io.ReadCloser, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) StdoutPipe() (io.ReadCloser, error)\n```\n\nStdoutPipe returns a pipe that will be connected to the command's standard output when the command starts. \n\nWait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.String",
                    "documentation": {
                      "identifier": "Cmd.String",
                      "newPage": false,
                      "searchKey": "exec.Cmd.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) String() string\n```\n\nString returns a human-readable description of c. It is intended only for debugging. In particular, it is not suitable for use as input to a shell. The output of String may vary across Go releases. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.Wait",
                    "documentation": {
                      "identifier": "Cmd.Wait",
                      "newPage": false,
                      "searchKey": "exec.Cmd.Wait",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) Wait() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) Wait() error\n```\n\nWait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete. \n\nThe command must have been started by Start. \n\nThe returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status. \n\nIf the command fails to run or doesn't complete successfully, the error is of type *ExitError. Other error types may be returned for I/O problems. \n\nIf any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits for the respective I/O loop copying to or from the process to complete. \n\nWait releases any resources associated with the Cmd. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.argv",
                    "documentation": {
                      "identifier": "Cmd.argv",
                      "newPage": false,
                      "searchKey": "exec.Cmd.argv",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) argv() []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) argv() []string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.closeDescriptors",
                    "documentation": {
                      "identifier": "Cmd.closeDescriptors",
                      "newPage": false,
                      "searchKey": "exec.Cmd.closeDescriptors",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) closeDescriptors(closers []io.Closer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) closeDescriptors(closers []io.Closer)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.envv",
                    "documentation": {
                      "identifier": "Cmd.envv",
                      "newPage": false,
                      "searchKey": "exec.Cmd.envv",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) envv() ([]string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) envv() ([]string, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.stderr",
                    "documentation": {
                      "identifier": "Cmd.stderr",
                      "newPage": false,
                      "searchKey": "exec.Cmd.stderr",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) stderr() (f *os.File, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) stderr() (f *os.File, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.stdin",
                    "documentation": {
                      "identifier": "Cmd.stdin",
                      "newPage": false,
                      "searchKey": "exec.Cmd.stdin",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) stdin() (f *os.File, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) stdin() (f *os.File, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.stdout",
                    "documentation": {
                      "identifier": "Cmd.stdout",
                      "newPage": false,
                      "searchKey": "exec.Cmd.stdout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) stdout() (f *os.File, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) stdout() (f *os.File, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Cmd.writerDescriptor",
                    "documentation": {
                      "identifier": "Cmd.writerDescriptor",
                      "newPage": false,
                      "searchKey": "exec.Cmd.writerDescriptor",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/os/exec#Error",
              "documentation": {
                "identifier": "Error",
                "newPage": false,
                "searchKey": "exec.Error",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Error struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Error struct {\n\t// Name is the file name for which the error occurred.\n\tName string\n\t// Err is the underlying error.\n\tErr error\n}\n```\n\nError is returned by LookPath when it fails to classify a file as an executable. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/os/exec#Error.Error",
                    "documentation": {
                      "identifier": "Error.Error",
                      "newPage": false,
                      "searchKey": "exec.Error.Error",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *Error) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *Error) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#Error.Unwrap",
                    "documentation": {
                      "identifier": "Error.Unwrap",
                      "newPage": false,
                      "searchKey": "exec.Error.Unwrap",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *Error) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *Error) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/os/exec#ExitError",
              "documentation": {
                "identifier": "ExitError",
                "newPage": false,
                "searchKey": "exec.ExitError",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ExitError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ExitError struct {\n\t*os.ProcessState\n\n\t// Stderr holds a subset of the standard error output from the\n\t// Cmd.Output method if standard error was not otherwise being\n\t// collected.\n\t//\n\t// If the error output is long, Stderr may contain only a prefix\n\t// and suffix of the output, with the middle replaced with\n\t// text about the number of omitted bytes.\n\t//\n\t// Stderr is provided for debugging, for inclusion in error messages.\n\t// Users with other needs should redirect Cmd.Stderr as needed.\n\tStderr []byte\n}\n```\n\nAn ExitError reports an unsuccessful exit by a command. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/os/exec#ExitError.Error",
                    "documentation": {
                      "identifier": "ExitError.Error",
                      "newPage": false,
                      "searchKey": "exec.ExitError.Error",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ExitError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ExitError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/os/exec#closeOnce",
              "documentation": {
                "identifier": "closeOnce",
                "newPage": false,
                "searchKey": "exec.closeOnce",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type closeOnce struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype closeOnce struct {\n\t*os.File\n\n\tonce sync.Once\n\terr  error\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/os/exec#closeOnce.Close",
                    "documentation": {
                      "identifier": "closeOnce.Close",
                      "newPage": false,
                      "searchKey": "exec.closeOnce.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *closeOnce) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *closeOnce) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#closeOnce.close",
                    "documentation": {
                      "identifier": "closeOnce.close",
                      "newPage": false,
                      "searchKey": "exec.closeOnce.close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *closeOnce) close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *closeOnce) close()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/os/exec#prefixSuffixSaver",
              "documentation": {
                "identifier": "prefixSuffixSaver",
                "newPage": false,
                "searchKey": "exec.prefixSuffixSaver",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type prefixSuffixSaver struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype prefixSuffixSaver struct {\n\tN         int // max size of prefix or suffix\n\tprefix    []byte\n\tsuffix    []byte // ring buffer once len(suffix) == N\n\tsuffixOff int    // offset to write into suffix\n\tskipped   int64\n}\n```\n\nprefixSuffixSaver is an io.Writer which retains the first N bytes and the last N bytes written to it. The Bytes() methods reconstructs it with a pretty error message. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/os/exec#prefixSuffixSaver.Bytes",
                    "documentation": {
                      "identifier": "prefixSuffixSaver.Bytes",
                      "newPage": false,
                      "searchKey": "exec.prefixSuffixSaver.Bytes",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *prefixSuffixSaver) Bytes() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *prefixSuffixSaver) Bytes() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#prefixSuffixSaver.Write",
                    "documentation": {
                      "identifier": "prefixSuffixSaver.Write",
                      "newPage": false,
                      "searchKey": "exec.prefixSuffixSaver.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *prefixSuffixSaver) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *prefixSuffixSaver) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/os/exec#prefixSuffixSaver.fill",
                    "documentation": {
                      "identifier": "prefixSuffixSaver.fill",
                      "newPage": false,
                      "searchKey": "exec.prefixSuffixSaver.fill",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *prefixSuffixSaver) fill(dst *[]byte, p []byte) (pRemain []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *prefixSuffixSaver) fill(dst *[]byte, p []byte) (pRemain []byte)\n```\n\nfill appends up to len(p) bytes of p to *dst, such that *dst does not grow larger than w.N. It returns the un-appended suffix of p. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/os/exec#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/os/exec#BenchmarkExecHostname",
              "documentation": {
                "identifier": "BenchmarkExecHostname",
                "newPage": false,
                "searchKey": "exec.BenchmarkExecHostname",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkExecHostname(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkExecHostname(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#LookPath",
              "documentation": {
                "identifier": "LookPath",
                "newPage": false,
                "searchKey": "exec.LookPath",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookPath(file string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookPath(file string) (string, error)\n```\n\nLookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#TestDedupEnv",
              "documentation": {
                "identifier": "TestDedupEnv",
                "newPage": false,
                "searchKey": "exec.TestDedupEnv",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDedupEnv(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDedupEnv(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#TestLookPathNotFound",
              "documentation": {
                "identifier": "TestLookPathNotFound",
                "newPage": false,
                "searchKey": "exec.TestLookPathNotFound",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookPathNotFound(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookPathNotFound(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#TestLookPathUnixEmptyPath",
              "documentation": {
                "identifier": "TestLookPathUnixEmptyPath",
                "newPage": false,
                "searchKey": "exec.TestLookPathUnixEmptyPath",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLookPathUnixEmptyPath(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLookPathUnixEmptyPath(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#TestPrefixSuffixSaver",
              "documentation": {
                "identifier": "TestPrefixSuffixSaver",
                "newPage": false,
                "searchKey": "exec.TestPrefixSuffixSaver",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPrefixSuffixSaver(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPrefixSuffixSaver(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#addCriticalEnv",
              "documentation": {
                "identifier": "addCriticalEnv",
                "newPage": false,
                "searchKey": "exec.addCriticalEnv",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func addCriticalEnv(env []string) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addCriticalEnv(env []string) []string\n```\n\naddCriticalEnv adds any critical environment variables that are required (or at least almost always required) on the operating system. Currently this is only used for Windows. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#dedupEnv",
              "documentation": {
                "identifier": "dedupEnv",
                "newPage": false,
                "searchKey": "exec.dedupEnv",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func dedupEnv(env []string) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dedupEnv(env []string) []string\n```\n\ndedupEnv returns a copy of env with any duplicates removed, in favor of later values. Items not of the normal environment \"key=value\" form are preserved unchanged. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#dedupEnvCase",
              "documentation": {
                "identifier": "dedupEnvCase",
                "newPage": false,
                "searchKey": "exec.dedupEnvCase",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func dedupEnvCase(caseInsensitive bool, env []string) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dedupEnvCase(caseInsensitive bool, env []string) []string\n```\n\ndedupEnvCase is dedupEnv with a case option for testing. If caseInsensitive is true, the case of keys is ignored. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#findExecutable",
              "documentation": {
                "identifier": "findExecutable",
                "newPage": false,
                "searchKey": "exec.findExecutable",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func findExecutable(file string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc findExecutable(file string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#init.exec_unix.go",
              "documentation": {
                "identifier": "init.exec_unix.go",
                "newPage": false,
                "searchKey": "exec.init",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#interfaceEqual",
              "documentation": {
                "identifier": "interfaceEqual",
                "newPage": false,
                "searchKey": "exec.interfaceEqual",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func interfaceEqual(a, b interface{}) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc interfaceEqual(a, b interface{}) bool\n```\n\ninterfaceEqual protects against panics from doing equality tests on two interfaces with non-comparable underlying types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#lookExtensions",
              "documentation": {
                "identifier": "lookExtensions",
                "newPage": false,
                "searchKey": "exec.lookExtensions",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookExtensions(path, dir string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookExtensions(path, dir string) (string, error)\n```\n\nlookExtensions finds windows executable by its dir and path. It uses LookPath to try appropriate extensions. lookExtensions does not search PATH, instead it converts `prog` into `.\\prog`. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/os/exec#minInt",
              "documentation": {
                "identifier": "minInt",
                "newPage": false,
                "searchKey": "exec.minInt",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func minInt(a, b int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc minInt(a, b int) int\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
